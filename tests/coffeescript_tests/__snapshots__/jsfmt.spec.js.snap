// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`argument_parsing.coffee 1`] = `
return unless require?
{buildCSOptionParser} = require '../lib/coffeescript/command'

optionParser = buildCSOptionParser()

sameOptions = (opts1, opts2, msg) ->
  ownKeys = Object.keys(opts1).sort()
  otherKeys = Object.keys(opts2).sort()
  arrayEq ownKeys, otherKeys, msg
  for k in ownKeys
    arrayEq opts1[k], opts2[k], msg
  yes

test "combined options are not split after initial file name", ->
  argv = ['some-file.coffee', '-bc']
  parsed = optionParser.parse argv
  expected = arguments: ['some-file.coffee', '-bc']
  sameOptions parsed, expected

  argv = ['some-file.litcoffee', '-bc']
  parsed = optionParser.parse argv
  expected = arguments: ['some-file.litcoffee', '-bc']
  sameOptions parsed, expected

  argv = ['-c', 'some-file.coffee', '-bc']
  parsed = optionParser.parse argv
  expected =
    compile: yes
    arguments: ['some-file.coffee', '-bc']
  sameOptions parsed, expected

  argv = ['-bc', 'some-file.coffee', '-bc']
  parsed = optionParser.parse argv
  expected =
    bare: yes
    compile: yes
    arguments: ['some-file.coffee', '-bc']
  sameOptions parsed, expected

test "combined options are not split after a '--', which is discarded", ->
  argv = ['--', '-bc']
  parsed = optionParser.parse argv
  expected =
    doubleDashed: yes
    arguments: ['-bc']
  sameOptions parsed, expected

  argv = ['-bc', '--', '-bc']
  parsed = optionParser.parse argv
  expected =
    bare: yes
    compile: yes
    doubleDashed: yes
    arguments: ['-bc']
  sameOptions parsed, expected

test "options are not split after any '--'", ->
  argv = ['--', '--', '-bc']
  parsed = optionParser.parse argv
  expected =
    doubleDashed: yes
    arguments: ['--', '-bc']
  sameOptions parsed, expected

  argv = ['--', 'some-file.coffee', '--', 'arg']
  parsed = optionParser.parse argv
  expected =
    doubleDashed: yes
    arguments: ['some-file.coffee', '--', 'arg']
  sameOptions parsed, expected

  argv = ['--', 'arg', 'some-file.coffee', '--', '-bc']
  parsed = optionParser.parse argv
  expected =
    doubleDashed: yes
    arguments: ['arg', 'some-file.coffee', '--', '-bc']
  sameOptions parsed, expected

test "any non-option argument stops argument parsing", ->
  argv = ['arg', '-bc']
  parsed = optionParser.parse argv
  expected = arguments: ['arg', '-bc']
  sameOptions parsed, expected

test "later '--' are not removed", ->
  argv = ['some-file.coffee', '--', '-bc']
  parsed = optionParser.parse argv
  expected = arguments: ['some-file.coffee', '--', '-bc']
  sameOptions parsed, expected

test "throw on invalid options", ->
  argv = ['-k']
  throws -> optionParser.parse argv

  argv = ['-ck']
  throws (-> optionParser.parse argv), /multi-flag/

  argv = ['-kc']
  throws (-> optionParser.parse argv), /multi-flag/

  argv = ['-oc']
  throws (-> optionParser.parse argv), /needs an argument/

  argv = ['-o']
  throws (-> optionParser.parse argv), /value required/

  argv = ['-co']
  throws (-> optionParser.parse argv), /value required/

  # Check if all flags in a multi-flag are recognized before checking if flags
  # before the last need arguments.
  argv = ['-ok']
  throws (-> optionParser.parse argv), /unrecognized option/

test "has expected help text", ->
  ok optionParser.help() is '''

Usage: coffee [options] path/to/script.coffee [args]

If called without options, \`coffee\` will run your script.

  -b, --bare         compile without a top-level function wrapper
  -c, --compile      compile to JavaScript and save as .js files
  -e, --eval         pass a string from the command line as input
  -h, --help         display this help message
  -i, --interactive  run an interactive CoffeeScript REPL
  -j, --join         concatenate the source CoffeeScript before compiling
  -m, --map          generate source map and save as .js.map files
  -M, --inline-map   generate source map and include it directly in output
  -n, --nodes        print out the parse tree that the parser produces
      --nodejs       pass options directly to the "node" binary
      --no-header    suppress the "Generated by" header
  -o, --output       set the output path or path/filename for compiled JavaScript
  -p, --print        print out the compiled JavaScript
  -r, --require      require the given module before eval or REPL
  -s, --stdio        listen for and compile scripts over stdio
  -l, --literate     treat stdio as literate style coffeescript
  -t, --transpile    pipe generated JavaScript through Babel
      --tokens       print out the tokens that the lexer/rewriter produce
  -v, --version      display the version number
  -w, --watch        watch scripts for changes and rerun commands
      --babylon      print out Babylon AST
      --prettier     compile using Prettier
  -a, --ast          print out AST

  '''
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
return unless require?
{ buildCSOptionParser } = require '../lib/coffeescript/command'

optionParser = buildCSOptionParser()

sameOptions = (opts1, opts2, msg) ->
  ownKeys = Object.keys(opts1).sort()
  otherKeys = Object.keys(opts2).sort()
  arrayEq ownKeys, otherKeys, msg
  for k in ownKeys
    arrayEq opts1[k], opts2[k], msg
  yes

test 'combined options are not split after initial file name', ->
  argv = ['some-file.coffee', '-bc']
  parsed = optionParser.parse argv
  expected = arguments: ['some-file.coffee', '-bc']
  sameOptions parsed, expected

  argv = ['some-file.litcoffee', '-bc']
  parsed = optionParser.parse argv
  expected = arguments: ['some-file.litcoffee', '-bc']
  sameOptions parsed, expected

  argv = ['-c', 'some-file.coffee', '-bc']
  parsed = optionParser.parse argv
  expected =
    compile: yes
    arguments: ['some-file.coffee', '-bc']
  sameOptions parsed, expected

  argv = ['-bc', 'some-file.coffee', '-bc']
  parsed = optionParser.parse argv
  expected =
    bare: yes
    compile: yes
    arguments: ['some-file.coffee', '-bc']
  sameOptions parsed, expected

test "combined options are not split after a '--', which is discarded", ->
  argv = ['--', '-bc']
  parsed = optionParser.parse argv
  expected =
    doubleDashed: yes
    arguments: ['-bc']
  sameOptions parsed, expected

  argv = ['-bc', '--', '-bc']
  parsed = optionParser.parse argv
  expected =
    bare: yes
    compile: yes
    doubleDashed: yes
    arguments: ['-bc']
  sameOptions parsed, expected

test "options are not split after any '--'", ->
  argv = ['--', '--', '-bc']
  parsed = optionParser.parse argv
  expected =
    doubleDashed: yes
    arguments: ['--', '-bc']
  sameOptions parsed, expected

  argv = ['--', 'some-file.coffee', '--', 'arg']
  parsed = optionParser.parse argv
  expected =
    doubleDashed: yes
    arguments: ['some-file.coffee', '--', 'arg']
  sameOptions parsed, expected

  argv = ['--', 'arg', 'some-file.coffee', '--', '-bc']
  parsed = optionParser.parse argv
  expected =
    doubleDashed: yes
    arguments: ['arg', 'some-file.coffee', '--', '-bc']
  sameOptions parsed, expected

test 'any non-option argument stops argument parsing', ->
  argv = ['arg', '-bc']
  parsed = optionParser.parse argv
  expected = arguments: ['arg', '-bc']
  sameOptions parsed, expected

test "later '--' are not removed", ->
  argv = ['some-file.coffee', '--', '-bc']
  parsed = optionParser.parse argv
  expected = arguments: ['some-file.coffee', '--', '-bc']
  sameOptions parsed, expected

test 'throw on invalid options', ->
  argv = ['-k']
  throws -> optionParser.parse argv

  argv = ['-ck']
  throws (-> optionParser.parse argv), /multi-flag/

  argv = ['-kc']
  throws (-> optionParser.parse argv), /multi-flag/

  argv = ['-oc']
  throws (-> optionParser.parse argv), /needs an argument/

  argv = ['-o']
  throws (-> optionParser.parse argv), /value required/

  argv = ['-co']
  throws (-> optionParser.parse argv), /value required/

  # Check if all flags in a multi-flag are recognized before checking if flags
  # before the last need arguments.
  argv = ['-ok']
  throws (-> optionParser.parse argv), /unrecognized option/

test 'has expected help text', ->
  ok(
    optionParser.help() is '''

Usage: coffee [options] path/to/script.coffee [args]

If called without options, \`coffee\` will run your script.

  -b, --bare         compile without a top-level function wrapper
  -c, --compile      compile to JavaScript and save as .js files
  -e, --eval         pass a string from the command line as input
  -h, --help         display this help message
  -i, --interactive  run an interactive CoffeeScript REPL
  -j, --join         concatenate the source CoffeeScript before compiling
  -m, --map          generate source map and save as .js.map files
  -M, --inline-map   generate source map and include it directly in output
  -n, --nodes        print out the parse tree that the parser produces
      --nodejs       pass options directly to the "node" binary
      --no-header    suppress the "Generated by" header
  -o, --output       set the output path or path/filename for compiled JavaScript
  -p, --print        print out the compiled JavaScript
  -r, --require      require the given module before eval or REPL
  -s, --stdio        listen for and compile scripts over stdio
  -l, --literate     treat stdio as literate style coffeescript
  -t, --transpile    pipe generated JavaScript through Babel
      --tokens       print out the tokens that the lexer/rewriter produce
  -v, --version      display the version number
  -w, --watch        watch scripts for changes and rerun commands
      --babylon      print out Babylon AST
      --prettier     compile using Prettier
  -a, --ast          print out AST

  '''
  )

`;

exports[`arrays.coffee 1`] = `
# Array Literals
# --------------

# * Array Literals
# * Splats in Array Literals

# TODO: add indexing and method invocation tests: [1][0] is 1, [].toString()

test "trailing commas", ->
  trailingComma = [1, 2, 3,]
  ok (trailingComma[0] is 1) and (trailingComma[2] is 3) and (trailingComma.length is 3)

  trailingComma = [
    1, 2, 3,
    4, 5, 6
    7, 8, 9,
  ]
  (sum = (sum or 0) + n) for n in trailingComma

  a = [((x) -> x), ((x) -> x * x)]
  ok a.length is 2

test "incorrect indentation without commas", ->
  result = [['a']
   {b: 'c'}]
  ok result[0][0] is 'a'
  ok result[1]['b'] is 'c'

# Elisions
test "array elisions", ->
  eq [,1].length, 2
  eq [,,1,2,,].length, 5
  arr = [1,,2]
  eq arr.length, 3
  eq arr[1], undefined
  eq [,,].length, 2

test "array elisions indentation and commas", ->
  arr1 = [
    , 1, 2, , , 3,
    4, 5, 6
    , , 8, 9,
  ]
  eq arr1.length, 12
  eq arr1[5], 3
  eq arr1[9], undefined
  arr2 = [, , 1,
    2, , 3,
    , 4, 5
    6
    , , ,
  ]
  eq arr2.length, 12
  eq arr2[8], 5
  eq arr2[1], undefined

test "array elisions destructuring", ->
  arr = [1,2,3,4,5,6,7,8,9]
  [,a] = arr
  [,,,b] = arr
  arrayEq [a,b], [2,4]
  [,a,,b,,c,,,d] = arr
  arrayEq [a,b,c,d], [2,4,6,9]
  [
    ,e,
    ,f,
    ,g,
    ,,h] = arr
  arrayEq [e,f,g,h], [2,4,6,9]

test "array elisions destructuring with splats and expansions", ->
  arr = [1,2,3,4,5,6,7,8,9]
  [,a,,,b...] = arr
  arrayEq [a,b], [2,[5,6,7,8,9]]
  [,c,...,,d,,e] = arr
  arrayEq [c,d,e], [2,7,9]
  [...,f,,,g,,,] = arr
  arrayEq [f,g], [4,7]

test "array elisions as function parameters", ->
  arr = [1,2,3,4,5,6,7,8,9]
  foo = ([,a]) -> a
  a = foo arr
  eq a, 2
  foo = ([,,,a]) -> a
  a = foo arr
  eq a, 4
  foo = ([,a,,b,,c,,,d]) -> [a,b,c,d]
  [a,b,c,d] = foo arr
  arrayEq [a,b,c,d], [2,4,6,9]

test "array elisions nested destructuring", ->
  arr = [
    1,
    [2,3, [4,5,6, [7,8,9] ] ]
  ]
  [,a] = arr
  arrayEq a[2][3], [7,8,9]
  [,[,,[,b,,[,,c]]]] = arr
  eq b, 5
  eq c, 9
  aobj = [
    {},
    {x: 2},
    {},
    [
      {},
      {},
      {z:1, w:[1,2,4], p:3, q:4}
      {},
      {}
    ]
  ]
  [,d,,[,,{w}]] = aobj
  deepEqual d, {x:2}
  arrayEq w, [1,2,4]

# Splats in Array Literals

test "array splat expansions with assignments", ->
  nums = [1, 2, 3]
  list = [a = 0, nums..., b = 4]
  eq 0, a
  eq 4, b
  arrayEq [0,1,2,3,4], list


test "mixed shorthand objects in array lists", ->
  arr = [
    a:1
    'b'
    c:1
  ]
  ok arr.length is 3
  ok arr[2].c is 1

  arr = [b: 1, a: 2, 100]
  eq arr[1], 100

  arr = [a:0, b:1, (1 + 1)]
  eq arr[1], 2

  arr = [a:1, 'a', b:1, 'b']
  eq arr.length, 4
  eq arr[2].b, 1
  eq arr[3], 'b'

test "array splats with nested arrays", ->
  nonce = {}
  a = [nonce]
  list = [1, 2, a...]
  eq list[0], 1
  eq list[2], nonce

  a = [[nonce]]
  list = [1, 2, a...]
  arrayEq list, [1, 2, [nonce]]

test "#4260: splat after existential operator soak", ->
  a = {b: [3]}
  foo = (a) -> [a]
  arrayEq [a?.b...], [3]
  arrayEq [c?.b ? []...], []
  arrayEq [...a?.b], [3]
  arrayEq [...c?.b ? []], []
  arrayEq foo(a?.b...), [3]
  arrayEq foo(...a?.b), [3]
  arrayEq foo(c?.b ? []...), [undefined]
  arrayEq foo(...c?.b ? []), [undefined]
  e = yes
  f = null
  arrayEq [(a if e)?.b...], [3]
  arrayEq [(a if f)?.b ? []...], []
  arrayEq [...(a if e)?.b], [3]
  arrayEq [...(a if f)?.b ? []], []
  arrayEq foo((a if e)?.b...), [3]
  arrayEq foo(...(a if e)?.b), [3]
  arrayEq foo((a if f)?.b ? []...), [undefined]
  arrayEq foo(...(a if f)?.b ? []), [undefined]

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  arrayEq [... a?.b], [3]
  arrayEq [... c?.b ? []], []
  arrayEq [a?.b ...], [3]
  arrayEq [(a if e)?.b ...], [3]
  arrayEq foo(a?.b ...), [3]
  arrayEq foo(... a?.b), [3]

test "#1349: trailing if after splat", ->
  a = [3]
  b = yes
  c = null
  foo = (a) -> [a]
  arrayEq [a if b...], [3]
  arrayEq [(a if c) ? []...], []
  arrayEq [...a if b], [3]
  arrayEq [...(a if c) ? []], []
  arrayEq foo((a if b)...), [3]
  arrayEq foo(...(a if b)), [3]
  arrayEq foo((a if c) ? []...), [undefined]
  arrayEq foo(...(a if c) ? []), [undefined]

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  arrayEq [... a if b], [3]
  arrayEq [a if b ...], [3]

test "#1274: \`[] = a()\` compiles to \`false\` instead of \`a()\`", ->
  a = false
  fn = -> a = true
  [] = fn()
  ok a

test "#3194: string interpolation in array", ->
  arr = [ "a"
          key: 'value'
        ]
  eq 2, arr.length
  eq 'a', arr[0]
  eq 'value', arr[1].key

  b = 'b'
  arr = [ "a#{b}"
          key: 'value'
        ]
  eq 2, arr.length
  eq 'ab', arr[0]
  eq 'value', arr[1].key

test "regex interpolation in array", ->
  arr = [ /a/
          key: 'value'
        ]
  eq 2, arr.length
  eq 'a', arr[0].source
  eq 'value', arr[1].key

  b = 'b'
  arr = [ ///a#{b}///
          key: 'value'
        ]
  eq 2, arr.length
  eq 'ab', arr[0].source
  eq 'value', arr[1].key

test "splat extraction from generators", ->
  gen = ->
    yield 1
    yield 2
    yield 3
  arrayEq [ gen()... ], [ 1, 2, 3 ]

test "for-from loops over Array", ->
  array1 = [50, 30, 70, 20]
  array2 = []
  for x from array1
    array2.push(x)
  arrayEq array1, array2

  array1 = [[20, 30], [40, 50]]
  array2 = []
  for [a, b] from array1
    array2.push(b)
    array2.push(a)
  arrayEq array2, [30, 20, 50, 40]

  array1 = [{a: 10, b: 20, c: 30}, {a: 40, b: 50, c: 60}]
  array2 = []
  for {a: a, b, c: d} from array1
    array2.push([a, b, d])
  arrayEq array2, [[10, 20, 30], [40, 50, 60]]

  array1 = [[10, 20, 30, 40, 50]]
  for [a, b..., c] from array1
    eq 10, a
    arrayEq [20, 30, 40], b
    eq 50, c

test "for-from comprehensions over Array", ->
  array1 = (x + 10 for x from [10, 20, 30])
  ok array1.join(' ') is '20 30 40'

  array2 = (x for x from [30, 41, 57] when x %% 3 is 0)
  ok array2.join(' ') is '30 57'

  array1 = (b + 5 for [a, b] from [[20, 30], [40, 50]])
  ok array1.join(' ') is '35 55'

  array2 = (a + b for [a, b] from [[10, 20], [30, 40], [50, 60]] when a + b >= 70)
  ok array2.join(' ') is '70 110'
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Array Literals
# --------------

# * Array Literals
# * Splats in Array Literals

# TODO: add indexing and method invocation tests: [1][0] is 1, [].toString()

test 'trailing commas', ->
  trailingComma = [1, 2, 3]
  ok(
    trailingComma[0] is 1 and
      trailingComma[2] is 3 and
      trailingComma.length is 3
  )

  trailingComma = [1, 2, 3, 4, 5, 6, 7, 8, 9]
  (sum = (sum or 0) + n) for n in trailingComma

  a = [
    (x) -> x
    (x) -> x * x
  ]
  ok a.length is 2

test 'incorrect indentation without commas', ->
  result = [['a'], { b: 'c' }]
  ok result[0][0] is 'a'
  ok result[1]['b'] is 'c'

# Elisions
test 'array elisions', ->
  eq [, 1].length, 2
  eq [, , 1, 2, ,].length, 5
  arr = [1, , 2]
  eq arr.length, 3
  eq arr[1], undefined
  eq [, ,].length, 2

test 'array elisions indentation and commas', ->
  arr1 = [, 1, 2, , , 3, 4, 5, 6, , 8, 9]
  eq arr1.length, 12
  eq arr1[5], 3
  eq arr1[9], undefined
  arr2 = [, , 1, 2, , 3, , 4, 5, 6, , ,]
  eq arr2.length, 12
  eq arr2[8], 5
  eq arr2[1], undefined

test 'array elisions destructuring', ->
  arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
  [, a] = arr
  [, , , b] = arr
  arrayEq [a, b], [2, 4]
  [, a, , b, , c, , , d] = arr
  arrayEq [a, b, c, d], [2, 4, 6, 9]
  [, e, , f, , g, , , h] = arr
  arrayEq [e, f, g, h], [2, 4, 6, 9]

test 'array elisions destructuring with splats and expansions', ->
  arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
  [, a, , , b...] = arr
  arrayEq [a, b], [2, [5, 6, 7, 8, 9]]
  [, c, ..., , d, , e] = arr
  arrayEq [c, d, e], [2, 7, 9]
  [..., f, , , g, , ,] = arr
  arrayEq [f, g], [4, 7]

test 'array elisions as function parameters', ->
  arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
  foo = ([, a]) -> a
  a = foo arr
  eq a, 2
  foo = ([, , , a]) -> a
  a = foo arr
  eq a, 4
  foo = ([, a, , b, , c, , , d]) -> [a, b, c, d]
  [a, b, c, d] = foo arr
  arrayEq [a, b, c, d], [2, 4, 6, 9]

test 'array elisions nested destructuring', ->
  arr = [1, [2, 3, [4, 5, 6, [7, 8, 9]]]]
  [, a] = arr
  arrayEq a[2][3], [7, 8, 9]
  [, [, , [, b, , [, , c]]]] = arr
  eq b, 5
  eq c, 9
  aobj = [
    {}
  ,
    x: 2
  ,
    {}
    [{}, {}, { z: 1, w: [1, 2, 4], p: 3, q: 4 }, {}, {}]
  ]
  [, d, , [, , { w }]] = aobj
  deepEqual d, { x: 2 }
  arrayEq w, [1, 2, 4]

# Splats in Array Literals

test 'array splat expansions with assignments', ->
  nums = [1, 2, 3]
  list = [(a = 0), nums..., (b = 4)]
  eq 0, a
  eq 4, b
  arrayEq [0, 1, 2, 3, 4], list

test 'mixed shorthand objects in array lists', ->
  arr = [{ a: 1 }, 'b', { c: 1 }]
  ok arr.length is 3
  ok arr[2].c is 1

  arr = [{ b: 1, a: 2 }, 100]
  eq arr[1], 100

  arr = [{ a: 0, b: 1 }, 1 + 1]
  eq arr[1], 2

  arr = [{ a: 1 }, 'a', { b: 1 }, 'b']
  eq arr.length, 4
  eq arr[2].b, 1
  eq arr[3], 'b'

test 'array splats with nested arrays', ->
  nonce = {}
  a = [nonce]
  list = [1, 2, a...]
  eq list[0], 1
  eq list[2], nonce

  a = [[nonce]]
  list = [1, 2, a...]
  arrayEq list, [1, 2, [nonce]]

test '#4260: splat after existential operator soak', ->
  a = b: [3]
  foo = (a) -> [a]
  arrayEq [a?.b...], [3]
  arrayEq [(c?.b ? [])...], []
  arrayEq [...a?.b], [3]
  arrayEq [...(c?.b ? [])], []
  arrayEq foo(a?.b...), [3]
  arrayEq foo(...a?.b), [3]
  arrayEq foo((c?.b ? [])...), [undefined]
  arrayEq foo(...(c?.b ? [])), [undefined]
  e = yes
  f = null
  arrayEq [(a if e)?.b...], [3]
  arrayEq [((a if f)?.b ? [])...], []
  arrayEq [...(a if e)?.b], [3]
  arrayEq [...((a if f)?.b ? [])], []
  arrayEq foo((a if e)?.b...), [3]
  arrayEq foo(...(a if e)?.b), [3]
  arrayEq foo(((a if f)?.b ? [])...), [undefined]
  arrayEq foo(...((a if f)?.b ? [])), [undefined]

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  arrayEq [...a?.b], [3]
  arrayEq [...(c?.b ? [])], []
  arrayEq [a?.b...], [3]
  arrayEq [(a if e)?.b...], [3]
  arrayEq foo(a?.b...), [3]
  arrayEq foo(...a?.b), [3]

test '#1349: trailing if after splat', ->
  a = [3]
  b = yes
  c = null
  foo = (a) -> [a]
  arrayEq [(a if b)...], [3]
  arrayEq [((a if c) ? [])...], []
  arrayEq [...(a if b)], [3]
  arrayEq [...((a if c) ? [])], []
  arrayEq foo((a if b)...), [3]
  arrayEq foo(...(a if b)), [3]
  arrayEq foo(((a if c) ? [])...), [undefined]
  arrayEq foo(...((a if c) ? [])), [undefined]

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  arrayEq [...(a if b)], [3]
  arrayEq [(a if b)...], [3]

test '#1274: \`[] = a()\` compiles to \`false\` instead of \`a()\`', ->
  a = false
  fn = -> a = true
  [] = fn()
  ok a

test '#3194: string interpolation in array', ->
  arr = ['a', { key: 'value' }]
  eq 2, arr.length
  eq 'a', arr[0]
  eq 'value', arr[1].key

  b = 'b'
  arr = ["a#{b}", { key: 'value' }]
  eq 2, arr.length
  eq 'ab', arr[0]
  eq 'value', arr[1].key

test 'regex interpolation in array', ->
  arr = [/a/, { key: 'value' }]
  eq 2, arr.length
  eq 'a', arr[0].source
  eq 'value', arr[1].key

  b = 'b'
  arr = [///a#{b}///, { key: 'value' }]
  eq 2, arr.length
  eq 'ab', arr[0].source
  eq 'value', arr[1].key

test 'splat extraction from generators', ->
  gen = ->
    yield 1
    yield 2
    yield 3
  arrayEq [gen()...], [1, 2, 3]

test 'for-from loops over Array', ->
  array1 = [50, 30, 70, 20]
  array2 = []
  for x from array1
    array2.push x
  arrayEq array1, array2

  array1 = [[20, 30], [40, 50]]
  array2 = []
  for [a, b] from array1
    array2.push b
    array2.push a
  arrayEq array2, [30, 20, 50, 40]

  array1 = [{ a: 10, b: 20, c: 30 }, { a: 40, b: 50, c: 60 }]
  array2 = []
  for { a: a, b, c: d } from array1
    array2.push [a, b, d]
  arrayEq array2, [[10, 20, 30], [40, 50, 60]]

  array1 = [[10, 20, 30, 40, 50]]
  for [a, b..., c] from array1
    eq 10, a
    arrayEq [20, 30, 40], b
    eq 50, c

test 'for-from comprehensions over Array', ->
  array1 = (x + 10 for x from [10, 20, 30])
  ok array1.join(' ') is '20 30 40'

  array2 = (x for x from [30, 41, 57] when x %% 3 is 0)
  ok array2.join(' ') is '30 57'

  array1 = (b + 5 for [a, b] from [[20, 30], [40, 50]])
  ok array1.join(' ') is '35 55'

  array2 =
    a + b for [a, b] from [[10, 20], [30, 40], [50, 60]] when a + b >= 70
  ok array2.join(' ') is '70 110'

`;

exports[`assignment.coffee 1`] = `
# Assignment
# ----------

# * Assignment
# * Compound Assignment
# * Destructuring Assignment
# * Context Property (@) Assignment
# * Existential Assignment (?=)
# * Assignment to variables similar to generated variables

test "context property assignment (using @)", ->
  nonce = {}
  addMethod = ->
    @method = -> nonce
    this
  eq nonce, addMethod.call({}).method()

test "unassignable values", ->
  nonce = {}
  for nonref in ['', '""', '0', 'f()'].concat CoffeeScript.RESERVED
    eq nonce, (try CoffeeScript.compile "#{nonref} = v" catch e then nonce)

# Compound Assignment

test "boolean operators", ->
  nonce = {}

  a  = 0
  a or= nonce
  eq nonce, a

  b  = 1
  b or= nonce
  eq 1, b

  c = 0
  c and= nonce
  eq 0, c

  d = 1
  d and= nonce
  eq nonce, d

  # ensure that RHS is treated as a group
  e = f = false
  e and= f or true
  eq false, e

test "compound assignment as a sub expression", ->
  [a, b, c] = [1, 2, 3]
  eq 6, (a + b += c)
  eq 1, a
  eq 5, b
  eq 3, c

# *note: this test could still use refactoring*
test "compound assignment should be careful about caching variables", ->
  count = 0
  list = []

  list[++count] or= 1
  eq 1, list[1]
  eq 1, count

  list[++count] ?= 2
  eq 2, list[2]
  eq 2, count

  list[count++] and= 6
  eq 6, list[2]
  eq 3, count

  base = ->
    ++count
    base

  base().four or= 4
  eq 4, base.four
  eq 4, count

  base().five ?= 5
  eq 5, base.five
  eq 5, count

  eq 5, base().five ?= 6
  eq 6, count

test "compound assignment with implicit objects", ->
  obj = undefined
  obj ?=
    one: 1

  eq 1, obj.one

  obj and=
    two: 2

  eq undefined, obj.one
  eq         2, obj.two

test "compound assignment (math operators)", ->
  num = 10
  num -= 5
  eq 5, num

  num *= 10
  eq 50, num

  num /= 10
  eq 5, num

  num %= 3
  eq 2, num

test "more compound assignment", ->
  a = {}
  val = undefined
  val ||= a
  val ||= true
  eq a, val

  b = {}
  val &&= true
  eq val, true
  val &&= b
  eq b, val

  c = {}
  val = null
  val ?= c
  val ?= true
  eq c, val

test "#1192: assignment starting with object literals", ->
  doesNotThrow (-> CoffeeScript.run "{}.p = 0")
  doesNotThrow (-> CoffeeScript.run "{}.p++")
  doesNotThrow (-> CoffeeScript.run "{}[0] = 1")
  doesNotThrow (-> CoffeeScript.run """{a: 1, 'b', "#{1}": 2}.p = 0""")
  doesNotThrow (-> CoffeeScript.run "{a:{0:{}}}.a[0] = 0")

{}.p = 0
{}.p++
{}[0] = 1
{a: 1, 'b', "#{1}": 2}.p = 0
{a:{0:{}}}.a[0] = 0


# Destructuring Assignment

test "empty destructuring assignment", ->
  {} = {}
  [] = []

test "chained destructuring assignments", ->
  [a] = {0: b} = {'0': c} = [nonce={}]
  eq nonce, a
  eq nonce, b
  eq nonce, c

test "variable swapping to verify caching of RHS values when appropriate", ->
  a = nonceA = {}
  b = nonceB = {}
  c = nonceC = {}
  [a, b, c] = [b, c, a]
  eq nonceB, a
  eq nonceC, b
  eq nonceA, c
  [a, b, c] = [b, c, a]
  eq nonceC, a
  eq nonceA, b
  eq nonceB, c
  fn = ->
    [a, b, c] = [b, c, a]
  arrayEq [nonceA,nonceB,nonceC], fn()
  eq nonceA, a
  eq nonceB, b
  eq nonceC, c

test "#713: destructuring assignment should return right-hand-side value", ->
  nonces = [nonceA={},nonceB={}]
  eq nonces, [a, b] = [c, d] = nonces
  eq nonceA, a
  eq nonceA, c
  eq nonceB, b
  eq nonceB, d

test "#4787 destructuring of objects within arrays", ->
  arr = [1, {a:1, b:2}]
  [...,{a, b}] = arr
  eq a, 1
  eq b, arr[1].b
  deepEqual {a, b}, arr[1]

test "destructuring assignment with splats", ->
  a = {}; b = {}; c = {}; d = {}; e = {}
  [x,y...,z] = [a,b,c,d,e]
  eq a, x
  arrayEq [b,c,d], y
  eq e, z

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  [x,y ...,z] = [a,b,c,d,e]
  eq a, x
  arrayEq [b,c,d], y
  eq e, z

test "deep destructuring assignment with splats", ->
  a={}; b={}; c={}; d={}; e={}; f={}; g={}; h={}; i={}
  [u, [v, w..., x], y..., z] = [a, [b, c, d, e], f, g, h, i]
  eq a, u
  eq b, v
  arrayEq [c,d], w
  eq e, x
  arrayEq [f,g,h], y
  eq i, z

test "destructuring assignment with objects", ->
  a={}; b={}; c={}
  obj = {a,b,c}
  {a:x, b:y, c:z} = obj
  eq a, x
  eq b, y
  eq c, z

test "deep destructuring assignment with objects", ->
  a={}; b={}; c={}; d={}
  obj = {
    a
    b: {
      'c': {
        d: [
          b
          {e: c, f: d}
        ]
      }
    }
  }
  {a: w, 'b': {c: d: [x, {'f': z, e: y}]}} = obj
  eq a, w
  eq b, x
  eq c, y
  eq d, z

test "destructuring assignment with objects and splats", ->
  a={}; b={}; c={}; d={}
  obj = a: b: [a, b, c, d]
  {a: b: [y, z...]} = obj
  eq a, y
  arrayEq [b,c,d], z

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  {a: b: [y, z ...]} = obj
  eq a, y
  arrayEq [b,c,d], z

test "destructuring assignment against an expression", ->
  a={}; b={}
  [y, z] = if true then [a, b] else [b, a]
  eq a, y
  eq b, z

test "bracket insertion when necessary", ->
  [a] = [0] ? [1]
  eq a, 0

# for implicit destructuring assignment in comprehensions, see the comprehension tests

test "destructuring assignment with context (@) properties", ->
  a={}; b={}; c={}; d={}; e={}
  obj =
    fn: () ->
      local = [a, {b, c}, d, e]
      [@a, {b: @b, c: @c}, @d, @e] = local
  eq undefined, obj[key] for key in ['a','b','c','d','e']
  obj.fn()
  eq a, obj.a
  eq b, obj.b
  eq c, obj.c
  eq d, obj.d
  eq e, obj.e

test "#1024: destructure empty assignments to produce javascript-like results", ->
  eq 2 * [] = 3 + 5, 16

test "#1005: invalid identifiers allowed on LHS of destructuring assignment", ->
  disallowed = ['eval', 'arguments'].concat CoffeeScript.RESERVED
  throws (-> CoffeeScript.compile "[#{disallowed.join ', '}] = x"), null, 'all disallowed'
  throws (-> CoffeeScript.compile "[#{disallowed.join '..., '}...] = x"), null, 'all disallowed as splats'
  t = tSplat = null
  for v in disallowed when v isnt 'class' # \`class\` by itself is an expression
    throws (-> CoffeeScript.compile t), null, t = "[#{v}] = x"
    throws (-> CoffeeScript.compile tSplat), null, tSplat = "[#{v}...] = x"
  doesNotThrow ->
    for v in disallowed
      CoffeeScript.compile "[a.#{v}] = x"
      CoffeeScript.compile "[a.#{v}...] = x"
      CoffeeScript.compile "[@#{v}] = x"
      CoffeeScript.compile "[@#{v}...] = x"

test "#2055: destructuring assignment with \`new\`", ->
  {length} = new Array
  eq 0, length

test "#156: destructuring with expansion", ->
  array = [1..5]
  [first, ..., last] = array
  eq 1, first
  eq 5, last
  [..., lastButOne, last] = array
  eq 4, lastButOne
  eq 5, last
  [first, second, ..., last] = array
  eq 2, second
  [..., last] = 'strings as well -> x'
  eq 'x', last
  throws (-> CoffeeScript.compile "[1, ..., 3]"),        null, "prohibit expansion outside of assignment"
  throws (-> CoffeeScript.compile "[..., a, b...] = c"), null, "prohibit expansion and a splat"
  throws (-> CoffeeScript.compile "[...] = c"),          null, "prohibit lone expansion"

test "destructuring with dynamic keys", ->
  {"#{'a'}": a, """#{'b'}""": b, c} = {a: 1, b: 2, c: 3}
  eq 1, a
  eq 2, b
  eq 3, c
  throws -> CoffeeScript.compile '{"#{a}"} = b'

test "simple array destructuring defaults", ->
  [a = 1] = []
  eq 1, a
  [a = 2] = [undefined]
  eq 2, a
  [a = 3] = [null]
  eq null, a # Breaking change in CS2: per ES2015, default values are applied for \`undefined\` but not for \`null\`.
  [a = 4] = [0]
  eq 0, a
  arr = [a = 5]
  eq 5, a
  arrayEq [5], arr

test "simple object destructuring defaults", ->
  {b = 1} = {}
  eq b, 1
  {b = 2} = {b: undefined}
  eq b, 2
  {b = 3} = {b: null}
  eq b, null # Breaking change in CS2: per ES2015, default values are applied for \`undefined\` but not for \`null\`.
  {b = 4} = {b: 0}
  eq b, 0

  {b: c = 1} = {}
  eq c, 1
  {b: c = 2} = {b: undefined}
  eq c, 2
  {b: c = 3} = {b: null}
  eq c, null # Breaking change in CS2: per ES2015, default values are applied for \`undefined\` but not for \`null\`.
  {b: c = 4} = {b: 0}
  eq c, 0

test "multiple array destructuring defaults", ->
  [a = 1, b = 2, c] = [undefined, 12, 13]
  eq a, 1
  eq b, 12
  eq c, 13
  [a, b = 2, c = 3] = [undefined, 12, 13]
  eq a, undefined
  eq b, 12
  eq c, 13
  [a = 1, b, c = 3] = [11, 12]
  eq a, 11
  eq b, 12
  eq c, 3

test "multiple object destructuring defaults", ->
  {a = 1, b: bb = 2, 'c': c = 3, "#{0}": d = 4} = {"#{'b'}": 12}
  eq a, 1
  eq bb, 12
  eq c, 3
  eq d, 4

test "array destructuring defaults with splats", ->
  [..., a = 9] = []
  eq a, 9
  [..., b = 9] = [19]
  eq b, 19

test "deep destructuring assignment with defaults", ->
  [a, [{b = 1, c = 3}] = [c: 2]] = [0]
  eq a, 0
  eq b, 1
  eq c, 2

test "destructuring assignment with context (@) properties and defaults", ->
  a={}; b={}; c={}; d={}; e={}
  obj =
    fn: () ->
      local = [a, {b, c: undefined}, d]
      [@a, {b: @b = b, @c = c}, @d, @e = e] = local
  eq undefined, obj[key] for key in ['a','b','c','d','e']
  obj.fn()
  eq a, obj.a
  eq b, obj.b
  eq c, obj.c
  eq d, obj.d
  eq e, obj.e

test "destructuring assignment with defaults single evaluation", ->
  callCount = 0
  fn = -> callCount++
  [a = fn()] = []
  eq 0, a
  eq 1, callCount
  [a = fn()] = [10]
  eq 10, a
  eq 1, callCount
  {a = fn(), b: c = fn()} = {a: 20, b: undefined}
  eq 20, a
  eq c, 1
  eq callCount, 2


# Existential Assignment

test "existential assignment", ->
  nonce = {}
  a = false
  a ?= nonce
  eq false, a
  b = undefined
  b ?= nonce
  eq nonce, b
  c = null
  c ?= nonce
  eq nonce, c

test "#1627: prohibit conditional assignment of undefined variables", ->
  throws (-> CoffeeScript.compile "x ?= 10"),        null, "prohibit (x ?= 10)"
  throws (-> CoffeeScript.compile "x ||= 10"),       null, "prohibit (x ||= 10)"
  throws (-> CoffeeScript.compile "x or= 10"),       null, "prohibit (x or= 10)"
  throws (-> CoffeeScript.compile "do -> x ?= 10"),  null, "prohibit (do -> x ?= 10)"
  throws (-> CoffeeScript.compile "do -> x ||= 10"), null, "prohibit (do -> x ||= 10)"
  throws (-> CoffeeScript.compile "do -> x or= 10"), null, "prohibit (do -> x or= 10)"
  doesNotThrow (-> CoffeeScript.compile "x = null; x ?= 10"),        "allow (x = null; x ?= 10)"
  doesNotThrow (-> CoffeeScript.compile "x = null; x ||= 10"),       "allow (x = null; x ||= 10)"
  doesNotThrow (-> CoffeeScript.compile "x = null; x or= 10"),       "allow (x = null; x or= 10)"
  doesNotThrow (-> CoffeeScript.compile "x = null; do -> x ?= 10"),  "allow (x = null; do -> x ?= 10)"
  doesNotThrow (-> CoffeeScript.compile "x = null; do -> x ||= 10"), "allow (x = null; do -> x ||= 10)"
  doesNotThrow (-> CoffeeScript.compile "x = null; do -> x or= 10"), "allow (x = null; do -> x or= 10)"

  throws (-> CoffeeScript.compile "-> -> -> x ?= 10"), null, "prohibit (-> -> -> x ?= 10)"
  doesNotThrow (-> CoffeeScript.compile "x = null; -> -> -> x ?= 10"), "allow (x = null; -> -> -> x ?= 10)"

x = null; x ?= 10
x = null; x ||= 10
x = null; x or= 10
x = null; do -> x ?= 10
x = null; do -> x ||= 10
x = null; do -> x or= 10
x = null; -> -> -> x ?= 10

test "more existential assignment", ->
  global.temp ?= 0
  eq global.temp, 0
  global.temp or= 100
  eq global.temp, 100
  delete global.temp

test "#1348, #1216: existential assignment compilation", ->
  nonce = {}
  a = nonce
  b = (a ?= 0)
  eq nonce, b
  #the first ?= compiles into a statement; the second ?= compiles to a ternary expression
  eq a ?= b ?= 1, nonce

  if a then a ?= 2 else a = 3
  eq a, nonce

test "#1591, #1101: splatted expressions in destructuring assignment must be assignable", ->
  nonce = {}
  for nonref in ['', '""', '0', 'f()', '(->)'].concat CoffeeScript.RESERVED
    eq nonce, (try CoffeeScript.compile "[#{nonref}...] = v" catch e then nonce)

test "#1643: splatted accesses in destructuring assignments should not be declared as variables", ->
  nonce = {}
  accesses = ['o.a', 'o["a"]', '(o.a)', '(o.a).a', '@o.a', 'C::a', 'f().a', 'o?.a', 'o?.a.b', 'f?().a']
  for access in accesses
    for i,j in [1,2,3] #position can matter
      code =
        """
        nonce = {}; nonce2 = {}; nonce3 = {};
        @o = o = new (class C then a:{}); f = -> o
        [#{new Array(i).join('x,')}#{access}...] = [#{new Array(i).join('0,')}nonce, nonce2, nonce3]
        unless #{access}[0] is nonce and #{access}[1] is nonce2 and #{access}[2] is nonce3 then throw new Error('[...]')
        """
      eq nonce, unless (try CoffeeScript.run code, bare: true catch e then true) then nonce
  # subpatterns like \`[[a]...]\` and \`[{a}...]\`
  subpatterns = ['[sub, sub2, sub3]', '{0: sub, 1: sub2, 2: sub3}']
  for subpattern in subpatterns
    for i,j in [1,2,3]
      code =
        """
        nonce = {}; nonce2 = {}; nonce3 = {};
        [#{new Array(i).join('x,')}#{subpattern}...] = [#{new Array(i).join('0,')}nonce, nonce2, nonce3]
        unless sub is nonce and sub2 is nonce2 and sub3 is nonce3 then throw new Error('[sub...]')
        """
      eq nonce, unless (try CoffeeScript.run code, bare: true catch e then true) then nonce

test "#1838: Regression with variable assignment", ->
  name =
  'dave'

  eq name, 'dave'

test '#2211: splats in destructured parameters', ->
  doesNotThrow -> CoffeeScript.compile '([a...]) ->'
  doesNotThrow -> CoffeeScript.compile '([a...],b) ->'
  doesNotThrow -> CoffeeScript.compile '([a...],[b...]) ->'
  throws -> CoffeeScript.compile '([a...,[a...]]) ->'
  doesNotThrow -> CoffeeScript.compile '([a...,[b...]]) ->'

([a...]) ->
([a...],b) ->
([a...],[b...]) ->
([a...,[b...]]) ->

test '#2213: invocations within destructured parameters', ->
  throws -> CoffeeScript.compile '([a()])->'
  throws -> CoffeeScript.compile '([a:b()])->'
  throws -> CoffeeScript.compile '([a:b.c()])->'
  throws -> CoffeeScript.compile '({a()})->'
  throws -> CoffeeScript.compile '({a:b()})->'
  throws -> CoffeeScript.compile '({a:b.c()})->'

test '#2532: compound assignment with terminator', ->
  doesNotThrow -> CoffeeScript.compile """
  a = "hello"
  a +=
  "
  world
  !
  "
  """

a = "hello"
a +=
"
world
!
"

test "#2613: parens on LHS of destructuring", ->
  a = {}
  [(a).b] = [1, 2, 3]
  eq a.b, 1

test "#2181: conditional assignment as a subexpression", ->
  a = false
  false && a or= true
  eq false, a
  eq false, not a or= true

test "#1500: Assignment to variables similar to generated variables", ->
  len = 0
  x = ((results = null; n) for n in [1, 2, 3])
  arrayEq [1, 2, 3], x
  eq 0, len

  for x in [1, 2, 3]
    f = ->
      i = 0
    f()
    eq 'undefined', typeof i

  ref = 2
  x = ref * 2 ? 1
  eq x, 4
  eq 'undefined', typeof ref1

  x = {}
  base = -> x
  name = -1
  base()[-name] ?= 2
  eq x[1], 2
  eq base(), x
  eq name, -1

  f = (@a, a) -> [@a, a]
  arrayEq [1, 2], f.call scope = {}, 1, 2
  eq 1, scope.a

  try throw 'foo'
  catch error
    eq error, 'foo'

  eq error, 'foo'

  doesNotThrow -> CoffeeScript.compile '(@slice...) ->'

test "Assignment to variables similar to helper functions", ->
  f = (slice...) -> slice
  arrayEq [1, 2, 3], f 1, 2, 3
  eq 'undefined', typeof slice1

  class A
  class B extends A
    extend = 3
    hasProp = 4
    value: 5
    method: (bind, bind1) => [bind, bind1, extend, hasProp, @value]
  {method} = new B
  arrayEq [1, 2, 3, 4, 5], method 1, 2

  modulo = -1 %% 3
  eq 2, modulo

  indexOf = [1, 2, 3]
  ok 2 in indexOf

test "#4566: destructuring with nested default values", ->
  {a: {b = 1}} = a: {}
  eq 1, b

  {c: {d} = {}} = c: d: 3
  eq 3, d

  {e: {f = 5} = {}} = {}
  eq 5, f

test "#4878: Compile error when using destructuring with a splat or expansion in an array", ->
  arr = ['a', 'b', 'c', 'd']

  f1 = (list) ->
    [first, ..., last] = list

  f2 = (list) ->
    [first..., last] = list

  f3 = (list) ->
    ([first, ...] = list); first

  f4 = (list) ->
    ([first, rest...] = list); rest

  arrayEq f1(arr), arr
  arrayEq f2(arr), arr
  arrayEq f3(arr), 'a'
  arrayEq f4(arr), ['b', 'c', 'd']

  foo = (list) ->
    ret =
      if list?.length > 0
        [first, ..., last] = list
        [first, last]
      else
        []

  arrayEq foo(arr), ['a', 'd']

  bar = (list) ->
    ret =
      if list?.length > 0
        [first, rest...] = list
        [first, rest]
      else
        []

  arrayEq bar(arr), ['a', ['b', 'c', 'd']]

test "destructuring assignment with an empty array in object", ->
  obj =
    a1: [1, 2]
    b1: 3

  {a1:[], b1} = obj
  eq 'undefined', typeof a1
  eq b1, 3

  obj =
    a2:
      b2: [1, 2]
    c2: 3

  {a2: {b2:[]}, c2} = obj
  eq 'undefined', typeof b2
  eq c2, 3

test "#5004: array destructuring with accessors", ->
  obj =
    arr: ['a', 'b', 'c', 'd']
    list: {}
    f1: ->
      [@first, @rest...] = @arr
    f2: ->
      [@second, @third..., @last] = @rest
    f3: ->
      [@list.a, @list.middle..., @list.d] = @arr

  obj.f1()
  eq obj.first, 'a'
  arrayEq obj.rest, ['b', 'c', 'd']

  obj.f2()
  eq obj.second, 'b'
  arrayEq obj.third, ['c']
  eq obj.last, 'd'

  obj.f3()
  eq obj.list.a, 'a'
  arrayEq obj.list.middle, ['b', 'c']
  eq obj.list.d, 'd'

  [obj.list.middle..., d] = obj.arr
  eq d, 'd'
  arrayEq obj.list.middle, ['a', 'b', 'c']

test "#4884: destructured object splat", ->
  [{length}...] = [1, 2, 3]
  eq length, 3
  [{length: len}...] = [1, 2, 3]
  eq len, 3
  [{length}..., three] = [1, 2, 3]
  eq length, 2
  eq three, 3
  [{length: len}..., three] = [1, 2, 3]
  eq len, 2
  eq three, 3
  x = [{length}..., three] = [1, 2, 3]
  eq length, 2
  eq three, 3
  eq x[2], 3
  x = [{length: len}..., three] = [1, 2, 3]
  eq len, 2
  eq three, 3
  eq x[2], 3

test "#4884: destructured array splat", ->
  [[one, two, three]...] = [1, 2, 3]
  eq one, 1
  eq two, 2
  eq three, 3
  [[one, two]..., three] = [1, 2, 3]
  eq one, 1
  eq two, 2
  eq three, 3
  x = [[one, two]..., three] = [1, 2, 3]
  eq one, 1
  eq two, 2
  eq three, 3
  eq x[2], 3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Assignment
# ----------

# * Assignment
# * Compound Assignment
# * Destructuring Assignment
# * Context Property (@) Assignment
# * Existential Assignment (?=)
# * Assignment to variables similar to generated variables

test 'context property assignment (using @)', ->
  nonce = {}
  addMethod = ->
    @method = -> nonce
    this
  eq nonce, addMethod.call({}).method()

test 'unassignable values', ->
  nonce = {}
  for nonref in ['', '""', '0', 'f()'].concat CoffeeScript.RESERVED
    eq nonce, try CoffeeScript.compile "#{nonref} = v" catch e then nonce

# Compound Assignment

test 'boolean operators', ->
  nonce = {}

  a = 0
  a or= nonce
  eq nonce, a

  b = 1
  b or= nonce
  eq 1, b

  c = 0
  c and= nonce
  eq 0, c

  d = 1
  d and= nonce
  eq nonce, d

  # ensure that RHS is treated as a group
  e = f = false
  e and= f or true
  eq false, e

test 'compound assignment as a sub expression', ->
  [a, b, c] = [1, 2, 3]
  eq 6, a + (b += c)
  eq 1, a
  eq 5, b
  eq 3, c

# *note: this test could still use refactoring*
test 'compound assignment should be careful about caching variables', ->
  count = 0
  list = []

  list[++count] or= 1
  eq 1, list[1]
  eq 1, count

  list[++count] ?= 2
  eq 2, list[2]
  eq 2, count

  list[count++] and= 6
  eq 6, list[2]
  eq 3, count

  base = ->
    ++count
    base

  base().four or= 4
  eq 4, base.four
  eq 4, count

  base().five ?= 5
  eq 5, base.five
  eq 5, count

  eq 5, base().five ?= 6
  eq 6, count

test 'compound assignment with implicit objects', ->
  obj = undefined
  obj ?= one: 1

  eq 1, obj.one

  obj and= two: 2

  eq undefined, obj.one
  eq 2, obj.two

test 'compound assignment (math operators)', ->
  num = 10
  num -= 5
  eq 5, num

  num *= 10
  eq 50, num

  num /= 10
  eq 5, num

  num %= 3
  eq 2, num

test 'more compound assignment', ->
  a = {}
  val = undefined
  val ||= a
  val ||= true
  eq a, val

  b = {}
  val &&= true
  eq val, true
  val &&= b
  eq b, val

  c = {}
  val = null
  val ?= c
  val ?= true
  eq c, val

test '#1192: assignment starting with object literals', ->
  doesNotThrow -> CoffeeScript.run '{}.p = 0'
  doesNotThrow -> CoffeeScript.run '{}.p++'
  doesNotThrow -> CoffeeScript.run '{}[0] = 1'
  doesNotThrow -> CoffeeScript.run """{a: 1, 'b', "#{1}": 2}.p = 0"""
  doesNotThrow -> CoffeeScript.run '{a:{0:{}}}.a[0] = 0'

{}.p = 0
{}.p++
{}[0] = 1
{ a: 1, 'b', "#{1}": 2 }.p = 0
{ a: 0: {} }.a[0] = 0

# Destructuring Assignment

test 'empty destructuring assignment', ->
  {} = {}
  [] = []

test 'chained destructuring assignments', ->
  [a] = { 0: b } = { '0': c } = [(nonce = {})]
  eq nonce, a
  eq nonce, b
  eq nonce, c

test 'variable swapping to verify caching of RHS values when appropriate', ->
  a = nonceA = {}
  b = nonceB = {}
  c = nonceC = {}
  [a, b, c] = [b, c, a]
  eq nonceB, a
  eq nonceC, b
  eq nonceA, c
  [a, b, c] = [b, c, a]
  eq nonceC, a
  eq nonceA, b
  eq nonceB, c
  fn = ->
    [a, b, c] = [b, c, a]
  arrayEq [nonceA, nonceB, nonceC], fn()
  eq nonceA, a
  eq nonceB, b
  eq nonceC, c

test '#713: destructuring assignment should return right-hand-side value', ->
  nonces = [(nonceA = {}), (nonceB = {})]
  eq nonces, ([a, b] = [c, d] = nonces)
  eq nonceA, a
  eq nonceA, c
  eq nonceB, b
  eq nonceB, d

test '#4787 destructuring of objects within arrays', ->
  arr = [1, { a: 1, b: 2 }]
  [..., { a, b }] = arr
  eq a, 1
  eq b, arr[1].b
  deepEqual { a, b }, arr[1]

test 'destructuring assignment with splats', ->
  a = {}
  b = {}
  c = {}
  d = {}
  e = {}
  [x, y..., z] = [a, b, c, d, e]
  eq a, x
  arrayEq [b, c, d], y
  eq e, z

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  [x, y..., z] = [a, b, c, d, e]
  eq a, x
  arrayEq [b, c, d], y
  eq e, z

test 'deep destructuring assignment with splats', ->
  a = {}
  b = {}
  c = {}
  d = {}
  e = {}
  f = {}
  g = {}
  h = {}
  i = {}
  [u, [v, w..., x], y..., z] = [a, [b, c, d, e], f, g, h, i]
  eq a, u
  eq b, v
  arrayEq [c, d], w
  eq e, x
  arrayEq [f, g, h], y
  eq i, z

test 'destructuring assignment with objects', ->
  a = {}
  b = {}
  c = {}
  obj = { a, b, c }
  { a: x, b: y, c: z } = obj
  eq a, x
  eq b, y
  eq c, z

test 'deep destructuring assignment with objects', ->
  a = {}
  b = {}
  c = {}
  d = {}
  obj = {
    a
    b:
      c:
        d: [b, { e: c, f: d }]
  }
  { a: w, b: { c: { d: [x, { f: z, e: y }] } } } = obj
  eq a, w
  eq b, x
  eq c, y
  eq d, z

test 'destructuring assignment with objects and splats', ->
  a = {}
  b = {}
  c = {}
  d = {}
  obj = a: b: [a, b, c, d]
  { a: { b: [y, z...] } } = obj
  eq a, y
  arrayEq [b, c, d], z

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  { a: { b: [y, z...] } } = obj
  eq a, y
  arrayEq [b, c, d], z

test 'destructuring assignment against an expression', ->
  a = {}
  b = {}
  [y, z] = if true then [a, b] else [b, a]
  eq a, y
  eq b, z

test 'bracket insertion when necessary', ->
  [a] = [0] ? [1]
  eq a, 0

# for implicit destructuring assignment in comprehensions, see the comprehension tests

test 'destructuring assignment with context (@) properties', ->
  a = {}
  b = {}
  c = {}
  d = {}
  e = {}
  obj =
    fn: ->
      local = [a, { b, c }, d, e]
      [@a, { b: @b, c: @c }, @d, @e] = local
  eq undefined, obj[key] for key in ['a', 'b', 'c', 'd', 'e']
  obj.fn()
  eq a, obj.a
  eq b, obj.b
  eq c, obj.c
  eq d, obj.d
  eq e, obj.e

test '#1024: destructure empty assignments to produce javascript-like results', ->
  eq 2 * ([] = 3 + 5), 16

test '#1005: invalid identifiers allowed on LHS of destructuring assignment', ->
  disallowed = ['eval', 'arguments'].concat CoffeeScript.RESERVED
  throws(
    -> CoffeeScript.compile "[#{disallowed.join ', '}] = x"
    null
    'all disallowed'
  )
  throws(
    -> CoffeeScript.compile "[#{disallowed.join '..., '}...] = x"
    null
    'all disallowed as splats'
  )
  t = tSplat = null
  for v in disallowed when (
    v isnt 'class' # \`class\` by itself is an expression
  )
    throws (-> CoffeeScript.compile t), null, (t = "[#{v}] = x")
    throws (-> CoffeeScript.compile tSplat), null, (tSplat = "[#{v}...] = x")
  doesNotThrow ->
    for v in disallowed
      CoffeeScript.compile "[a.#{v}] = x"
      CoffeeScript.compile "[a.#{v}...] = x"
      CoffeeScript.compile "[@#{v}] = x"
      CoffeeScript.compile "[@#{v}...] = x"

test '#2055: destructuring assignment with \`new\`', ->
  { length } = new Array()
  eq 0, length

test '#156: destructuring with expansion', ->
  array = [1..5]
  [first, ..., last] = array
  eq 1, first
  eq 5, last
  [..., lastButOne, last] = array
  eq 4, lastButOne
  eq 5, last
  [first, second, ..., last] = array
  eq 2, second
  [..., last] = 'strings as well -> x'
  eq 'x', last
  throws(
    -> CoffeeScript.compile '[1, ..., 3]'
    null
    'prohibit expansion outside of assignment'
  )
  throws(
    -> CoffeeScript.compile '[..., a, b...] = c'
    null
    'prohibit expansion and a splat'
  )
  throws (-> CoffeeScript.compile '[...] = c'), null, 'prohibit lone expansion'

test 'destructuring with dynamic keys', ->
  { "#{'a'}": a, """#{'b'}""": b, c } = a: 1, b: 2, c: 3
  eq 1, a
  eq 2, b
  eq 3, c
  throws -> CoffeeScript.compile '{"#{a}"} = b'

test 'simple array destructuring defaults', ->
  [a = 1] = []
  eq 1, a
  [a = 2] = [undefined]
  eq 2, a
  [a = 3] = [null]
  eq null, a # Breaking change in CS2: per ES2015, default values are applied for \`undefined\` but not for \`null\`.
  [a = 4] = [0]
  eq 0, a
  arr = [(a = 5)]
  eq 5, a
  arrayEq [5], arr

test 'simple object destructuring defaults', ->
  { b = 1 } = {}
  eq b, 1
  { b = 2 } = b: undefined
  eq b, 2
  { b = 3 } = b: null
  eq b, null # Breaking change in CS2: per ES2015, default values are applied for \`undefined\` but not for \`null\`.
  { b = 4 } = b: 0
  eq b, 0

  { b: c = 1 } = {}
  eq c, 1
  { b: c = 2 } = b: undefined
  eq c, 2
  { b: c = 3 } = b: null
  eq c, null # Breaking change in CS2: per ES2015, default values are applied for \`undefined\` but not for \`null\`.
  { b: c = 4 } = b: 0
  eq c, 0

test 'multiple array destructuring defaults', ->
  [a = 1, b = 2, c] = [undefined, 12, 13]
  eq a, 1
  eq b, 12
  eq c, 13
  [a, b = 2, c = 3] = [undefined, 12, 13]
  eq a, undefined
  eq b, 12
  eq c, 13
  [a = 1, b, c = 3] = [11, 12]
  eq a, 11
  eq b, 12
  eq c, 3

test 'multiple object destructuring defaults', ->
  { a = 1, b: bb = 2, c: c = 3, "#{0}": d = 4 } = "#{'b'}": 12
  eq a, 1
  eq bb, 12
  eq c, 3
  eq d, 4

test 'array destructuring defaults with splats', ->
  [..., a = 9] = []
  eq a, 9
  [..., b = 9] = [19]
  eq b, 19

test 'deep destructuring assignment with defaults', ->
  [a, [{ b = 1, c = 3 }] = [c: 2]] = [0]
  eq a, 0
  eq b, 1
  eq c, 2

test 'destructuring assignment with context (@) properties and defaults', ->
  a = {}
  b = {}
  c = {}
  d = {}
  e = {}
  obj =
    fn: ->
      local = [a, { b, c: undefined }, d]
      [@a, { b: @b = b, @c = c }, @d, @e = e] = local
  eq undefined, obj[key] for key in ['a', 'b', 'c', 'd', 'e']
  obj.fn()
  eq a, obj.a
  eq b, obj.b
  eq c, obj.c
  eq d, obj.d
  eq e, obj.e

test 'destructuring assignment with defaults single evaluation', ->
  callCount = 0
  fn = -> callCount++
  [a = fn()] = []
  eq 0, a
  eq 1, callCount
  [a = fn()] = [10]
  eq 10, a
  eq 1, callCount
  { a = fn(), b: c = fn() } = a: 20, b: undefined
  eq 20, a
  eq c, 1
  eq callCount, 2

# Existential Assignment

test 'existential assignment', ->
  nonce = {}
  a = false
  a ?= nonce
  eq false, a
  b = undefined
  b ?= nonce
  eq nonce, b
  c = null
  c ?= nonce
  eq nonce, c

test '#1627: prohibit conditional assignment of undefined variables', ->
  throws (-> CoffeeScript.compile 'x ?= 10'), null, 'prohibit (x ?= 10)'
  throws (-> CoffeeScript.compile 'x ||= 10'), null, 'prohibit (x ||= 10)'
  throws (-> CoffeeScript.compile 'x or= 10'), null, 'prohibit (x or= 10)'
  throws(
    -> CoffeeScript.compile 'do -> x ?= 10'
    null
    'prohibit (do -> x ?= 10)'
  )
  throws(
    -> CoffeeScript.compile 'do -> x ||= 10'
    null
    'prohibit (do -> x ||= 10)'
  )
  throws(
    -> CoffeeScript.compile 'do -> x or= 10'
    null
    'prohibit (do -> x or= 10)'
  )
  doesNotThrow(
    -> CoffeeScript.compile 'x = null; x ?= 10'
    'allow (x = null; x ?= 10)'
  )
  doesNotThrow(
    -> CoffeeScript.compile 'x = null; x ||= 10'
    'allow (x = null; x ||= 10)'
  )
  doesNotThrow(
    -> CoffeeScript.compile 'x = null; x or= 10'
    'allow (x = null; x or= 10)'
  )
  doesNotThrow(
    -> CoffeeScript.compile 'x = null; do -> x ?= 10'
    'allow (x = null; do -> x ?= 10)'
  )
  doesNotThrow(
    -> CoffeeScript.compile 'x = null; do -> x ||= 10'
    'allow (x = null; do -> x ||= 10)'
  )
  doesNotThrow(
    -> CoffeeScript.compile 'x = null; do -> x or= 10'
    'allow (x = null; do -> x or= 10)'
  )

  throws(
    -> CoffeeScript.compile '-> -> -> x ?= 10'
    null
    'prohibit (-> -> -> x ?= 10)'
  )
  doesNotThrow(
    -> CoffeeScript.compile 'x = null; -> -> -> x ?= 10'
    'allow (x = null; -> -> -> x ?= 10)'
  )

x = null
x ?= 10
x = null
x ||= 10
x = null
x or= 10
x = null
do -> x ?= 10
x = null
do -> x ||= 10
x = null
do -> x or= 10
x = null
-> -> -> x ?= 10

test 'more existential assignment', ->
  global.temp ?= 0
  eq global.temp, 0
  global.temp or= 100
  eq global.temp, 100
  delete global.temp

test '#1348, #1216: existential assignment compilation', ->
  nonce = {}
  a = nonce
  b = a ?= 0
  eq nonce, b
  #the first ?= compiles into a statement; the second ?= compiles to a ternary expression
  eq a ?= b ?= 1, nonce

  if a then a ?= 2 else a = 3
  eq a, nonce

test '#1591, #1101: splatted expressions in destructuring assignment must be assignable', ->
  nonce = {}
  for nonref in ['', '""', '0', 'f()', '(->)'].concat CoffeeScript.RESERVED
    eq nonce, try CoffeeScript.compile "[#{nonref}...] = v" catch e then nonce

test '#1643: splatted accesses in destructuring assignments should not be declared as variables', ->
  nonce = {}
  accesses = [
    'o.a'
    'o["a"]'
    '(o.a)'
    '(o.a).a'
    '@o.a'
    'C::a'
    'f().a'
    'o?.a'
    'o?.a.b'
    'f?().a'
  ]
  for access in accesses
    for i, j in [1, 2, 3] #position can matter
      code = """
        nonce = {}; nonce2 = {}; nonce3 = {};
        @o = o = new (class C then a:{}); f = -> o
        [#{new Array(i).join 'x,'}#{access}...] = [#{new Array(i).join(
        '0,'
      )}nonce, nonce2, nonce3]
        unless #{access}[0] is nonce and #{access}[1] is nonce2 and #{access}[2] is nonce3 then throw new Error('[...]')
        """
      eq nonce,
        unless (try CoffeeScript.run code, bare: true catch e then true)
          nonce
  # subpatterns like \`[[a]...]\` and \`[{a}...]\`
  subpatterns = ['[sub, sub2, sub3]', '{0: sub, 1: sub2, 2: sub3}']
  for subpattern in subpatterns
    for i, j in [1, 2, 3]
      code = """
        nonce = {}; nonce2 = {}; nonce3 = {};
        [#{new Array(i).join 'x,'}#{subpattern}...] = [#{new Array(i).join(
        '0,'
      )}nonce, nonce2, nonce3]
        unless sub is nonce and sub2 is nonce2 and sub3 is nonce3 then throw new Error('[sub...]')
        """
      eq nonce,
        unless (try CoffeeScript.run code, bare: true catch e then true)
          nonce

test '#1838: Regression with variable assignment', ->
  name = 'dave'

  eq name, 'dave'

test '#2211: splats in destructured parameters', ->
  doesNotThrow -> CoffeeScript.compile '([a...]) ->'
  doesNotThrow -> CoffeeScript.compile '([a...],b) ->'
  doesNotThrow -> CoffeeScript.compile '([a...],[b...]) ->'
  throws -> CoffeeScript.compile '([a...,[a...]]) ->'
  doesNotThrow -> CoffeeScript.compile '([a...,[b...]]) ->'

([a...]) ->
([a...], b) ->
([a...], [b...]) ->
([a..., [b...]]) ->

test '#2213: invocations within destructured parameters', ->
  throws -> CoffeeScript.compile '([a()])->'
  throws -> CoffeeScript.compile '([a:b()])->'
  throws -> CoffeeScript.compile '([a:b.c()])->'
  throws -> CoffeeScript.compile '({a()})->'
  throws -> CoffeeScript.compile '({a:b()})->'
  throws -> CoffeeScript.compile '({a:b.c()})->'

test '#2532: compound assignment with terminator', ->
  doesNotThrow ->
    CoffeeScript.compile '''
  a = "hello"
  a +=
  "
  world
  !
  "
  '''

a = 'hello'
a += '
world
!
'

test '#2613: parens on LHS of destructuring', ->
  a = {}
  [a.b] = [1, 2, 3]
  eq a.b, 1

test '#2181: conditional assignment as a subexpression', ->
  a = false
  false && (a or= true)
  eq false, a
  eq false, not (a or= true)

test '#1500: Assignment to variables similar to generated variables', ->
  len = 0
  x = (((results = null); n) for n in [1, 2, 3])
  arrayEq [1, 2, 3], x
  eq 0, len

  for x in [1, 2, 3]
    f = ->
      i = 0
    f()
    eq 'undefined', typeof i

  ref = 2
  x = ref * 2 ? 1
  eq x, 4
  eq 'undefined', typeof ref1

  x = {}
  base = -> x
  name = -1
  base()[-name] ?= 2
  eq x[1], 2
  eq base(), x
  eq name, -1

  f = (@a, a) -> [@a, a]
  arrayEq [1, 2], f.call (scope = {}), 1, 2
  eq 1, scope.a

  try
    throw 'foo'
  catch error
    eq error, 'foo'

  eq error, 'foo'

  doesNotThrow -> CoffeeScript.compile '(@slice...) ->'

test 'Assignment to variables similar to helper functions', ->
  f = (slice...) -> slice
  arrayEq [1, 2, 3], f 1, 2, 3
  eq 'undefined', typeof slice1

  class A
  class B extends A
    extend = 3
    hasProp = 4
    value: 5
    method: (bind, bind1) => [bind, bind1, extend, hasProp, @value]
  { method } = new B()
  arrayEq [1, 2, 3, 4, 5], method 1, 2

  modulo = -1 %% 3
  eq 2, modulo

  indexOf = [1, 2, 3]
  ok 2 in indexOf

test '#4566: destructuring with nested default values', ->
  { a: { b = 1 } } = a: {}
  eq 1, b

  { c: { d } = {} } = c: d: 3
  eq 3, d

  { e: { f = 5 } = {} } = {}
  eq 5, f

test '#4878: Compile error when using destructuring with a splat or expansion in an array', ->
  arr = ['a', 'b', 'c', 'd']

  f1 = (list) ->
    [first, ..., last] = list

  f2 = (list) ->
    [first..., last] = list

  f3 = (list) ->
    [first, ...] = list
    first

  f4 = (list) ->
    [first, rest...] = list
    rest

  arrayEq f1(arr), arr
  arrayEq f2(arr), arr
  arrayEq f3(arr), 'a'
  arrayEq f4(arr), ['b', 'c', 'd']

  foo = (list) ->
    ret = if list?.length > 0
      [first, ..., last] = list
      [first, last]
    else
      []

  arrayEq foo(arr), ['a', 'd']

  bar = (list) ->
    ret = if list?.length > 0
      [first, rest...] = list
      [first, rest]
    else
      []

  arrayEq bar(arr), ['a', ['b', 'c', 'd']]

test 'destructuring assignment with an empty array in object', ->
  obj =
    a1: [1, 2]
    b1: 3

  { a1: [], b1 } = obj
  eq 'undefined', typeof a1
  eq b1, 3

  obj =
    a2:
      b2: [1, 2]
    c2: 3

  { a2: { b2: [] }, c2 } = obj
  eq 'undefined', typeof b2
  eq c2, 3

test '#5004: array destructuring with accessors', ->
  obj =
    arr: ['a', 'b', 'c', 'd']
    list: {}
    f1: ->
      [@first, @rest...] = @arr
    f2: ->
      [@second, @third..., @last] = @rest
    f3: ->
      [@list.a, @list.middle..., @list.d] = @arr

  obj.f1()
  eq obj.first, 'a'
  arrayEq obj.rest, ['b', 'c', 'd']

  obj.f2()
  eq obj.second, 'b'
  arrayEq obj.third, ['c']
  eq obj.last, 'd'

  obj.f3()
  eq obj.list.a, 'a'
  arrayEq obj.list.middle, ['b', 'c']
  eq obj.list.d, 'd'

  [obj.list.middle..., d] = obj.arr
  eq d, 'd'
  arrayEq obj.list.middle, ['a', 'b', 'c']

test '#4884: destructured object splat', ->
  [{ length }...] = [1, 2, 3]
  eq length, 3
  [{ length: len }...] = [1, 2, 3]
  eq len, 3
  [{ length }..., three] = [1, 2, 3]
  eq length, 2
  eq three, 3
  [{ length: len }..., three] = [1, 2, 3]
  eq len, 2
  eq three, 3
  x = [{ length }..., three] = [1, 2, 3]
  eq length, 2
  eq three, 3
  eq x[2], 3
  x = [{ length: len }..., three] = [1, 2, 3]
  eq len, 2
  eq three, 3
  eq x[2], 3

test '#4884: destructured array splat', ->
  [[one, two, three]...] = [1, 2, 3]
  eq one, 1
  eq two, 2
  eq three, 3
  [[one, two]..., three] = [1, 2, 3]
  eq one, 1
  eq two, 2
  eq three, 3
  x = [[one, two]..., three] = [1, 2, 3]
  eq one, 1
  eq two, 2
  eq three, 3
  eq x[2], 3

`;

exports[`async.coffee 1`] = `
# Functions that contain the \`await\` keyword will compile into async functions,
# supported by Node 7.6+, Chrome 55+, Firefox 52+, Safari 10.1+ and Edge.
# But runtimes that don’t support the \`await\` keyword will throw an error just
# from parsing this file, even without executing it, even if we put
# \`return unless try new Function 'async () => {}'\` at the top of this file.
# Therefore we need to prevent runtimes which will choke on such code from
# parsing it, which is handled in \`Cakefile\`.


# This is always fulfilled.
winning = (val) -> Promise.resolve val

# This is always rejected.
failing = (val) -> Promise.reject new Error val


test "async as argument", ->
  ok ->
    await winning()

test "explicit async", ->
  a = do ->
    await return 5
  eq a.constructor, Promise
  a.then (val) ->
    eq val, 5

test "implicit async", ->
  a = do ->
    x = await winning(5)
    y = await winning(4)
    z = await winning(3)
    [x, y, z]

  eq a.constructor, Promise

test "async return value (implicit)", ->
  out = null
  a = ->
    x = await winning(5)
    y = await winning(4)
    z = await winning(3)
    [x, y, z]

  b = do ->
    out = await a()

  b.then ->
    arrayEq out, [5, 4, 3]

test "async return value (explicit)", ->
  out = null
  a = ->
    await return [5, 2, 3]

  b = do ->
    out = await a()

  b.then ->
    arrayEq out, [5, 2, 3]


test "async parameters", ->
  [out1, out2] = [null, null]
  a = (a, [b, c])->
    arr = [a]
    arr.push b
    arr.push c
    await return arr

  b = (a, b, c = 5)->
    arr = [a]
    arr.push b
    arr.push c
    await return arr

  c = do ->
    out1 = await a(5, [4, 3])
    out2 = await b(4, 4)

  c.then ->
    arrayEq out1, [5, 4, 3]
    arrayEq out2, [4, 4, 5]

test "async \`this\` scoping", ->
  bnd = null
  ubnd = null
  nst = null
  obj =
    bound: ->
      return do =>
        await return this
    unbound: ->
      return do ->
        await return this
    nested: ->
      return do =>
        await do =>
          await do =>
            await return this

  promise = do ->
    bnd = await obj.bound()
    ubnd = await obj.unbound()
    nst = await obj.nested()

  promise.then ->
    eq bnd, obj
    ok ubnd isnt obj
    eq nst, obj

test "await precedence", ->
  out = null

  fn = (win, fail) ->
    win(3)

  promise = do ->
    # assert precedence between unary (new) and power (**) operators
    out = 1 + await new Promise(fn) ** 2

  promise.then ->
    eq out, 10

test "\`await\` inside IIFEs", ->
  [x, y, z] = new Array(3)

  a = do ->
    x = switch (4)  # switch 4
      when 2
        await winning(1)
      when 4
        await winning(5)
      when 7
        await winning(2)

    y = try
      text = "this should be caught"
      throw new Error(text)
      await winning(1)
    catch e
      await winning(4)

    z = for i in [0..5]
      a = i * i
      await winning(a)

  a.then ->
    eq x, 5
    eq y, 4

    arrayEq z, [0, 1, 4, 9, 16, 25]

test "error handling", ->
  res = null
  val = 0
  a = ->
    try
      await failing("fail")
    catch e
      val = 7  # to assure the catch block runs
      return e

  b = do ->
    res = await a()

  b.then ->
    eq val, 7

    ok res.message?
    eq res.message, "fail"

test "await expression evaluates to argument if not A+", ->
  eq(await 4, 4)


test "implicit call with \`await\`", ->
  addOne = (arg) -> arg + 1

  a = addOne await 3
  eq a, 4

test "async methods in classes", ->
  class Base
    @static: ->
      await 1
    method: ->
      await 2

  eq await Base.static(), 1
  eq await new Base().method(), 2

  class Child extends Base
    @static: -> super()
    method: -> super()

  eq await Child.static(), 1
  eq await new Child().method(), 2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Functions that contain the \`await\` keyword will compile into async functions,
# supported by Node 7.6+, Chrome 55+, Firefox 52+, Safari 10.1+ and Edge.
# But runtimes that don’t support the \`await\` keyword will throw an error just
# from parsing this file, even without executing it, even if we put
# \`return unless try new Function 'async () => {}'\` at the top of this file.
# Therefore we need to prevent runtimes which will choke on such code from
# parsing it, which is handled in \`Cakefile\`.

# This is always fulfilled.
winning = (val) -> Promise.resolve val

# This is always rejected.
failing = (val) -> Promise.reject new Error val

test 'async as argument', ->
  ok ->
    await winning()

test 'explicit async', ->
  a = do ->
    await return 5
  eq a.constructor, Promise
  a.then (val) ->
    eq val, 5

test 'implicit async', ->
  a = do ->
    x = await winning 5
    y = await winning 4
    z = await winning 3
    [x, y, z]

  eq a.constructor, Promise

test 'async return value (implicit)', ->
  out = null
  a = ->
    x = await winning 5
    y = await winning 4
    z = await winning 3
    [x, y, z]

  b = do ->
    out = await a()

  b.then ->
    arrayEq out, [5, 4, 3]

test 'async return value (explicit)', ->
  out = null
  a = ->
    await return [5, 2, 3]

  b = do ->
    out = await a()

  b.then ->
    arrayEq out, [5, 2, 3]

test 'async parameters', ->
  [out1, out2] = [null, null]
  a = (a, [b, c]) ->
    arr = [a]
    arr.push b
    arr.push c
    await return arr

  b = (a, b, c = 5) ->
    arr = [a]
    arr.push b
    arr.push c
    await return arr

  c = do ->
    out1 = await a 5, [4, 3]
    out2 = await b 4, 4

  c.then ->
    arrayEq out1, [5, 4, 3]
    arrayEq out2, [4, 4, 5]

test 'async \`this\` scoping', ->
  bnd = null
  ubnd = null
  nst = null
  obj =
    bound: ->
      return do =>
        await return this
    unbound: ->
      return do ->
        await return this
    nested: ->
      return do =>
        await do =>
          await do =>
            await return this

  promise = do ->
    bnd = await obj.bound()
    ubnd = await obj.unbound()
    nst = await obj.nested()

  promise.then ->
    eq bnd, obj
    ok ubnd isnt obj
    eq nst, obj

test 'await precedence', ->
  out = null

  fn = (win, fail) ->
    win 3

  promise = do ->
    # assert precedence between unary (new) and power (**) operators
    out = 1 + (await new Promise(fn)) ** 2

  promise.then ->
    eq out, 10

test '\`await\` inside IIFEs', ->
  [x, y, z] = new Array 3

  a = do ->
    x = switch (
      4 # switch 4
    )
      when 2
        await winning 1
      when 4
        await winning 5
      when 7
        await winning 2

    y = try
      text = 'this should be caught'
      throw new Error text
      await winning 1
    catch e
      await winning 4

    z = for i in [0..5]
      a = i * i
      await winning a

  a.then ->
    eq x, 5
    eq y, 4

    arrayEq z, [0, 1, 4, 9, 16, 25]

test 'error handling', ->
  res = null
  val = 0
  a = ->
    try
      await failing 'fail'
    catch e
      val = 7 # to assure the catch block runs
      return e

  b = do ->
    res = await a()

  b.then ->
    eq val, 7

    ok res.message?
    eq res.message, 'fail'

test 'await expression evaluates to argument if not A+', ->
  eq await 4, 4

test 'implicit call with \`await\`', ->
  addOne = (arg) -> arg + 1

  a = addOne await 3
  eq a, 4

test 'async methods in classes', ->
  class Base
    @static: ->
      await 1
    method: ->
      await 2

  eq await Base.static(), 1
  eq await new Base().method(), 2

  class Child extends Base
    @static: -> super()
    method: -> super()

  eq await Child.static(), 1
  eq await new Child().method(), 2

`;

exports[`async_iterators.coffee 1`] = `
# This is always fulfilled.
winLater = (val, ms) ->
  new Promise (resolve) -> setTimeout (-> resolve val), ms

# This is always rejected.
failLater = (val, ms) ->
  new Promise (resolve, reject) -> setTimeout (-> reject new Error val), ms

createAsyncIterable = (syncIterable) ->
  for elem in syncIterable
    yield await winLater elem, 50

test "async iteration", ->
  foo = (x for await x from createAsyncIterable [1,2,3])
  arrayEq foo, [1, 2, 3]

test "async generator functions", ->
  foo = (val) ->
    yield await winLater val + 1, 50

  bar = (val) ->
    yield await failLater val - 1, 50

  a = await foo(41).next()
  eq a.value, 42

  try
    b = do -> await bar(41).next()
    b.catch (err) ->
      eq "40", err.message
  catch err
    ok no
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This is always fulfilled.
winLater = (val, ms) ->
  new Promise (resolve) -> setTimeout (-> resolve val), ms

# This is always rejected.
failLater = (val, ms) ->
  new Promise (resolve, reject) -> setTimeout (-> reject new Error val), ms

createAsyncIterable = (syncIterable) ->
  for elem in syncIterable
    yield await winLater elem, 50

test 'async iteration', ->
  foo = (x for await x from createAsyncIterable [1, 2, 3])
  arrayEq foo, [1, 2, 3]

test 'async generator functions', ->
  foo = (val) ->
    yield await winLater val + 1, 50

  bar = (val) ->
    yield await failLater val - 1, 50

  a = await foo(41).next()
  eq a.value, 42

  try
    b = do -> await bar(41).next()
    b.catch (err) ->
      eq '40', err.message
  catch err
    ok no

`;

exports[`booleans.coffee 1`] = `
# Boolean Literals
# ----------------

# TODO: add method invocation tests: true.toString() is "true"

test "#764 Booleans should be indexable", ->
  toString = Boolean::toString

  eq toString, true['toString']
  eq toString, false['toString']
  eq toString, yes['toString']
  eq toString, no['toString']
  eq toString, on['toString']
  eq toString, off['toString']

  eq toString, true.toString
  eq toString, false.toString
  eq toString, yes.toString
  eq toString, no.toString
  eq toString, on.toString
  eq toString, off.toString
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Boolean Literals
# ----------------

# TODO: add method invocation tests: true.toString() is "true"

test '#764 Booleans should be indexable', ->
  toString = Boolean::toString

  eq toString, true['toString']
  eq toString, false['toString']
  eq toString, yes['toString']
  eq toString, no['toString']
  eq toString, on['toString']
  eq toString, off['toString']

  eq toString, true.toString
  eq toString, false.toString
  eq toString, yes.toString
  eq toString, no.toString
  eq toString, on.toString
  eq toString, off.toString

`;

exports[`classes.coffee 1`] = `
# Classes
# -------

# * Class Definition
# * Class Instantiation
# * Inheritance and Super
# * ES2015+ Class Interoperability

test "classes with a four-level inheritance chain", ->

  class Base
    func: (string) ->
      "zero/#{string}"

    @static: (string) ->
      "static/#{string}"

  class FirstChild extends Base
    func: (string) ->
      super('one/') + string

  SecondChild = class extends FirstChild
    func: (string) ->
      super('two/') + string

  thirdCtor = ->
    @array = [1, 2, 3]

  class ThirdChild extends SecondChild
    constructor: ->
      super()
      thirdCtor.call this

    # Gratuitous comment for testing.
    func: (string) ->
      super('three/') + string

  result = (new ThirdChild).func 'four'

  ok result is 'zero/one/two/three/four'
  ok Base.static('word') is 'static/word'

  ok (new ThirdChild).array.join(' ') is '1 2 3'


test "constructors with inheritance and super", ->

  identity = (f) -> f

  class TopClass
    constructor: (arg) ->
      @prop = 'top-' + arg

  class SuperClass extends TopClass
    constructor: (arg) ->
      identity super 'super-' + arg

  class SubClass extends SuperClass
    constructor: ->
      identity super 'sub'

  ok (new SubClass).prop is 'top-super-sub'


test "'super' with accessors", ->
  class Base
    m: -> 4
    n: -> 5
    o: -> 6

  name = 'o'
  class A extends Base
    m: -> super()
    n: -> super.n()
    "#{name}": -> super()
    p: -> super[name]()

  a = new A
  eq 4, a.m()
  eq 5, a.n()
  eq 6, a.o()
  eq 6, a.p()


test "soaked 'super' invocation", ->
  class Base
    method: -> 2

  class A extends Base
    method: -> super?()
    noMethod: -> super?()

  a = new A
  eq 2, a.method()
  eq undefined, a.noMethod()

  name = 'noMethod'
  class B extends Base
    "#{'method'}": -> super?()
    "#{'noMethod'}": -> super?() ? super['method']()

  b = new B
  eq 2, b.method()
  eq 2, b.noMethod()

test "'@' referring to the current instance, and not being coerced into a call", ->

  class ClassName
    amI: ->
      @ instanceof ClassName

  obj = new ClassName
  ok obj.amI()


test "super() calls in constructors of classes that are defined as object properties", ->

  class Hive
    constructor: (name) -> @name = name

  class Hive.Bee extends Hive
    constructor: (name) -> super name

  maya = new Hive.Bee 'Maya'
  ok maya.name is 'Maya'


test "classes with JS-keyword properties", ->

  class Class
    class: 'class'
    name: -> @class

  instance = new Class
  ok instance.class is 'class'
  ok instance.name() is 'class'


test "Classes with methods that are pre-bound to the instance, or statically, to the class", ->

  class Dog
    constructor: (name) ->
      @name = name

    bark: =>
      "#{@name} woofs!"

    @static = =>
      new this('Dog')

  spark = new Dog('Spark')
  fido  = new Dog('Fido')
  fido.bark = spark.bark

  ok fido.bark() is 'Spark woofs!'

  obj = func: Dog.static

  ok obj.func().name is 'Dog'


test "a bound function in a bound function", ->

  class Mini
    num: 10
    generate: =>
      for i in [1..3]
        =>
          @num

  m = new Mini
  eq (func() for func in m.generate()).join(' '), '10 10 10'


test "contructor called with varargs", ->

  class Connection
    constructor: (one, two, three) ->
      [@one, @two, @three] = [one, two, three]

    out: ->
      "#{@one}-#{@two}-#{@three}"

  list = [3, 2, 1]
  conn = new Connection list...
  ok conn instanceof Connection
  ok conn.out() is '3-2-1'


test "calling super and passing along all arguments", ->

  class Parent
    method: (args...) -> @args = args

  class Child extends Parent
    method: -> super arguments...

  c = new Child
  c.method 1, 2, 3, 4
  ok c.args.join(' ') is '1 2 3 4'


test "classes wrapped in decorators", ->

  func = (klass) ->
    klass::prop = 'value'
    klass

  func class Test
    prop2: 'value2'

  ok (new Test).prop  is 'value'
  ok (new Test).prop2 is 'value2'


test "anonymous classes", ->

  obj =
    klass: class
      method: -> 'value'

  instance = new obj.klass
  ok instance.method() is 'value'


test "Implicit objects as static properties", ->

  class Static
    @static =
      one: 1
      two: 2

  ok Static.static.one is 1
  ok Static.static.two is 2


test "nothing classes", ->

  c = class
  ok c instanceof Function


test "classes with static-level implicit objects", ->

  class A
    @static = one: 1
    two: 2

  class B
    @static = one: 1,
    two: 2

  eq A.static.one, 1
  eq A.static.two, undefined
  eq (new A).two, 2

  eq B.static.one, 1
  eq B.static.two, 2
  eq (new B).two, undefined


test "classes with value'd constructors", ->

  counter = 0
  classMaker = ->
    inner = ++counter
    ->
      @value = inner
      @

  class One
    constructor: classMaker()

  class Two
    constructor: classMaker()

  eq (new One).value, 1
  eq (new Two).value, 2
  eq (new One).value, 1
  eq (new Two).value, 2


test "executable class bodies", ->

  class A
    if true
      b: 'b'
    else
      c: 'c'

  a = new A

  eq a.b, 'b'
  eq a.c, undefined


test "#2502: parenthesizing inner object values", ->

  class A
    category:  (type: 'string')
    sections:  (type: 'number', default: 0)

  eq (new A).category.type, 'string'

  eq (new A).sections.default, 0


test "conditional prototype property assignment", ->
  debug = false

  class Person
    if debug
      age: -> 10
    else
      age: -> 20

  eq (new Person).age(), 20


test "mild metaprogramming", ->

  class Base
    @attr: (name) ->
      @::[name] = (val) ->
        if arguments.length > 0
          @["_#{name}"] = val
        else
          @["_#{name}"]

  class Robot extends Base
    @attr 'power'
    @attr 'speed'

  robby = new Robot

  ok robby.power() is undefined

  robby.power 11
  robby.speed Infinity

  eq robby.power(), 11
  eq robby.speed(), Infinity


test "namespaced classes do not reserve their function name in outside scope", ->

  one = {}
  two = {}

  class one.Klass
    @label = "one"

  class two.Klass
    @label = "two"

  eq typeof Klass, 'undefined'
  eq one.Klass.label, 'one'
  eq two.Klass.label, 'two'


test "nested classes", ->

  class Outer
    constructor: ->
      @label = 'outer'

    class @Inner
      constructor: ->
        @label = 'inner'

  eq (new Outer).label, 'outer'
  eq (new Outer.Inner).label, 'inner'


test "variables in constructor bodies are correctly scoped", ->

  class A
    x = 1
    constructor: ->
      x = 10
      y = 20
    y = 2
    captured: ->
      {x, y}

  a = new A
  eq a.captured().x, 10
  eq a.captured().y, 2


test "Issue #924: Static methods in nested classes", ->

  class A
    @B: class
      @c = -> 5

  eq A.B.c(), 5


test "\`class extends this\`", ->

  class A
    func: -> 'A'

  B = null
  makeClass = ->
    B = class extends this
      func: -> super() + ' B'

  makeClass.call A

  eq (new B()).func(), 'A B'


test "ensure that constructors invoked with splats return a new object", ->

  args = [1, 2, 3]
  Type = (@args) ->
  type = new Type args

  ok type and type instanceof Type
  ok type.args and type.args instanceof Array
  ok v is args[i] for v, i in type.args

  Type1 = (@a, @b, @c) ->
  type1 = new Type1 args...

  ok type1 instanceof   Type1
  eq type1.constructor, Type1
  ok type1.a is args[0] and type1.b is args[1] and type1.c is args[2]

  # Ensure that constructors invoked with splats cache the function.
  called = 0
  get = -> if called++ then false else class Type
  new (get()) args...

test "\`new\` shouldn't add extra parens", ->

  ok new Date().constructor is Date


test "\`new\` works against bare function", ->

  eq Date, new ->
    Date


test "#1182: a subclass should be able to set its constructor to an external function", ->
  ctor = ->
    @val = 1
    return
  class A
  class B extends A
    constructor: ctor
  eq (new B).val, 1

test "#1182: external constructors continued", ->
  ctor = ->
  class A
  class B extends A
    method: ->
    constructor: ctor
  ok B::method

test "#1313: misplaced __extends", ->
  nonce = {}
  class A
  class B extends A
    prop: nonce
    constructor: -> super()
  eq nonce, B::prop

test "#1182: execution order needs to be considered as well", ->
  counter = 0
  makeFn = (n) -> eq n, ++counter; ->
  class B extends (makeFn 1)
    @B: makeFn 2
    constructor: makeFn 3

test "#1182: external constructors with bound functions", ->
  fn = ->
    {one: 1}
    this
  class B
  class A
    constructor: fn
    method: => this instanceof A
  ok (new A).method.call(new B)

test "#1372: bound class methods with reserved names", ->
  class C
    delete: =>
  ok C::delete

test "#1380: \`super\` with reserved names", ->
  class C
    do: -> super()
  ok C::do

  class B
    0: -> super()
  ok B::[0]

test "#1464: bound class methods should keep context", ->
  nonce  = {}
  nonce2 = {}
  class C
    constructor: (@id) ->
    @boundStaticColon: => new this(nonce)
    @boundStaticEqual= => new this(nonce2)
  eq nonce,  C.boundStaticColon().id
  eq nonce2, C.boundStaticEqual().id

test "#1009: classes with reserved words as determined names", -> (->
  eq 'function', typeof (class @for)
  ok not /\\beval\\b/.test (class @eval).toString()
  ok not /\\barguments\\b/.test (class @arguments).toString()
).call {}

test "#1482: classes can extend expressions", ->
  id = (x) -> x
  nonce = {}
  class A then nonce: nonce
  class B extends id A
  eq nonce, (new B).nonce

test "#1598: super works for static methods too", ->

  class Parent
    method: ->
      'NO'
    @method: ->
      'yes'

  class Child extends Parent
    @method: ->
      'pass? ' + super()

  eq Child.method(), 'pass? yes'

test "#1842: Regression with bound functions within bound class methods", ->

  class Store
    @bound: =>
      do =>
        eq this, Store

  Store.bound()

  # And a fancier case:

  class Store

    eq this, Store

    @bound: =>
      do =>
        eq this, Store

    @unbound: ->
      eq this, Store

    instance: =>
      ok this instanceof Store

  Store.bound()
  Store.unbound()
  (new Store).instance()

test "#1876: Class @A extends A", ->
  class A
  class @A extends A

  ok (new @A) instanceof A

test "#1813: Passing class definitions as expressions", ->
  ident = (x) -> x

  result = ident class A then x = 1

  eq result, A

  result = ident class B extends A
    x = 1

  eq result, B

test "#1966: external constructors should produce their return value", ->
  ctor = -> {}
  class A then constructor: ctor
  ok (new A) not instanceof A

test "#1980: regression with an inherited class with static function members", ->

  class A

  class B extends A
    @static: => 'value'

  eq B.static(), 'value'

test "#1534: class then 'use strict'", ->
  # [14.1 Directive Prologues and the Use Strict Directive](http://es5.github.com/#x14.1)
  nonce = {}
  error = 'do -> ok this'
  strictTest = "do ->'use strict';#{error}"
  return unless (try CoffeeScript.run strictTest, bare: yes catch e then nonce) is nonce

  throws -> CoffeeScript.run "class then 'use strict';#{error}", bare: yes
  doesNotThrow -> CoffeeScript.run "class then #{error}", bare: yes
  doesNotThrow -> CoffeeScript.run "class then #{error};'use strict'", bare: yes

  # comments are ignored in the Directive Prologue
  comments = ["""
  class
    ### comment ###
    'use strict'
    #{error}""",
  """
  class
    ### comment 1 ###
    ### comment 2 ###
    'use strict'
    #{error}""",
  """
  class
    ### comment 1 ###
    ### comment 2 ###
    'use strict'
    #{error}
    ### comment 3 ###"""
  ]
  throws (-> CoffeeScript.run comment, bare: yes) for comment in comments

  # [ES5 §14.1](http://es5.github.com/#x14.1) allows for other directives
  directives = ["""
  class
    'directive 1'
    'use strict'
    #{error}""",
  """
  class
    'use strict'
    'directive 2'
    #{error}""",
  """
  class
    ### comment 1 ###
    'directive 1'
    'use strict'
    #{error}""",
  """
  class
    ### comment 1 ###
    'directive 1'
    ### comment 2 ###
    'use strict'
    #{error}"""
  ]
  throws (-> CoffeeScript.run directive, bare: yes) for directive in directives

test "#2052: classes should work in strict mode", ->
  try
    do ->
      'use strict'
      class A
  catch e
    ok no

test "directives in class with extends ", ->
  strictTest = """
    class extends Object
      ### comment ###
      'use strict'
      do -> eq this, undefined
  """
  CoffeeScript.run strictTest, bare: yes

test "#2630: class bodies can't reference arguments", ->
  throws ->
    CoffeeScript.compile('class Test then arguments')

  # #4320: Don't be too eager when checking, though.
  class Test
    arguments: 5
  eq 5, Test::arguments

test "#2319: fn class n extends o.p [INDENT] x = 123", ->
  first = ->

  base = onebase: ->

  first class OneKeeper extends base.onebase
    one = 1
    one: -> one

  eq new OneKeeper().one(), 1


test "#2599: other typed constructors should be inherited", ->
  class Base
    constructor: -> return {}

  class Derived extends Base

  ok (new Derived) not instanceof Derived
  ok (new Derived) not instanceof Base
  ok (new Base) not instanceof Base

test "extending native objects works with and without defining a constructor", ->
  class MyArray extends Array
    method: -> 'yes!'

  myArray = new MyArray
  ok myArray instanceof MyArray
  ok 'yes!', myArray.method()

  class OverrideArray extends Array
    constructor: -> super()
    method: -> 'yes!'

  overrideArray = new OverrideArray
  ok overrideArray instanceof OverrideArray
  eq 'yes!', overrideArray.method()


test "#2782: non-alphanumeric-named bound functions", ->
  class A
    'b:c': =>
      'd'

  eq (new A)['b:c'](), 'd'


test "#2781: overriding bound functions", ->
  class A
    a: ->
        @b()
    b: =>
        1

  class B extends A
    b: =>
        2

  b = (new A).b
  eq b(), 1

  b = (new B).b
  eq b(), 2


test "#2791: bound function with destructured argument", ->
  class Foo
    method: ({a}) => 'Bar'

  eq (new Foo).method({a: 'Bar'}), 'Bar'


test "#2796: ditto, ditto, ditto", ->
  answer = null

  outsideMethod = (func) ->
    func.call message: 'wrong!'

  class Base
    constructor: ->
      @message = 'right!'
      outsideMethod @echo

    echo: =>
      answer = @message

  new Base
  eq answer, 'right!'

test "#3063: Class bodies cannot contain pure statements", ->
  throws -> CoffeeScript.compile """
    class extends S
      return if S.f
      @f: => this
  """

test "#2949: super in static method with reserved name", ->
  class Foo
    @static: -> 'baz'

  class Bar extends Foo
    @static: -> super()

  eq Bar.static(), 'baz'

test "#3232: super in static methods (not object-assigned)", ->
  class Foo
    @baz = -> true
    @qux = -> true

  class Bar extends Foo
    @baz = -> super()
    Bar.qux = -> super()

  ok Bar.baz()
  ok Bar.qux()

test "#1392 calling \`super\` in methods defined on namespaced classes", ->
  class Base
    m: -> 5
    n: -> 4
  namespace =
    A: ->
    B: ->
  class namespace.A extends Base
    m: -> super()

  eq 5, (new namespace.A).m()
  namespace.B::m = namespace.A::m
  namespace.A::m = null
  eq 5, (new namespace.B).m()

  class C
    @a: class extends Base
      m: -> super()
  eq 5, (new C.a).m()


test "#4436 immediately instantiated named class", ->
  ok new class Foo


test "dynamic method names", ->
  class A
    "#{name = 'm'}": -> 1
  eq 1, new A().m()

  class B extends A
    "#{name = 'm'}": -> super()
  eq 1, new B().m()

  getName = -> 'm'
  class C
    "#{name = getName()}": -> 1
  eq 1, new C().m()


test "dynamic method names and super", ->
  class Base
    @m: -> 6
    m: -> 5
    m2: -> 4.5
    n: -> 4

  name = -> count++; 'n'
  count = 0

  m = 'm'
  class A extends Base
    "#{m}": -> super()
    "#{name()}": -> super()

  m = 'n'
  eq 5, (new A).m()

  eq 4, (new A).n()
  eq 1, count

  m = 'm'
  m2 = 'm2'
  count = 0
  class B extends Base
    @[name()] = -> super()
    "#{m}": -> super()
    "#{m2}": -> super()
  b = new B
  m = m2 = 'n'
  eq 6, B.m()
  eq 5, b.m()
  eq 4.5, b.m2()
  eq 1, count

  class C extends B
    m: -> super()
  eq 5, (new C).m()

# ES2015+ class interoperability
# Based on https://github.com/balupton/es6-javascript-class-interop
# Helper functions to generate true ES classes to extend:
getBasicClass = ->
  \`\`\`
  class BasicClass {
    constructor (greeting) {
      this.greeting = greeting || 'hi'
    }
  }
  \`\`\`
  BasicClass

getExtendedClass = (BaseClass) ->
  \`\`\`
  class ExtendedClass extends BaseClass {
    constructor (greeting, name) {
      super(greeting || 'hello')
      this.name = name
    }
  }
  \`\`\`
  ExtendedClass

test "can instantiate a basic ES class", ->
  BasicClass = getBasicClass()
  i = new BasicClass 'howdy!'
  eq i.greeting, 'howdy!'

test "can instantiate an extended ES class", ->
  BasicClass = getBasicClass()
  ExtendedClass = getExtendedClass BasicClass
  i = new ExtendedClass 'yo', 'buddy'
  eq i.greeting, 'yo'
  eq i.name, 'buddy'

test "can extend a basic ES class", ->
  BasicClass = getBasicClass()
  class ExtendedClass extends BasicClass
    constructor: (@name) ->
      super()
  i = new ExtendedClass 'dude'
  eq i.name, 'dude'

test "can extend an extended ES class", ->
  BasicClass = getBasicClass()
  ExtendedClass = getExtendedClass BasicClass

  class ExtendedExtendedClass extends ExtendedClass
    constructor: (@value) ->
      super()
    getDoubledValue: ->
      @value * 2

  i = new ExtendedExtendedClass 7
  eq i.getDoubledValue(), 14

test "CoffeeScript class can be extended in ES", ->
  class CoffeeClass
    constructor: (@favoriteDrink = 'latte', @size = 'grande') ->
    getDrinkOrder: ->
      "#{@size} #{@favoriteDrink}"

  \`\`\`
  class ECMAScriptClass extends CoffeeClass {
    constructor (favoriteDrink) {
      super(favoriteDrink);
      this.favoriteDrink = this.favoriteDrink + ' with a dash of semicolons';
    }
  }
  \`\`\`

  e = new ECMAScriptClass 'coffee'
  eq e.getDrinkOrder(), 'grande coffee with a dash of semicolons'

test "extended CoffeeScript class can be extended in ES", ->
  class CoffeeClass
    constructor: (@favoriteDrink = 'latte') ->

  class CoffeeClassWithDrinkOrder extends CoffeeClass
    constructor: (@favoriteDrink, @size = 'grande') ->
      super()
    getDrinkOrder: ->
      "#{@size} #{@favoriteDrink}"

  \`\`\`
  class ECMAScriptClass extends CoffeeClassWithDrinkOrder {
    constructor (favoriteDrink) {
      super(favoriteDrink);
      this.favoriteDrink = this.favoriteDrink + ' with a dash of semicolons';
    }
  }
  \`\`\`

  e = new ECMAScriptClass 'coffee'
  eq e.getDrinkOrder(), 'grande coffee with a dash of semicolons'

test "\`this\` access after \`super\` in extended classes", ->
  class Base

  class Test extends Base
    constructor: (param, @param) ->
      eq param, nonce

      result = { super: super(), @param, @method }
      eq result.super, this
      eq result.param, @param
      eq result.method, @method
      ok result.method isnt Test::method

    method: =>

  nonce = {}
  new Test nonce, {}

test "\`@\`-params and bound methods with multiple \`super\` paths (blocks)", ->
  nonce = {}

  class Base
    constructor: (@name) ->

  class Test extends Base
    constructor: (param, @param) ->
      if param
        super 'param'
        eq @name, 'param'
      else
        super 'not param'
        eq @name, 'not param'
      eq @param, nonce
      ok @method isnt Test::method
    method: =>
  new Test true, nonce
  new Test false, nonce


test "\`@\`-params and bound methods with multiple \`super\` paths (expressions)", ->
  nonce = {}

  class Base
    constructor: (@name) ->

  class Test extends Base
    constructor: (param, @param) ->
      # Contrived example: force each path into an expression with inline assertions
      if param
        result = (
          eq (super 'param'), @;
          eq @name, 'param';
          eq @param, nonce;
          ok @method isnt Test::method
        )
      else
        result = (
          eq (super 'not param'), @;
          eq @name, 'not param';
          eq @param, nonce;
          ok @method isnt Test::method
        )
    method: =>
  new Test true, nonce
  new Test false, nonce

test "constructor super in arrow functions", ->
  class Test extends (class)
    constructor: (@param) ->
      do => super()
      eq @param, nonce

  new Test nonce = {}

# TODO Some of these tests use CoffeeScript.compile and CoffeeScript.run when they could use
# regular test mechanics.
# TODO Some of these tests might be better placed in \`test/error_messages.coffee\`.
# TODO Some of these tests are duplicates.

# Ensure that we always throw if we experience more than one super()
# call in a constructor.  This ends up being a runtime error.
# Should be caught at compile time.
test "multiple super calls", ->
  throwsA = """
  class A
    constructor: (@drink) ->
    make: -> "Making a #{@drink}"

  class MultiSuper extends A
    constructor: (drink) ->
      super(drink)
      super(drink)
      @newDrink = drink
  new MultiSuper('Late').make()
  """
  throws -> CoffeeScript.run throwsA, bare: yes

# Basic test to ensure we can pass @params in a constuctor and
# inheritance works correctly
test "@ params", ->
  class A
    constructor: (@drink, @shots, @flavor) ->
    make: -> "Making a #{@flavor} #{@drink} with #{@shots} shot(s)"

  a = new A('Machiato', 2, 'chocolate')
  eq a.make(),  "Making a chocolate Machiato with 2 shot(s)"

  class B extends A
  b = new B('Machiato', 2, 'chocolate')
  eq b.make(),  "Making a chocolate Machiato with 2 shot(s)"

# Ensure we can accept @params with default parameters in a constructor
test "@ params with defaults in a constructor", ->
  class A
    # Multiple @ params with defaults
    constructor: (@drink = 'Americano', @shots = '1', @flavor = 'caramel') ->
    make: -> "Making a #{@flavor} #{@drink} with #{@shots} shot(s)"

  a = new A()
  eq a.make(),  "Making a caramel Americano with 1 shot(s)"

# Ensure we can handle default constructors with class params
test "@ params with class params", ->
  class Beverage
    drink: 'Americano'
    shots: '1'
    flavor: 'caramel'

  class A
    # Class creation as a default param with \`this\`
    constructor: (@drink = new Beverage()) ->
  a = new A()
  eq a.drink.drink, 'Americano'

  beverage = new Beverage
  class B
    # class costruction with a default external param
    constructor: (@drink = beverage) ->

  b = new B()
  eq b.drink.drink, 'Americano'

  class C
    # Default constructor with anonymous empty class
    constructor: (@meta = class) ->
  c = new C()
  ok c.meta instanceof Function

test "@ params without super, including errors", ->
  classA = """
  class A
    constructor: (@drink) ->
    make: -> "Making a #{@drink}"
  a = new A('Machiato')
  """

  throwsB = """
  class B extends A
    #implied super
    constructor: (@drink) ->
  b = new B('Machiato')
  """
  throws -> CoffeeScript.compile classA + throwsB, bare: yes

test "@ params super race condition", ->
  classA = """
  class A
    constructor: (@drink) ->
    make: -> "Making a #{@drink}"
  """

  throwsB = """
  class B extends A
    constructor: (@params) ->

  b = new B('Machiato')
  """
  throws -> CoffeeScript.compile classA + throwsB, bare: yes

  # Race condition with @ and super
  throwsC = """
  class C extends A
    constructor: (@params) ->
      super(@params)

  c = new C('Machiato')
  """
  throws -> CoffeeScript.compile classA + throwsC, bare: yes


test "@ with super call", ->
  class D
    make: -> "Making a #{@drink}"

  class E extends D
    constructor: (@drink) ->
      super()

  e = new E('Machiato')
  eq e.make(),  "Making a Machiato"

test "@ with splats and super call", ->
  class A
    make: -> "Making a #{@drink}"

  class B extends A
    constructor: (@drink...) ->
      super()

  B = new B('Machiato')
  eq B.make(),  "Making a Machiato"


test "super and external constructors", ->
  # external constructor with @ param is allowed
  ctorA = (@drink) ->
  class A
    constructor: ctorA
    make: -> "Making a #{@drink}"
  a = new A('Machiato')
  eq a.make(),  "Making a Machiato"

  # External constructor with super
  throwsC = """
  class B
    constructor: (@drink) ->
    make: -> "Making a #{@drink}"

  ctorC = (drink) ->
    super(drink)

  class C extends B
    constructor: ctorC
  c = new C('Machiato')
  """
  throws -> CoffeeScript.compile throwsC, bare: yes


test "bound functions without super", ->
  # Bound function with @
  # Throw on compile, since bound
  # constructors are illegal
  throwsA = """
  class A
    constructor: (drink) =>
      @drink = drink

  """
  throws -> CoffeeScript.compile throwsA, bare: yes

test "super in a bound function in a constructor", ->
  throwsB = """
  class A
  class B extends A
    constructor: do => super
  """
  throws -> CoffeeScript.compile throwsB, bare: yes

test "super in a bound function", ->
  class A
    constructor: (@drink) ->
    make: -> "Making a #{@drink}"

  class B extends A
    make: (@flavor) =>
      super() + " with #{@flavor}"

  b = new B('Machiato')
  eq b.make('vanilla'),  "Making a Machiato with vanilla"

  # super in a bound function in a bound function
  class C extends A
    make: (@flavor) =>
      func = () =>
        super() + " with #{@flavor}"
      func()

  c = new C('Machiato')
  eq c.make('vanilla'), "Making a Machiato with vanilla"

  # bound function in a constructor
  class D extends A
    constructor: (drink) ->
      super(drink)
      x = =>
        eq @drink,  "Machiato"
      x()
  d = new D('Machiato')
  eq d.make(),  "Making a Machiato"

# duplicate
test "super in a try/catch", ->
  classA = """
  class A
    constructor: (param) ->
      throw "" unless param
  """

  throwsB = """
  class B extends A
      constructor: ->
        try
          super()
  """

  throwsC = """
  ctor = ->
    try
      super()

  class C extends A
      constructor: ctor
  """
  throws -> CoffeeScript.run classA + throwsB, bare: yes
  throws -> CoffeeScript.run classA + throwsC, bare: yes

test "mixed ES6 and CS6 classes with a four-level inheritance chain", ->
  # Extended test
  # ES2015+ class interoperability

  \`\`\`
  class Base {
    constructor (greeting) {
      this.greeting = greeting || 'hi';
    }
    func (string) {
      return 'zero/' + string;
    }
    static  staticFunc (string) {
      return 'static/' + string;
    }
  }
  \`\`\`

  class FirstChild extends Base
    func: (string) ->
      super('one/') + string


  \`\`\`
  class SecondChild extends FirstChild {
    func (string) {
      return super.func('two/' + string);
    }
  }
  \`\`\`

  thirdCtor = ->
    @array = [1, 2, 3]

  class ThirdChild extends SecondChild
    constructor: ->
      super()
      thirdCtor.call this
    func: (string) ->
      super('three/') + string

  result = (new ThirdChild).func 'four'
  ok result is 'zero/one/two/three/four'
  ok Base.staticFunc('word') is 'static/word'

# exercise extends in a nested class
test "nested classes with super", ->
  class Outer
    constructor: ->
      @label = 'outer'

    class @Inner
      constructor: ->
        @label = 'inner'

    class @ExtendedInner extends @Inner
      constructor: ->
        tmp = super()
        @label = tmp.label + ' extended'

    @extender: () =>
      class ExtendedSelf extends @
        constructor: ->
          tmp = super()
          @label = tmp.label + ' from this'
      new ExtendedSelf

  eq (new Outer).label, 'outer'
  eq (new Outer.Inner).label, 'inner'
  eq (new Outer.ExtendedInner).label, 'inner extended'
  eq (Outer.extender()).label, 'outer from this'

test "Static methods generate 'static' keywords", ->
  compile = """
  class CheckStatic
    constructor: (@drink) ->
    @className: -> 'CheckStatic'

  c = new CheckStatic('Machiato')
  """
  result = CoffeeScript.compile compile, bare: yes
  ok result.match(' static ')

test "Static methods in nested classes", ->
  class Outer
    @name: -> 'Outer'

    class @Inner
      @name: -> 'Inner'

  eq Outer.name(), 'Outer'
  eq Outer.Inner.name(), 'Inner'


test "mixed constructors with inheritance and ES6 super", ->
  identity = (f) -> f

  class TopClass
    constructor: (arg) ->
      @prop = 'top-' + arg

  \`\`\`
  class SuperClass extends TopClass {
    constructor (arg) {
      identity(super('super-' + arg));
    }
  }
  \`\`\`
  class SubClass extends SuperClass
    constructor: ->
      identity super 'sub'

  ok (new SubClass).prop is 'top-super-sub'

test "ES6 static class methods can be overriden", ->
  class A
    @name: -> 'A'

  class B extends A
    @name: -> 'B'

  eq A.name(), 'A'
  eq B.name(), 'B'

# If creating static by direct assignment rather than ES6 static keyword
test "ES6 Static methods should set \`this\` to undefined // ES6 ", ->
  class A
    @test: ->
      eq this, undefined

# Ensure that our object prototypes work with ES6
test "ES6 prototypes can be overriden", ->
  class A
    className: 'classA'

  \`\`\`
  class B {
    test () {return "B";};
  }
  \`\`\`
  b = new B
  a = new A
  eq a.className, 'classA'
  eq b.test(), 'B'
  Object.setPrototypeOf(b, a)
  eq b.className, 'classA'
  # This shouldn't throw,
  # as we only change inheritance not object construction
  # This may be an issue with ES, rather than CS construction?
  #eq b.test(), 'B'

  class D extends B
  B::test = () -> 'D'
  eq (new D).test(), 'D'

# TODO: implement this error check
# test "ES6 conformance to extending non-classes", ->
#   A = (@title) ->
#     'Title: ' + @

#   class B extends A
#   b = new B('caffeinated')
#   eq b.title, 'caffeinated'

#   # Check inheritance chain
#   A::getTitle = () -> @title
#   eq b.getTitle(), 'caffeinated'

#   throwsC = """
#   C = {title: 'invalid'}
#   class D extends {}
#   """
#   # This should catch on compile and message should be "class can only extend classes and functions."
#   throws -> CoffeeScript.run throwsC, bare: yes

# TODO: Evaluate future compliance with "strict mode";
# test "Class function environment should be in \`strict mode\`, ie as if 'use strict' was in use", ->
#   class A
#     # this might be a meaningless test, since these are likely to be runtime errors and different
#     # for every browser.  Thoughts?
#     constructor: () ->
#       # Ivalid: prop reassignment
#       @state = {prop: [1], prop: {a: 'a'}}
#       # eval reassignment
#       @badEval = eval;

#   # Should throw, but doesn't
#   a = new A

# TODO: new.target needs support  Separate issue
# test "ES6 support for new.target (functions and constructors)", ->
#   throwsA = """
#   class A
#     constructor: () ->
#       a = new.target.name
#   """
#   throws -> CoffeeScript.compile throwsA, bare: yes

test "only one method named constructor allowed", ->
  throwsA = """
  class A
    constructor: (@first) ->
    constructor: (@last) ->
  """
  throws -> CoffeeScript.compile throwsA, bare: yes

test "If the constructor of a child class does not call super,it should return an object.", ->
  nonce = {}

  class A
  class B extends A
    constructor: ->
      return nonce

  eq nonce, new B


test "super can only exist in extended classes", ->
  throwsA = """
  class A
    constructor: (@name) ->
      super()
  """
  throws -> CoffeeScript.compile throwsA, bare: yes

# --- CS1 classes compatability breaks ---
test "CS6 Class extends a CS1 compiled class", ->
  \`\`\`
  // Generated by CoffeeScript 1.11.1
  var BaseCS1, ExtendedCS1,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BaseCS1 = (function() {
    function BaseCS1(drink) {
      this.drink = drink;
    }

    BaseCS1.prototype.make = function() {
      return "making a " + this.drink;
    };

    BaseCS1.className = function() {
      return 'BaseCS1';
    };

    return BaseCS1;

  })();

  ExtendedCS1 = (function(superClass) {
    extend(ExtendedCS1, superClass);

    function ExtendedCS1(flavor) {
      this.flavor = flavor;
      ExtendedCS1.__super__.constructor.call(this, 'cafe ole');
    }

    ExtendedCS1.prototype.make = function() {
      return "making a " + this.drink + " with " + this.flavor;
    };

    ExtendedCS1.className = function() {
      return 'ExtendedCS1';
    };

    return ExtendedCS1;

  })(BaseCS1);

  \`\`\`
  class B extends BaseCS1
  eq B.className(), 'BaseCS1'
  b = new B('machiato')
  eq b.make(), "making a machiato"


test "CS6 Class extends an extended CS1 compiled class", ->
  \`\`\`
  // Generated by CoffeeScript 1.11.1
  var BaseCS1, ExtendedCS1,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BaseCS1 = (function() {
    function BaseCS1(drink) {
      this.drink = drink;
    }

    BaseCS1.prototype.make = function() {
      return "making a " + this.drink;
    };

    BaseCS1.className = function() {
      return 'BaseCS1';
    };

    return BaseCS1;

  })();

  ExtendedCS1 = (function(superClass) {
    extend(ExtendedCS1, superClass);

    function ExtendedCS1(flavor) {
      this.flavor = flavor;
      ExtendedCS1.__super__.constructor.call(this, 'cafe ole');
    }

    ExtendedCS1.prototype.make = function() {
      return "making a " + this.drink + " with " + this.flavor;
    };

    ExtendedCS1.className = function() {
      return 'ExtendedCS1';
    };

    return ExtendedCS1;

  })(BaseCS1);

  \`\`\`
  class B extends ExtendedCS1
  eq B.className(), 'ExtendedCS1'
  b = new B('vanilla')
  eq b.make(), "making a cafe ole with vanilla"

test "CS6 Class extends a CS1 compiled class with super()", ->
  \`\`\`
  // Generated by CoffeeScript 1.11.1
  var BaseCS1, ExtendedCS1,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BaseCS1 = (function() {
    function BaseCS1(drink) {
      this.drink = drink;
    }

    BaseCS1.prototype.make = function() {
      return "making a " + this.drink;
    };

    BaseCS1.className = function() {
      return 'BaseCS1';
    };

    return BaseCS1;

  })();

  ExtendedCS1 = (function(superClass) {
    extend(ExtendedCS1, superClass);

    function ExtendedCS1(flavor) {
      this.flavor = flavor;
      ExtendedCS1.__super__.constructor.call(this, 'cafe ole');
    }

    ExtendedCS1.prototype.make = function() {
      return "making a " + this.drink + " with " + this.flavor;
    };

    ExtendedCS1.className = function() {
      return 'ExtendedCS1';
    };

    return ExtendedCS1;

  })(BaseCS1);

  \`\`\`
  class B extends ExtendedCS1
    constructor: (@shots) ->
      super('caramel')
    make: () ->
      super() + " and #{@shots} shots of espresso"

  eq B.className(), 'ExtendedCS1'
  b = new B('three')
  eq b.make(), "making a cafe ole with caramel and three shots of espresso"

test 'Bound method called normally before binding is ok', ->
  class Base
    constructor: ->
      @setProp()
      eq @derivedBound(), 3

  class Derived extends Base
    setProp: ->
      @prop = 3

    derivedBound: =>
      @prop

  d = new Derived

test 'Bound method called as callback after super() is ok', ->
  class Base

  class Derived extends Base
    constructor: (@prop = 3) ->
      super()
      f = @derivedBound
      eq f(), 3

    derivedBound: =>
      @prop

  d = new Derived
  {derivedBound} = d
  eq derivedBound(), 3

test 'Bound method of base class called as callback is ok', ->
  class Base
    constructor: (@prop = 3) ->
      f = @baseBound
      eq f(), 3

    baseBound: =>
      @prop

  b = new Base
  {baseBound} = b
  eq baseBound(), 3

test 'Bound method of prop-named class called as callback is ok', ->
  Hive = {}
  class Hive.Bee
    constructor: (@prop = 3) ->
      f = @baseBound
      eq f(), 3

    baseBound: =>
      @prop

  b = new Hive.Bee
  {baseBound} = b
  eq baseBound(), 3

test 'Bound method of class with expression base class called as callback is ok', ->
  calledB = no
  B = ->
    throw new Error if calledB
    calledB = yes
    class
  class A extends B()
    constructor: (@prop = 3) ->
      super()
      f = @derivedBound
      eq f(), 3

    derivedBound: =>
      @prop

  b = new A
  {derivedBound} = b
  eq derivedBound(), 3

test 'Bound method of class with expression class name called as callback is ok', ->
  calledF = no
  obj = {}
  B = class
  f = ->
    throw new Error if calledF
    calledF = yes
    obj
  class f().A extends B
    constructor: (@prop = 3) ->
      super()
      g = @derivedBound
      eq g(), 3

    derivedBound: =>
      @prop

  a = new obj.A
  {derivedBound} = a
  eq derivedBound(), 3

test 'Bound method of anonymous child class called as callback is ok', ->
  f = ->
    B = class
    class extends B
      constructor: (@prop = 3) ->
        super()
        g = @derivedBound
        eq g(), 3

      derivedBound: =>
        @prop

  a = new (f())
  {derivedBound} = a
  eq derivedBound(), 3

test 'Bound method of immediately instantiated class with expression base class called as callback is ok', ->
  calledF = no
  obj = {}
  B = class
  f = ->
    throw new Error if calledF
    calledF = yes
    obj
  a = new class f().A extends B
    constructor: (@prop = 3) ->
      super()
      g = @derivedBound
      eq g(), 3

    derivedBound: =>
      @prop

  {derivedBound} = a
  eq derivedBound(), 3

test "#4591: super.x.y, super['x'].y", ->
  class A
    x:
      y: 1
      z: -> 2

  class B extends A
    constructor: ->
      super()

      @w = super.x.y
      @v = super['x'].y
      @u = super.x['y']
      @t = super.x.z()
      @s = super['x'].z()
      @r = super.x['z']()

  b = new B
  eq 1, b.w
  eq 1, b.v
  eq 1, b.u
  eq 2, b.t
  eq 2, b.s
  eq 2, b.r

test "#4464: backticked expressions in class body", ->
  class A
    \`get x() { return 42; }\`

  class B
    \`get x() { return 42; }\`
    constructor: ->
      @y = 84

  a = new A
  eq 42, a.x
  b = new B
  eq 42, b.x
  eq 84, b.y

test "#4724: backticked expression in a class body with hoisted member", ->
  class A
    \`get x() { return 42; }\`
    hoisted: 84

  a = new A
  eq 42, a.x
  eq 84, a.hoisted

test "#4822: nested anonymous classes use non-conflicting variable names", ->
  Class = class
    @a: class
      @b: 1

  eq Class.a.b, 1

test "#4827: executable class body wrappers have correct context", ->
  test = ->
    class @A
    class @B extends @A
      @property = 1

  o = {}
  test.call o
  ok typeof o.A is typeof o.B is 'function'

test "#4868: Incorrect ‘Can’t call super with @params’ error", ->
  class A
    constructor: (@func = ->) ->
      @x = 1
      @func()

  class B extends A
    constructor: ->
      super -> @x = 2

  a = new A
  b = new B
  eq 1, a.x
  eq 2, b.x

  class C
    constructor: (@c = class) -> @c

  class D extends C
    constructor: ->
      super class then constructor: (@a) -> @a = 3

  d = new (new D).c
  eq 3, d.a~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Classes
# -------

# * Class Definition
# * Class Instantiation
# * Inheritance and Super
# * ES2015+ Class Interoperability

test 'classes with a four-level inheritance chain', ->
  class Base
    func: (string) ->
      "zero/#{string}"

    @static: (string) ->
      "static/#{string}"

  class FirstChild extends Base
    func: (string) ->
      super('one/') + string

  SecondChild = class extends FirstChild
    func: (string) ->
      super('two/') + string

  thirdCtor = ->
    @array = [1, 2, 3]

  class ThirdChild extends SecondChild
    constructor: ->
      super()
      thirdCtor.call this

    # Gratuitous comment for testing.
    func: (string) ->
      super('three/') + string

  result = new ThirdChild().func 'four'

  ok result is 'zero/one/two/three/four'
  ok Base.static('word') is 'static/word'

  ok new ThirdChild().array.join(' ') is '1 2 3'

test 'constructors with inheritance and super', ->
  identity = (f) -> f

  class TopClass
    constructor: (arg) ->
      @prop = 'top-' + arg

  class SuperClass extends TopClass
    constructor: (arg) ->
      identity super 'super-' + arg

  class SubClass extends SuperClass
    constructor: ->
      identity super 'sub'

  ok new SubClass().prop is 'top-super-sub'

test "'super' with accessors", ->
  class Base
    m: -> 4
    n: -> 5
    o: -> 6

  name = 'o'
  class A extends Base
    m: -> super()
    n: -> super.n()
    "#{name}": -> super()
    p: -> super[name]()

  a = new A()
  eq 4, a.m()
  eq 5, a.n()
  eq 6, a.o()
  eq 6, a.p()

test "soaked 'super' invocation", ->
  class Base
    method: -> 2

  class A extends Base
    method: -> super?()
    noMethod: -> super?()

  a = new A()
  eq 2, a.method()
  eq undefined, a.noMethod()

  name = 'noMethod'
  class B extends Base
    "#{'method'}": -> super?()
    "#{'noMethod'}": -> super?() ? super['method']()

  b = new B()
  eq 2, b.method()
  eq 2, b.noMethod()

test "'@' referring to the current instance, and not being coerced into a call", ->
  class ClassName
    amI: ->
      @ instanceof ClassName

  obj = new ClassName()
  ok obj.amI()

test 'super() calls in constructors of classes that are defined as object properties', ->
  class Hive
    constructor: (name) -> @name = name

  class Hive.Bee extends Hive
    constructor: (name) -> super name

  maya = new Hive.Bee 'Maya'
  ok maya.name is 'Maya'

test 'classes with JS-keyword properties', ->
  class Class
    class: 'class'
    name: -> @class

  instance = new Class()
  ok instance.class is 'class'
  ok instance.name() is 'class'

test 'Classes with methods that are pre-bound to the instance, or statically, to the class', ->
  class Dog
    constructor: (name) ->
      @name = name

    bark: =>
      "#{@name} woofs!"

    @static = =>
      new this 'Dog'

  spark = new Dog 'Spark'
  fido = new Dog 'Fido'
  fido.bark = spark.bark

  ok fido.bark() is 'Spark woofs!'

  obj = func: Dog.static

  ok obj.func().name is 'Dog'

test 'a bound function in a bound function', ->
  class Mini
    num: 10
    generate: =>
      for i in [1..3]
        =>
          @num

  m = new Mini()
  eq (func() for func in m.generate()).join(' '), '10 10 10'

test 'contructor called with varargs', ->
  class Connection
    constructor: (one, two, three) ->
      [@one, @two, @three] = [one, two, three]

    out: ->
      "#{@one}-#{@two}-#{@three}"

  list = [3, 2, 1]
  conn = new Connection list...
  ok conn instanceof Connection
  ok conn.out() is '3-2-1'

test 'calling super and passing along all arguments', ->
  class Parent
    method: (args...) -> @args = args

  class Child extends Parent
    method: -> super arguments...

  c = new Child()
  c.method 1, 2, 3, 4
  ok c.args.join(' ') is '1 2 3 4'

test 'classes wrapped in decorators', ->
  func = (klass) ->
    klass::prop = 'value'
    klass

  func(
    class Test
      prop2: 'value2'
  )

  ok new Test().prop is 'value'
  ok new Test().prop2 is 'value2'

test 'anonymous classes', ->
  obj =
    klass: class
      method: -> 'value'

  instance = new obj.klass()
  ok instance.method() is 'value'

test 'Implicit objects as static properties', ->
  class Static
    @static =
      one: 1
      two: 2

  ok Static.static.one is 1
  ok Static.static.two is 2

test 'nothing classes', ->
  c = class
  ok c instanceof Function

test 'classes with static-level implicit objects', ->
  class A
    @static = one: 1
    two: 2

  class B
    @static =
      one: 1
      two: 2

  eq A.static.one, 1
  eq A.static.two, undefined
  eq new A().two, 2

  eq B.static.one, 1
  eq B.static.two, 2
  eq new B().two, undefined

test "classes with value'd constructors", ->
  counter = 0
  classMaker = ->
    inner = ++counter
    ->
      @value = inner
      @

  class One
    constructor: classMaker()

  class Two
    constructor: classMaker()

  eq new One().value, 1
  eq new Two().value, 2
  eq new One().value, 1
  eq new Two().value, 2

test 'executable class bodies', ->
  class A
    if true
      b: 'b'
    else
      c: 'c'

  a = new A()

  eq a.b, 'b'
  eq a.c, undefined

test '#2502: parenthesizing inner object values', ->
  class A
    category: type: 'string'
    sections: type: 'number', default: 0

  eq new A().category.type, 'string'

  eq new A().sections.default, 0

test 'conditional prototype property assignment', ->
  debug = false

  class Person
    if debug
      age: -> 10
    else
      age: -> 20

  eq new Person().age(), 20

test 'mild metaprogramming', ->
  class Base
    @attr: (name) ->
      @::[name] = (val) ->
        if arguments.length > 0
          @["_#{name}"] = val
        else
          @["_#{name}"]

  class Robot extends Base
    @attr 'power'
    @attr 'speed'

  robby = new Robot()

  ok robby.power() is undefined

  robby.power 11
  robby.speed Infinity

  eq robby.power(), 11
  eq robby.speed(), Infinity

test 'namespaced classes do not reserve their function name in outside scope', ->
  one = {}
  two = {}

  class one.Klass
    @label = 'one'

  class two.Klass
    @label = 'two'

  eq typeof Klass, 'undefined'
  eq one.Klass.label, 'one'
  eq two.Klass.label, 'two'

test 'nested classes', ->
  class Outer
    constructor: ->
      @label = 'outer'

    class @Inner
      constructor: ->
        @label = 'inner'

  eq new Outer().label, 'outer'
  eq new Outer.Inner().label, 'inner'

test 'variables in constructor bodies are correctly scoped', ->
  class A
    x = 1
    constructor: ->
      x = 10
      y = 20
    y = 2
    captured: ->
      { x, y }

  a = new A()
  eq a.captured().x, 10
  eq a.captured().y, 2

test 'Issue #924: Static methods in nested classes', ->
  class A
    @B: class
      @c = -> 5

  eq A.B.c(), 5

test '\`class extends this\`', ->
  class A
    func: -> 'A'

  B = null
  makeClass = ->
    B = class extends this
      func: -> super() + ' B'

  makeClass.call A

  eq new B().func(), 'A B'

test 'ensure that constructors invoked with splats return a new object', ->
  args = [1, 2, 3]
  Type = (@args) ->
  type = new Type args

  ok type and type instanceof Type
  ok type.args and type.args instanceof Array
  ok v is args[i] for v, i in type.args

  Type1 = (@a, @b, @c) ->
  type1 = new Type1 args...

  ok type1 instanceof Type1
  eq type1.constructor, Type1
  ok type1.a is args[0] and type1.b is args[1] and type1.c is args[2]

  # Ensure that constructors invoked with splats cache the function.
  called = 0
  get = -> if called++ then false else class Type
  new (get()) args...

test "\`new\` shouldn't add extra parens", ->
  ok new Date().constructor is Date

test '\`new\` works against bare function', ->
  eq(
    Date
    new (->
      Date
    )()
  )

test '#1182: a subclass should be able to set its constructor to an external function', ->
  ctor = ->
    @val = 1
    return
  class A
  class B extends A
    constructor: ctor
  eq new B().val, 1

test '#1182: external constructors continued', ->
  ctor = ->
  class A
  class B extends A
    method: ->
    constructor: ctor
  ok B::method

test '#1313: misplaced __extends', ->
  nonce = {}
  class A
  class B extends A
    prop: nonce
    constructor: -> super()
  eq nonce, B::prop

test '#1182: execution order needs to be considered as well', ->
  counter = 0
  makeFn = (n) ->
    eq n, ++counter
    ->
  class B extends makeFn(1)
    @B: makeFn 2
    constructor: makeFn 3

test '#1182: external constructors with bound functions', ->
  fn = ->
    one: 1
    this
  class B
  class A
    constructor: fn
    method: => this instanceof A
  ok new A().method.call new B()

test '#1372: bound class methods with reserved names', ->
  class C
    delete: =>
  ok C::delete

test '#1380: \`super\` with reserved names', ->
  class C
    do: -> super()
  ok C::do

  class B
    0: -> super()
  ok B::[0]

test '#1464: bound class methods should keep context', ->
  nonce = {}
  nonce2 = {}
  class C
    constructor: (@id) ->
    @boundStaticColon: => new this nonce
    @boundStaticEqual = => new this nonce2
  eq nonce, C.boundStaticColon().id
  eq nonce2, C.boundStaticEqual().id

test '#1009: classes with reserved words as determined names', ->
  (->
    eq 'function', typeof (class @for)
    ok not /\\beval\\b/.test (class @eval).toString()
    ok not /\\barguments\\b/.test (class @arguments).toString()
  ).call {}

test '#1482: classes can extend expressions', ->
  id = (x) -> x
  nonce = {}
  class A
    nonce: nonce
  class B extends id(A)
  eq nonce, new B().nonce

test '#1598: super works for static methods too', ->
  class Parent
    method: ->
      'NO'
    @method: ->
      'yes'

  class Child extends Parent
    @method: ->
      'pass? ' + super()

  eq Child.method(), 'pass? yes'

test '#1842: Regression with bound functions within bound class methods', ->
  class Store
    @bound: =>
      do =>
        eq this, Store

  Store.bound()

  # And a fancier case:

  class Store
    eq this, Store

    @bound: =>
      do =>
        eq this, Store

    @unbound: ->
      eq this, Store

    instance: =>
      ok this instanceof Store

  Store.bound()
  Store.unbound()
  new Store().instance()

test '#1876: Class @A extends A', ->
  class A
  class @A extends A

  ok new @A() instanceof A

test '#1813: Passing class definitions as expressions', ->
  ident = (x) -> x

  result = ident(
    class A
      x = 1
  )

  eq result, A

  result = ident(
    class B extends A
      x = 1
  )

  eq result, B

test '#1966: external constructors should produce their return value', ->
  ctor = -> {}
  class A
    constructor: ctor
  ok new A() not instanceof A

test '#1980: regression with an inherited class with static function members', ->
  class A

  class B extends A
    @static: => 'value'

  eq B.static(), 'value'

test "#1534: class then 'use strict'", ->
  # [14.1 Directive Prologues and the Use Strict Directive](http://es5.github.com/#x14.1)
  nonce = {}
  error = 'do -> ok this'
  strictTest = "do ->'use strict';#{error}"
  return unless (
    (try CoffeeScript.run strictTest, bare: yes catch e then nonce) is nonce
  )

  throws -> CoffeeScript.run "class then 'use strict';#{error}", bare: yes
  doesNotThrow -> CoffeeScript.run "class then #{error}", bare: yes
  doesNotThrow -> CoffeeScript.run "class then #{error};'use strict'", bare: yes

  # comments are ignored in the Directive Prologue
  comments = [
    """
  class
    ### comment ###
    'use strict'
    #{error}"""
    """
  class
    ### comment 1 ###
    ### comment 2 ###
    'use strict'
    #{error}"""
    """
  class
    ### comment 1 ###
    ### comment 2 ###
    'use strict'
    #{error}
    ### comment 3 ###"""
  ]
  (throws -> CoffeeScript.run comment, bare: yes) for comment in comments

  # [ES5 §14.1](http://es5.github.com/#x14.1) allows for other directives
  directives = [
    """
  class
    'directive 1'
    'use strict'
    #{error}"""
    """
  class
    'use strict'
    'directive 2'
    #{error}"""
    """
  class
    ### comment 1 ###
    'directive 1'
    'use strict'
    #{error}"""
    """
  class
    ### comment 1 ###
    'directive 1'
    ### comment 2 ###
    'use strict'
    #{error}"""
  ]
  (throws -> CoffeeScript.run directive, bare: yes) for directive in directives

test '#2052: classes should work in strict mode', ->
  try
    do ->
      'use strict'
      class A
  catch e
    ok no

test 'directives in class with extends ', ->
  strictTest = '''
    class extends Object
      ### comment ###
      'use strict'
      do -> eq this, undefined
  '''
  CoffeeScript.run strictTest, bare: yes

test "#2630: class bodies can't reference arguments", ->
  throws ->
    CoffeeScript.compile 'class Test then arguments'

  # #4320: Don't be too eager when checking, though.
  class Test
    arguments: 5
  eq 5, Test::arguments

test '#2319: fn class n extends o.p [INDENT] x = 123', ->
  first = ->

  base = onebase: ->

  first(
    class OneKeeper extends base.onebase
      one = 1
      one: -> one
  )

  eq new OneKeeper().one(), 1

test '#2599: other typed constructors should be inherited', ->
  class Base
    constructor: -> return {}

  class Derived extends Base

  ok new Derived() not instanceof Derived
  ok new Derived() not instanceof Base
  ok new Base() not instanceof Base

test 'extending native objects works with and without defining a constructor', ->
  class MyArray extends Array
    method: -> 'yes!'

  myArray = new MyArray()
  ok myArray instanceof MyArray
  ok 'yes!', myArray.method()

  class OverrideArray extends Array
    constructor: -> super()
    method: -> 'yes!'

  overrideArray = new OverrideArray()
  ok overrideArray instanceof OverrideArray
  eq 'yes!', overrideArray.method()

test '#2782: non-alphanumeric-named bound functions', ->
  class A
    'b:c': =>
      'd'

  eq new A()['b:c'](), 'd'

test '#2781: overriding bound functions', ->
  class A
    a: ->
      @b()
    b: =>
      1

  class B extends A
    b: =>
      2

  b = new A().b
  eq b(), 1

  b = new B().b
  eq b(), 2

test '#2791: bound function with destructured argument', ->
  class Foo
    method: ({ a }) => 'Bar'

  eq new Foo().method(a: 'Bar'), 'Bar'

test '#2796: ditto, ditto, ditto', ->
  answer = null

  outsideMethod = (func) ->
    func.call message: 'wrong!'

  class Base
    constructor: ->
      @message = 'right!'
      outsideMethod @echo

    echo: =>
      answer = @message

  new Base()
  eq answer, 'right!'

test '#3063: Class bodies cannot contain pure statements', ->
  throws ->
    CoffeeScript.compile '''
    class extends S
      return if S.f
      @f: => this
  '''

test '#2949: super in static method with reserved name', ->
  class Foo
    @static: -> 'baz'

  class Bar extends Foo
    @static: -> super()

  eq Bar.static(), 'baz'

test '#3232: super in static methods (not object-assigned)', ->
  class Foo
    @baz = -> true
    @qux = -> true

  class Bar extends Foo
    @baz = -> super()
    Bar.qux = -> super()

  ok Bar.baz()
  ok Bar.qux()

test '#1392 calling \`super\` in methods defined on namespaced classes', ->
  class Base
    m: -> 5
    n: -> 4
  namespace =
    A: ->
    B: ->
  class namespace.A extends Base
    m: -> super()

  eq 5, new namespace.A().m()
  namespace.B::m = namespace.A::m
  namespace.A::m = null
  eq 5, new namespace.B().m()

  class C
    @a: class extends Base
      m: -> super()
  eq 5, new C.a().m()

test '#4436 immediately instantiated named class', ->
  ok new (class Foo)()

test 'dynamic method names', ->
  class A
    "#{(name = 'm')}": -> 1
  eq 1, new A().m()

  class B extends A
    "#{(name = 'm')}": -> super()
  eq 1, new B().m()

  getName = -> 'm'
  class C
    "#{(name = getName())}": -> 1
  eq 1, new C().m()

test 'dynamic method names and super', ->
  class Base
    @m: -> 6
    m: -> 5
    m2: -> 4.5
    n: -> 4

  name = ->
    count++
    'n'
  count = 0

  m = 'm'
  class A extends Base
    "#{m}": -> super()
    "#{name()}": -> super()

  m = 'n'
  eq 5, new A().m()

  eq 4, new A().n()
  eq 1, count

  m = 'm'
  m2 = 'm2'
  count = 0
  class B extends Base
    @[name()] = -> super()
    "#{m}": -> super()
    "#{m2}": -> super()
  b = new B()
  m = m2 = 'n'
  eq 6, B.m()
  eq 5, b.m()
  eq 4.5, b.m2()
  eq 1, count

  class C extends B
    m: -> super()
  eq 5, new C().m()

# ES2015+ class interoperability
# Based on https://github.com/balupton/es6-javascript-class-interop
# Helper functions to generate true ES classes to extend:
getBasicClass = ->
  \`\`\`
  class BasicClass {
    constructor (greeting) {
      this.greeting = greeting || 'hi'
    }
  }
  \`\`\`
  BasicClass

getExtendedClass = (BaseClass) ->
  \`\`\`
  class ExtendedClass extends BaseClass {
    constructor (greeting, name) {
      super(greeting || 'hello')
      this.name = name
    }
  }
  \`\`\`
  ExtendedClass

test 'can instantiate a basic ES class', ->
  BasicClass = getBasicClass()
  i = new BasicClass 'howdy!'
  eq i.greeting, 'howdy!'

test 'can instantiate an extended ES class', ->
  BasicClass = getBasicClass()
  ExtendedClass = getExtendedClass BasicClass
  i = new ExtendedClass 'yo', 'buddy'
  eq i.greeting, 'yo'
  eq i.name, 'buddy'

test 'can extend a basic ES class', ->
  BasicClass = getBasicClass()
  class ExtendedClass extends BasicClass
    constructor: (@name) ->
      super()
  i = new ExtendedClass 'dude'
  eq i.name, 'dude'

test 'can extend an extended ES class', ->
  BasicClass = getBasicClass()
  ExtendedClass = getExtendedClass BasicClass

  class ExtendedExtendedClass extends ExtendedClass
    constructor: (@value) ->
      super()
    getDoubledValue: ->
      @value * 2

  i = new ExtendedExtendedClass 7
  eq i.getDoubledValue(), 14

test 'CoffeeScript class can be extended in ES', ->
  class CoffeeClass
    constructor: (@favoriteDrink = 'latte', @size = 'grande') ->
    getDrinkOrder: ->
      "#{@size} #{@favoriteDrink}"

  \`\`\`
  class ECMAScriptClass extends CoffeeClass {
    constructor (favoriteDrink) {
      super(favoriteDrink);
      this.favoriteDrink = this.favoriteDrink + ' with a dash of semicolons';
    }
  }
  \`\`\`

  e = new ECMAScriptClass 'coffee'
  eq e.getDrinkOrder(), 'grande coffee with a dash of semicolons'

test 'extended CoffeeScript class can be extended in ES', ->
  class CoffeeClass
    constructor: (@favoriteDrink = 'latte') ->

  class CoffeeClassWithDrinkOrder extends CoffeeClass
    constructor: (@favoriteDrink, @size = 'grande') ->
      super()
    getDrinkOrder: ->
      "#{@size} #{@favoriteDrink}"

  \`\`\`
  class ECMAScriptClass extends CoffeeClassWithDrinkOrder {
    constructor (favoriteDrink) {
      super(favoriteDrink);
      this.favoriteDrink = this.favoriteDrink + ' with a dash of semicolons';
    }
  }
  \`\`\`

  e = new ECMAScriptClass 'coffee'
  eq e.getDrinkOrder(), 'grande coffee with a dash of semicolons'

test '\`this\` access after \`super\` in extended classes', ->
  class Base

  class Test extends Base
    constructor: (param, @param) ->
      eq param, nonce

      result = { super: super(), @param, @method }
      eq result.super, this
      eq result.param, @param
      eq result.method, @method
      ok result.method isnt Test::method

    method: =>

  nonce = {}
  new Test nonce, {}

test '\`@\`-params and bound methods with multiple \`super\` paths (blocks)', ->
  nonce = {}

  class Base
    constructor: (@name) ->

  class Test extends Base
    constructor: (param, @param) ->
      if param
        super 'param'
        eq @name, 'param'
      else
        super 'not param'
        eq @name, 'not param'
      eq @param, nonce
      ok @method isnt Test::method
    method: =>
  new Test true, nonce
  new Test false, nonce

test '\`@\`-params and bound methods with multiple \`super\` paths (expressions)', ->
  nonce = {}

  class Base
    constructor: (@name) ->

  class Test extends Base
    constructor: (param, @param) ->
      # Contrived example: force each path into an expression with inline assertions
      if param
        result = (
          eq super('param'), @;
          eq @name, 'param';
          eq @param, nonce;
          ok @method isnt Test::method
        )
      else
        result = (
          eq super('not param'), @;
          eq @name, 'not param';
          eq @param, nonce;
          ok @method isnt Test::method
        )
    method: =>
  new Test true, nonce
  new Test false, nonce

test 'constructor super in arrow functions', ->
  class Test extends (class)
    constructor: (@param) ->
      do => super()
      eq @param, nonce

  new Test(nonce = {})

# TODO Some of these tests use CoffeeScript.compile and CoffeeScript.run when they could use
# regular test mechanics.
# TODO Some of these tests might be better placed in \`test/error_messages.coffee\`.
# TODO Some of these tests are duplicates.

# Ensure that we always throw if we experience more than one super()
# call in a constructor.  This ends up being a runtime error.
# Should be caught at compile time.
test 'multiple super calls', ->
  throwsA = """
  class A
    constructor: (@drink) ->
    make: -> "Making a #{@drink}"

  class MultiSuper extends A
    constructor: (drink) ->
      super(drink)
      super(drink)
      @newDrink = drink
  new MultiSuper('Late').make()
  """
  throws -> CoffeeScript.run throwsA, bare: yes

# Basic test to ensure we can pass @params in a constuctor and
# inheritance works correctly
test '@ params', ->
  class A
    constructor: (@drink, @shots, @flavor) ->
    make: -> "Making a #{@flavor} #{@drink} with #{@shots} shot(s)"

  a = new A 'Machiato', 2, 'chocolate'
  eq a.make(), 'Making a chocolate Machiato with 2 shot(s)'

  class B extends A
  b = new B 'Machiato', 2, 'chocolate'
  eq b.make(), 'Making a chocolate Machiato with 2 shot(s)'

# Ensure we can accept @params with default parameters in a constructor
test '@ params with defaults in a constructor', ->
  class A
    # Multiple @ params with defaults
    constructor: (@drink = 'Americano', @shots = '1', @flavor = 'caramel') ->
    make: -> "Making a #{@flavor} #{@drink} with #{@shots} shot(s)"

  a = new A()
  eq a.make(), 'Making a caramel Americano with 1 shot(s)'

# Ensure we can handle default constructors with class params
test '@ params with class params', ->
  class Beverage
    drink: 'Americano'
    shots: '1'
    flavor: 'caramel'

  class A
    # Class creation as a default param with \`this\`
    constructor: (@drink = new Beverage()) ->
  a = new A()
  eq a.drink.drink, 'Americano'

  beverage = new Beverage()
  class B
    # class costruction with a default external param
    constructor: (@drink = beverage) ->

  b = new B()
  eq b.drink.drink, 'Americano'

  class C
    # Default constructor with anonymous empty class
    constructor: (@meta = class) ->
  c = new C()
  ok c.meta instanceof Function

test '@ params without super, including errors', ->
  classA = """
  class A
    constructor: (@drink) ->
    make: -> "Making a #{@drink}"
  a = new A('Machiato')
  """

  throwsB = '''
  class B extends A
    #implied super
    constructor: (@drink) ->
  b = new B('Machiato')
  '''
  throws -> CoffeeScript.compile classA + throwsB, bare: yes

test '@ params super race condition', ->
  classA = """
  class A
    constructor: (@drink) ->
    make: -> "Making a #{@drink}"
  """

  throwsB = '''
  class B extends A
    constructor: (@params) ->

  b = new B('Machiato')
  '''
  throws -> CoffeeScript.compile classA + throwsB, bare: yes

  # Race condition with @ and super
  throwsC = '''
  class C extends A
    constructor: (@params) ->
      super(@params)

  c = new C('Machiato')
  '''
  throws -> CoffeeScript.compile classA + throwsC, bare: yes

test '@ with super call', ->
  class D
    make: -> "Making a #{@drink}"

  class E extends D
    constructor: (@drink) ->
      super()

  e = new E 'Machiato'
  eq e.make(), 'Making a Machiato'

test '@ with splats and super call', ->
  class A
    make: -> "Making a #{@drink}"

  class B extends A
    constructor: (@drink...) ->
      super()

  B = new B 'Machiato'
  eq B.make(), 'Making a Machiato'

test 'super and external constructors', ->
  # external constructor with @ param is allowed
  ctorA = (@drink) ->
  class A
    constructor: ctorA
    make: -> "Making a #{@drink}"
  a = new A 'Machiato'
  eq a.make(), 'Making a Machiato'

  # External constructor with super
  throwsC = """
  class B
    constructor: (@drink) ->
    make: -> "Making a #{@drink}"

  ctorC = (drink) ->
    super(drink)

  class C extends B
    constructor: ctorC
  c = new C('Machiato')
  """
  throws -> CoffeeScript.compile throwsC, bare: yes

test 'bound functions without super', ->
  # Bound function with @
  # Throw on compile, since bound
  # constructors are illegal
  throwsA = '''
  class A
    constructor: (drink) =>
      @drink = drink

  '''
  throws -> CoffeeScript.compile throwsA, bare: yes

test 'super in a bound function in a constructor', ->
  throwsB = '''
  class A
  class B extends A
    constructor: do => super
  '''
  throws -> CoffeeScript.compile throwsB, bare: yes

test 'super in a bound function', ->
  class A
    constructor: (@drink) ->
    make: -> "Making a #{@drink}"

  class B extends A
    make: (@flavor) =>
      super() + " with #{@flavor}"

  b = new B 'Machiato'
  eq b.make('vanilla'), 'Making a Machiato with vanilla'

  # super in a bound function in a bound function
  class C extends A
    make: (@flavor) =>
      func = =>
        super() + " with #{@flavor}"
      func()

  c = new C 'Machiato'
  eq c.make('vanilla'), 'Making a Machiato with vanilla'

  # bound function in a constructor
  class D extends A
    constructor: (drink) ->
      super drink
      x = =>
        eq @drink, 'Machiato'
      x()
  d = new D 'Machiato'
  eq d.make(), 'Making a Machiato'

# duplicate
test 'super in a try/catch', ->
  classA = '''
  class A
    constructor: (param) ->
      throw "" unless param
  '''

  throwsB = '''
  class B extends A
      constructor: ->
        try
          super()
  '''

  throwsC = '''
  ctor = ->
    try
      super()

  class C extends A
      constructor: ctor
  '''
  throws -> CoffeeScript.run classA + throwsB, bare: yes
  throws -> CoffeeScript.run classA + throwsC, bare: yes

test 'mixed ES6 and CS6 classes with a four-level inheritance chain', ->
  # Extended test
  # ES2015+ class interoperability

  \`\`\`
  class Base {
    constructor (greeting) {
      this.greeting = greeting || 'hi';
    }
    func (string) {
      return 'zero/' + string;
    }
    static  staticFunc (string) {
      return 'static/' + string;
    }
  }
  \`\`\`

  class FirstChild extends Base
    func: (string) ->
      super('one/') + string

  \`\`\`
  class SecondChild extends FirstChild {
    func (string) {
      return super.func('two/' + string);
    }
  }
  \`\`\`

  thirdCtor = ->
    @array = [1, 2, 3]

  class ThirdChild extends SecondChild
    constructor: ->
      super()
      thirdCtor.call this
    func: (string) ->
      super('three/') + string

  result = new ThirdChild().func 'four'
  ok result is 'zero/one/two/three/four'
  ok Base.staticFunc('word') is 'static/word'

# exercise extends in a nested class
test 'nested classes with super', ->
  class Outer
    constructor: ->
      @label = 'outer'

    class @Inner
      constructor: ->
        @label = 'inner'

    class @ExtendedInner extends @Inner
      constructor: ->
        tmp = super()
        @label = tmp.label + ' extended'

    @extender: =>
      class ExtendedSelf extends @
        constructor: ->
          tmp = super()
          @label = tmp.label + ' from this'
      new ExtendedSelf()

  eq new Outer().label, 'outer'
  eq new Outer.Inner().label, 'inner'
  eq new Outer.ExtendedInner().label, 'inner extended'
  eq Outer.extender().label, 'outer from this'

test "Static methods generate 'static' keywords", ->
  compile = '''
  class CheckStatic
    constructor: (@drink) ->
    @className: -> 'CheckStatic'

  c = new CheckStatic('Machiato')
  '''
  result = CoffeeScript.compile compile, bare: yes
  ok result.match ' static '

test 'Static methods in nested classes', ->
  class Outer
    @name: -> 'Outer'

    class @Inner
      @name: -> 'Inner'

  eq Outer.name(), 'Outer'
  eq Outer.Inner.name(), 'Inner'

test 'mixed constructors with inheritance and ES6 super', ->
  identity = (f) -> f

  class TopClass
    constructor: (arg) ->
      @prop = 'top-' + arg

  \`\`\`
  class SuperClass extends TopClass {
    constructor (arg) {
      identity(super('super-' + arg));
    }
  }
  \`\`\`
  class SubClass extends SuperClass
    constructor: ->
      identity super 'sub'

  ok new SubClass().prop is 'top-super-sub'

test 'ES6 static class methods can be overriden', ->
  class A
    @name: -> 'A'

  class B extends A
    @name: -> 'B'

  eq A.name(), 'A'
  eq B.name(), 'B'

# If creating static by direct assignment rather than ES6 static keyword
test 'ES6 Static methods should set \`this\` to undefined // ES6 ', ->
  class A
    @test: ->
      eq this, undefined

# Ensure that our object prototypes work with ES6
test 'ES6 prototypes can be overriden', ->
  class A
    className: 'classA'

  \`\`\`
  class B {
    test () {return "B";};
  }
  \`\`\`
  b = new B()
  a = new A()
  eq a.className, 'classA'
  eq b.test(), 'B'
  Object.setPrototypeOf b, a
  eq b.className, 'classA'
  # This shouldn't throw,
  # as we only change inheritance not object construction
  # This may be an issue with ES, rather than CS construction?
  #eq b.test(), 'B'

  class D extends B
  B::test = -> 'D'
  eq new D().test(), 'D'

# TODO: implement this error check
# test "ES6 conformance to extending non-classes", ->
#   A = (@title) ->
#     'Title: ' + @

#   class B extends A
#   b = new B('caffeinated')
#   eq b.title, 'caffeinated'

#   # Check inheritance chain
#   A::getTitle = () -> @title
#   eq b.getTitle(), 'caffeinated'

#   throwsC = """
#   C = {title: 'invalid'}
#   class D extends {}
#   """
#   # This should catch on compile and message should be "class can only extend classes and functions."
#   throws -> CoffeeScript.run throwsC, bare: yes

# TODO: Evaluate future compliance with "strict mode";
# test "Class function environment should be in \`strict mode\`, ie as if 'use strict' was in use", ->
#   class A
#     # this might be a meaningless test, since these are likely to be runtime errors and different
#     # for every browser.  Thoughts?
#     constructor: () ->
#       # Ivalid: prop reassignment
#       @state = {prop: [1], prop: {a: 'a'}}
#       # eval reassignment
#       @badEval = eval;

#   # Should throw, but doesn't
#   a = new A

# TODO: new.target needs support  Separate issue
# test "ES6 support for new.target (functions and constructors)", ->
#   throwsA = """
#   class A
#     constructor: () ->
#       a = new.target.name
#   """
#   throws -> CoffeeScript.compile throwsA, bare: yes

test 'only one method named constructor allowed', ->
  throwsA = '''
  class A
    constructor: (@first) ->
    constructor: (@last) ->
  '''
  throws -> CoffeeScript.compile throwsA, bare: yes

test 'If the constructor of a child class does not call super,it should return an object.', ->
  nonce = {}

  class A
  class B extends A
    constructor: ->
      return nonce

  eq nonce, new B()

test 'super can only exist in extended classes', ->
  throwsA = '''
  class A
    constructor: (@name) ->
      super()
  '''
  throws -> CoffeeScript.compile throwsA, bare: yes

# --- CS1 classes compatability breaks ---
test 'CS6 Class extends a CS1 compiled class', ->
  \`\`\`
  // Generated by CoffeeScript 1.11.1
  var BaseCS1, ExtendedCS1,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BaseCS1 = (function() {
    function BaseCS1(drink) {
      this.drink = drink;
    }

    BaseCS1.prototype.make = function() {
      return "making a " + this.drink;
    };

    BaseCS1.className = function() {
      return 'BaseCS1';
    };

    return BaseCS1;

  })();

  ExtendedCS1 = (function(superClass) {
    extend(ExtendedCS1, superClass);

    function ExtendedCS1(flavor) {
      this.flavor = flavor;
      ExtendedCS1.__super__.constructor.call(this, 'cafe ole');
    }

    ExtendedCS1.prototype.make = function() {
      return "making a " + this.drink + " with " + this.flavor;
    };

    ExtendedCS1.className = function() {
      return 'ExtendedCS1';
    };

    return ExtendedCS1;

  })(BaseCS1);

  \`\`\`
  class B extends BaseCS1
  eq B.className(), 'BaseCS1'
  b = new B 'machiato'
  eq b.make(), 'making a machiato'

test 'CS6 Class extends an extended CS1 compiled class', ->
  \`\`\`
  // Generated by CoffeeScript 1.11.1
  var BaseCS1, ExtendedCS1,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BaseCS1 = (function() {
    function BaseCS1(drink) {
      this.drink = drink;
    }

    BaseCS1.prototype.make = function() {
      return "making a " + this.drink;
    };

    BaseCS1.className = function() {
      return 'BaseCS1';
    };

    return BaseCS1;

  })();

  ExtendedCS1 = (function(superClass) {
    extend(ExtendedCS1, superClass);

    function ExtendedCS1(flavor) {
      this.flavor = flavor;
      ExtendedCS1.__super__.constructor.call(this, 'cafe ole');
    }

    ExtendedCS1.prototype.make = function() {
      return "making a " + this.drink + " with " + this.flavor;
    };

    ExtendedCS1.className = function() {
      return 'ExtendedCS1';
    };

    return ExtendedCS1;

  })(BaseCS1);

  \`\`\`
  class B extends ExtendedCS1
  eq B.className(), 'ExtendedCS1'
  b = new B 'vanilla'
  eq b.make(), 'making a cafe ole with vanilla'

test 'CS6 Class extends a CS1 compiled class with super()', ->
  \`\`\`
  // Generated by CoffeeScript 1.11.1
  var BaseCS1, ExtendedCS1,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BaseCS1 = (function() {
    function BaseCS1(drink) {
      this.drink = drink;
    }

    BaseCS1.prototype.make = function() {
      return "making a " + this.drink;
    };

    BaseCS1.className = function() {
      return 'BaseCS1';
    };

    return BaseCS1;

  })();

  ExtendedCS1 = (function(superClass) {
    extend(ExtendedCS1, superClass);

    function ExtendedCS1(flavor) {
      this.flavor = flavor;
      ExtendedCS1.__super__.constructor.call(this, 'cafe ole');
    }

    ExtendedCS1.prototype.make = function() {
      return "making a " + this.drink + " with " + this.flavor;
    };

    ExtendedCS1.className = function() {
      return 'ExtendedCS1';
    };

    return ExtendedCS1;

  })(BaseCS1);

  \`\`\`
  class B extends ExtendedCS1
    constructor: (@shots) ->
      super 'caramel'
    make: ->
      super() + " and #{@shots} shots of espresso"

  eq B.className(), 'ExtendedCS1'
  b = new B 'three'
  eq b.make(), 'making a cafe ole with caramel and three shots of espresso'

test 'Bound method called normally before binding is ok', ->
  class Base
    constructor: ->
      @setProp()
      eq @derivedBound(), 3

  class Derived extends Base
    setProp: ->
      @prop = 3

    derivedBound: =>
      @prop

  d = new Derived()

test 'Bound method called as callback after super() is ok', ->
  class Base

  class Derived extends Base
    constructor: (@prop = 3) ->
      super()
      f = @derivedBound
      eq f(), 3

    derivedBound: =>
      @prop

  d = new Derived()
  { derivedBound } = d
  eq derivedBound(), 3

test 'Bound method of base class called as callback is ok', ->
  class Base
    constructor: (@prop = 3) ->
      f = @baseBound
      eq f(), 3

    baseBound: =>
      @prop

  b = new Base()
  { baseBound } = b
  eq baseBound(), 3

test 'Bound method of prop-named class called as callback is ok', ->
  Hive = {}
  class Hive.Bee
    constructor: (@prop = 3) ->
      f = @baseBound
      eq f(), 3

    baseBound: =>
      @prop

  b = new Hive.Bee()
  { baseBound } = b
  eq baseBound(), 3

test 'Bound method of class with expression base class called as callback is ok', ->
  calledB = no
  B = ->
    throw new Error() if calledB
    calledB = yes
    class
  class A extends B()
    constructor: (@prop = 3) ->
      super()
      f = @derivedBound
      eq f(), 3

    derivedBound: =>
      @prop

  b = new A()
  { derivedBound } = b
  eq derivedBound(), 3

test 'Bound method of class with expression class name called as callback is ok', ->
  calledF = no
  obj = {}
  B = class
  f = ->
    throw new Error() if calledF
    calledF = yes
    obj
  class f().A extends B
    constructor: (@prop = 3) ->
      super()
      g = @derivedBound
      eq g(), 3

    derivedBound: =>
      @prop

  a = new obj.A()
  { derivedBound } = a
  eq derivedBound(), 3

test 'Bound method of anonymous child class called as callback is ok', ->
  f = ->
    B = class
    class extends B
      constructor: (@prop = 3) ->
        super()
        g = @derivedBound
        eq g(), 3

      derivedBound: =>
        @prop

  a = new (f())()
  { derivedBound } = a
  eq derivedBound(), 3

test 'Bound method of immediately instantiated class with expression base class called as callback is ok', ->
  calledF = no
  obj = {}
  B = class
  f = ->
    throw new Error() if calledF
    calledF = yes
    obj
  a = new (class f().A extends B
    constructor: (@prop = 3) ->
      super()
      g = @derivedBound
      eq g(), 3

    derivedBound: =>
      @prop
  )()

  { derivedBound } = a
  eq derivedBound(), 3

test "#4591: super.x.y, super['x'].y", ->
  class A
    x:
      y: 1
      z: -> 2

  class B extends A
    constructor: ->
      super()

      @w = super.x.y
      @v = super['x'].y
      @u = super.x['y']
      @t = super.x.z()
      @s = super['x'].z()
      @r = super.x['z']()

  b = new B()
  eq 1, b.w
  eq 1, b.v
  eq 1, b.u
  eq 2, b.t
  eq 2, b.s
  eq 2, b.r

test '#4464: backticked expressions in class body', ->
  class A
    \`get x() { return 42; }\`

  class B
    \`get x() { return 42; }\`
    constructor: ->
      @y = 84

  a = new A()
  eq 42, a.x
  b = new B()
  eq 42, b.x
  eq 84, b.y

test '#4724: backticked expression in a class body with hoisted member', ->
  class A
    \`get x() { return 42; }\`
    hoisted: 84

  a = new A()
  eq 42, a.x
  eq 84, a.hoisted

test '#4822: nested anonymous classes use non-conflicting variable names', ->
  Class = class
    @a: class
      @b: 1

  eq Class.a.b, 1

test '#4827: executable class body wrappers have correct context', ->
  test = ->
    class @A
    class @B extends @A
      @property = 1

  o = {}
  test.call o
  ok typeof o.A is typeof o.B is 'function'

test '#4868: Incorrect ‘Can’t call super with @params’ error', ->
  class A
    constructor: (@func = ->) ->
      @x = 1
      @func()

  class B extends A
    constructor: ->
      super -> @x = 2

  a = new A()
  b = new B()
  eq 1, a.x
  eq 2, b.x

  class C
    constructor: (@c = class) -> @c

  class D extends C
    constructor: ->
      super(
        class
          constructor: (@a) -> @a = 3
      )

  d = new new D().c()
  eq 3, d.a

`;

exports[`cluster.coffee 1`] = `
# Cluster Module
# ---------

return if testingBrowser?

cluster = require 'cluster'

if cluster.isMaster
  test "#2737 - cluster module can spawn workers from a coffeescript process", ->
    cluster.once 'exit', (worker, code) ->
      eq code, 0

    cluster.fork()
else
  process.exit 0
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Cluster Module
# ---------

return if testingBrowser?

cluster = require 'cluster'

if cluster.isMaster
  test '#2737 - cluster module can spawn workers from a coffeescript process', ->
    cluster.once 'exit', (worker, code) ->
      eq code, 0

    cluster.fork()
else
  process.exit 0

`;

exports[`compilation.coffee 1`] = `
# Compilation
# -----------

# Helper to assert that a string should fail compilation.
cantCompile = (code) ->
  throws -> CoffeeScript.compile code

# Helper to pipe the CoffeeScript compiler’s output through a transpiler.
transpile = (method, code, options = {}) ->
  # \`method\` should be 'compile' or 'eval' or 'run'
  options.bare = yes
  options.transpile =
    # Target Internet Explorer 6, which supports no ES2015+ features.
    presets: [['env', {targets: browsers: ['ie 6']}]]
  CoffeeScript[method] code, options


test "ensure that carriage returns don't break compilation on Windows", ->
  doesNotThrow -> CoffeeScript.compile 'one\\r\\ntwo', bare: on

test "#3089 - don't mutate passed in options to compile", ->
  opts = {}
  CoffeeScript.compile '1 + 1', opts
  ok !opts.scope

test "--bare", ->
  eq -1, CoffeeScript.compile('x = y', bare: on).indexOf 'function'
  ok 'passed' is CoffeeScript.eval '"passed"', bare: on, filename: 'test'

test "header (#1778)", ->
  header = "// Generated by CoffeeScript #{CoffeeScript.VERSION}\\n"
  eq 0, CoffeeScript.compile('x = y', header: on).indexOf header

test "header is disabled by default", ->
  header = "// Generated by CoffeeScript #{CoffeeScript.VERSION}\\n"
  eq -1, CoffeeScript.compile('x = y').indexOf header

test "multiple generated references", ->
  a = {b: []}
  a.b[true] = -> this == a.b
  c = 0
  d = []
  ok a.b[0<++c<2] d...

test "splat on a line by itself is invalid", ->
  cantCompile "x 'a'\\n...\\n"

test "Issue 750", ->

  cantCompile 'f(->'

  cantCompile 'a = (break)'

  cantCompile 'a = (return 5 for item in list)'

  cantCompile 'a = (return 5 while condition)'

  cantCompile 'a = for x in y\\n  return 5'

test "Issue #986: Unicode identifiers", ->
  λ = 5
  eq λ, 5

test "#2516: Unicode spaces should not be part of identifiers", ->
  a = (x) -> x * 2
  b = 3
  eq 6, a b # U+00A0 NO-BREAK SPACE
  eq 6, a b # U+1680 OGHAM SPACE MARK
  eq 6, a b # U+2000 EN QUAD
  eq 6, a b # U+2001 EM QUAD
  eq 6, a b # U+2002 EN SPACE
  eq 6, a b # U+2003 EM SPACE
  eq 6, a b # U+2004 THREE-PER-EM SPACE
  eq 6, a b # U+2005 FOUR-PER-EM SPACE
  eq 6, a b # U+2006 SIX-PER-EM SPACE
  eq 6, a b # U+2007 FIGURE SPACE
  eq 6, a b # U+2008 PUNCTUATION SPACE
  eq 6, a b # U+2009 THIN SPACE
  eq 6, a b # U+200A HAIR SPACE
  eq 6, a b # U+202F NARROW NO-BREAK SPACE
  eq 6, a b # U+205F MEDIUM MATHEMATICAL SPACE
  eq 6, a　b # U+3000 IDEOGRAPHIC SPACE

  # #3560: Non-breaking space (U+00A0) (before \`'c'\`)
  eq 5, {c: 5}[ 'c' ]

  # A line where every space in non-breaking
  eq 1 + 1, 2  

test "don't accidentally stringify keywords", ->
  ok (-> this == 'this')() is false

test "#1026: no if/else/else allowed", ->
  cantCompile '''
    if a
      b
    else
      c
    else
      d
  '''

test "#1050: no closing asterisk comments from within block comments", ->
  cantCompile "### */ ###"

test "#1273: escaping quotes at the end of heredocs", ->
  cantCompile '"""\\\\"""' # """\\"""
  cantCompile '"""\\\\\\\\\\\\"""' # """\\\\\\"""

test "#1106: __proto__ compilation", ->
  object = eq
  @["__proto__"] = true
  ok __proto__

test "reference named hasOwnProperty", ->
  CoffeeScript.compile 'hasOwnProperty = 0; a = 1'

test "#1055: invalid keys in real (but not work-product) objects", ->
  cantCompile "@key: value"

test "#1066: interpolated strings are not implicit functions", ->
  cantCompile '"int#{er}polated" arg'

test "#2846: while with empty body", ->
  CoffeeScript.compile 'while 1 then', {sourceMap: true}

test "#2944: implicit call with a regex argument", ->
  CoffeeScript.compile 'o[key] /regex/'

test "#3001: \`own\` shouldn't be allowed in a \`for\`-\`in\` loop", ->
  cantCompile "a for own b in c"

test "#2994: single-line \`if\` requires \`then\`", ->
  cantCompile "if b else x"

test "transpile option, for Node API CoffeeScript.compile", ->
  return if global.testingBrowser
  ok transpile('compile', "import fs from 'fs'").includes 'require'

test "transpile option, for Node API CoffeeScript.eval", ->
  return if global.testingBrowser
  ok transpile 'eval', "import path from 'path'; path.sep in ['/', '\\\\\\\\']"

test "transpile option, for Node API CoffeeScript.run", ->
  return if global.testingBrowser
  doesNotThrow -> transpile 'run', "import fs from 'fs'"

test "transpile option has merged source maps", ->
  return if global.testingBrowser
  untranspiledOutput = CoffeeScript.compile "import path from 'path'\\nconsole.log path.sep", sourceMap: yes
  transpiledOutput   = transpile 'compile', "import path from 'path'\\nconsole.log path.sep", sourceMap: yes
  untranspiledOutput.v3SourceMap = JSON.parse untranspiledOutput.v3SourceMap
  transpiledOutput.v3SourceMap   = JSON.parse transpiledOutput.v3SourceMap
  ok untranspiledOutput.v3SourceMap.mappings isnt transpiledOutput.v3SourceMap.mappings
  # Babel adds \`'use strict';\` to the top of files with the modules transform.
  eq transpiledOutput.js.indexOf('use strict'), 1
  # The \`'use strict';\` followed by two newlines results in the first two lines
  # of the source map mappings being two blank/skipped lines.
  eq transpiledOutput.v3SourceMap.mappings.indexOf(';;'), 0
  # The number of lines in the transpiled code should match the number of lines
  # in the source map.
  eq transpiledOutput.js.split('\\n').length, transpiledOutput.v3SourceMap.mappings.split(';').length

test "using transpile from the Node API requires an object", ->
  try
    CoffeeScript.compile '', transpile: yes
  catch exception
    eq exception.message, 'The transpile option must be given an object with options to pass to Babel'

test "transpile option applies to imported .coffee files", ->
  return if global.testingBrowser
  doesNotThrow -> transpile 'run', "import { getSep } from './test/importing/transpile_import'\\ngetSep()"

test "#3306: trailing comma in a function call in the last line", ->
  eqJS '''
  foo bar,
  ''', '''
  foo(bar);
  '''~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Compilation
# -----------

# Helper to assert that a string should fail compilation.
cantCompile = (code) ->
  throws -> CoffeeScript.compile code

# Helper to pipe the CoffeeScript compiler’s output through a transpiler.
transpile = (method, code, options = {}) ->
  # \`method\` should be 'compile' or 'eval' or 'run'
  options.bare = yes
  options.transpile =
    # Target Internet Explorer 6, which supports no ES2015+ features.
    presets: [['env', { targets: browsers: ['ie 6'] }]]
  CoffeeScript[method] code, options

test "ensure that carriage returns don't break compilation on Windows", ->
  doesNotThrow -> CoffeeScript.compile 'one\\r\\ntwo', bare: on

test "#3089 - don't mutate passed in options to compile", ->
  opts = {}
  CoffeeScript.compile '1 + 1', opts
  ok !opts.scope

test '--bare', ->
  eq -1, CoffeeScript.compile('x = y', bare: on).indexOf 'function'
  ok 'passed' is CoffeeScript.eval '"passed"', bare: on, filename: 'test'

test 'header (#1778)', ->
  header = "// Generated by CoffeeScript #{CoffeeScript.VERSION}\\n"
  eq 0, CoffeeScript.compile('x = y', header: on).indexOf header

test 'header is disabled by default', ->
  header = "// Generated by CoffeeScript #{CoffeeScript.VERSION}\\n"
  eq -1, CoffeeScript.compile('x = y').indexOf header

test 'multiple generated references', ->
  a = b: []
  a.b[true] = -> this == a.b
  c = 0
  d = []
  ok a.b[0 < ++c < 2] d...

test 'splat on a line by itself is invalid', ->
  cantCompile "x 'a'\\n...\\n"

test 'Issue 750', ->
  cantCompile 'f(->'

  cantCompile 'a = (break)'

  cantCompile 'a = (return 5 for item in list)'

  cantCompile 'a = (return 5 while condition)'

  cantCompile 'a = for x in y\\n  return 5'

test 'Issue #986: Unicode identifiers', ->
  λ = 5
  eq λ, 5

test '#2516: Unicode spaces should not be part of identifiers', ->
  a = (x) -> x * 2
  b = 3
  eq 6, a b # U+00A0 NO-BREAK SPACE
  eq 6, a b # U+1680 OGHAM SPACE MARK
  eq 6, a b # U+2000 EN QUAD
  eq 6, a b # U+2001 EM QUAD
  eq 6, a b # U+2002 EN SPACE
  eq 6, a b # U+2003 EM SPACE
  eq 6, a b # U+2004 THREE-PER-EM SPACE
  eq 6, a b # U+2005 FOUR-PER-EM SPACE
  eq 6, a b # U+2006 SIX-PER-EM SPACE
  eq 6, a b # U+2007 FIGURE SPACE
  eq 6, a b # U+2008 PUNCTUATION SPACE
  eq 6, a b # U+2009 THIN SPACE
  eq 6, a b # U+200A HAIR SPACE
  eq 6, a b # U+202F NARROW NO-BREAK SPACE
  eq 6, a b # U+205F MEDIUM MATHEMATICAL SPACE
  eq 6, a b # U+3000 IDEOGRAPHIC SPACE

  # #3560: Non-breaking space (U+00A0) (before \`'c'\`)
  eq 5, { c: 5 }['c']

  # A line where every space in non-breaking
  eq 1 + 1, 2
test "don't accidentally stringify keywords", ->
  ok (-> this == 'this')() is false

test '#1026: no if/else/else allowed', ->
  cantCompile '''
    if a
      b
    else
      c
    else
      d
  '''

test '#1050: no closing asterisk comments from within block comments', ->
  cantCompile '### */ ###'

test '#1273: escaping quotes at the end of heredocs', ->
  cantCompile '"""\\\\"""' # """\\"""
  cantCompile '"""\\\\\\\\\\\\"""' # """\\\\\\"""

test '#1106: __proto__ compilation', ->
  object = eq
  @['__proto__'] = true
  ok __proto__

test 'reference named hasOwnProperty', ->
  CoffeeScript.compile 'hasOwnProperty = 0; a = 1'

test '#1055: invalid keys in real (but not work-product) objects', ->
  cantCompile '@key: value'

test '#1066: interpolated strings are not implicit functions', ->
  cantCompile '"int#{er}polated" arg'

test '#2846: while with empty body', ->
  CoffeeScript.compile 'while 1 then', sourceMap: true

test '#2944: implicit call with a regex argument', ->
  CoffeeScript.compile 'o[key] /regex/'

test "#3001: \`own\` shouldn't be allowed in a \`for\`-\`in\` loop", ->
  cantCompile 'a for own b in c'

test '#2994: single-line \`if\` requires \`then\`', ->
  cantCompile 'if b else x'

test 'transpile option, for Node API CoffeeScript.compile', ->
  return if global.testingBrowser
  ok transpile('compile', "import fs from 'fs'").includes 'require'

test 'transpile option, for Node API CoffeeScript.eval', ->
  return if global.testingBrowser
  ok transpile 'eval', "import path from 'path'; path.sep in ['/', '\\\\\\\\']"

test 'transpile option, for Node API CoffeeScript.run', ->
  return if global.testingBrowser
  doesNotThrow -> transpile 'run', "import fs from 'fs'"

test 'transpile option has merged source maps', ->
  return if global.testingBrowser
  untranspiledOutput = CoffeeScript.compile(
    "import path from 'path'\\nconsole.log path.sep"
    sourceMap: yes
  )
  transpiledOutput = transpile(
    'compile'
    "import path from 'path'\\nconsole.log path.sep"
    sourceMap: yes
  )
  untranspiledOutput.v3SourceMap = JSON.parse untranspiledOutput.v3SourceMap
  transpiledOutput.v3SourceMap = JSON.parse transpiledOutput.v3SourceMap
  ok(
    untranspiledOutput.v3SourceMap.mappings isnt
      transpiledOutput.v3SourceMap.mappings
  )
  # Babel adds \`'use strict';\` to the top of files with the modules transform.
  eq transpiledOutput.js.indexOf('use strict'), 1
  # The \`'use strict';\` followed by two newlines results in the first two lines
  # of the source map mappings being two blank/skipped lines.
  eq transpiledOutput.v3SourceMap.mappings.indexOf(';;'), 0
  # The number of lines in the transpiled code should match the number of lines
  # in the source map.
  eq(
    transpiledOutput.js.split('\\n').length
    transpiledOutput.v3SourceMap.mappings.split(';').length
  )

test 'using transpile from the Node API requires an object', ->
  try
    CoffeeScript.compile '', transpile: yes
  catch exception
    eq(
      exception.message
      'The transpile option must be given an object with options to pass to Babel'
    )

test 'transpile option applies to imported .coffee files', ->
  return if global.testingBrowser
  doesNotThrow ->
    transpile(
      'run'
      "import { getSep } from './test/importing/transpile_import'\\ngetSep()"
    )

test '#3306: trailing comma in a function call in the last line', ->
  eqJS(
    '''
  foo bar,
  '''
    '''
  foo(bar);
  '''
  )

`;

exports[`comprehensions.coffee 1`] = `
# Comprehensions
# --------------

# * Array Comprehensions
# * Range Comprehensions
# * Object Comprehensions
# * Implicit Destructuring Assignment
# * Comprehensions with Nonstandard Step

# TODO: refactor comprehension tests

test "Basic array comprehensions.", ->

  nums    = (n * n for n in [1, 2, 3] when n & 1)
  results = (n * 2 for n in nums)

  ok results.join(',') is '2,18'


test "Basic object comprehensions.", ->

  obj   = {one: 1, two: 2, three: 3}
  names = (prop + '!' for prop of obj)
  odds  = (prop + '!' for prop, value of obj when value & 1)

  ok names.join(' ') is "one! two! three!"
  ok odds.join(' ')  is "one! three!"


test "Basic range comprehensions.", ->

  nums = (i * 3 for i in [1..3])

  negs = (x for x in [-20..-5*2])
  negs = negs[0..2]

  result = nums.concat(negs).join(', ')

  ok result is '3, 6, 9, -20, -19, -18'


test "With range comprehensions, you can loop in steps.", ->

  results = (x for x in [0...15] by 5)
  ok results.join(' ') is '0 5 10'

  results = (x for x in [0..100] by 10)
  ok results.join(' ') is '0 10 20 30 40 50 60 70 80 90 100'


test "And can loop downwards, with a negative step.", ->

  results = (x for x in [5..1])

  ok results.join(' ') is '5 4 3 2 1'
  ok results.join(' ') is [(10-5)..(-2+3)].join(' ')

  results = (x for x in [10..1])
  ok results.join(' ') is [10..1].join(' ')

  results = (x for x in [10...0] by -2)
  ok results.join(' ') is [10, 8, 6, 4, 2].join(' ')


test "Range comprehension gymnastics.", ->

  eq "#{i for i in [5..1]}", '5,4,3,2,1'
  eq "#{i for i in [5..-5] by -5}", '5,0,-5'

  a = 6
  b = 0
  c = -2

  eq "#{i for i in [a..b]}", '6,5,4,3,2,1,0'
  eq "#{i for i in [a..b] by c}", '6,4,2,0'


test "Multiline array comprehension with filter.", ->

  evens = for num in [1, 2, 3, 4, 5, 6] when not (num & 1)
             num *= -1
             num -= 2
             num * -1
  eq evens + '', '4,6,8'


  test "The in operator still works, standalone.", ->

    ok 2 of evens


test "all isn't reserved.", ->

  all = 1


test "Ensure that the closure wrapper preserves local variables.", ->

  obj = {}

  for method in ['one', 'two', 'three'] then do (method) ->
    obj[method] = ->
      "I'm " + method

  ok obj.one()   is "I'm one"
  ok obj.two()   is "I'm two"
  ok obj.three() is "I'm three"


test "Index values at the end of a loop.", ->

  i = 0
  for i in [1..3]
    -> 'func'
    break if false
  ok i is 4


test "Ensure that local variables are closed over for range comprehensions.", ->

  funcs = for i in [1..3]
    do (i) ->
      -> -i

  eq (func() for func in funcs).join(' '), '-1 -2 -3'
  ok i is 4


test "Even when referenced in the filter.", ->

  list = ['one', 'two', 'three']

  methods = for num, i in list when num isnt 'two' and i isnt 1
    do (num, i) ->
      -> num + ' ' + i

  ok methods.length is 2
  ok methods[0]() is 'one 0'
  ok methods[1]() is 'three 2'


test "Even a convoluted one.", ->

  funcs = []

  for i in [1..3]
    do (i) ->
      x = i * 2
      ((z)->
        funcs.push -> z + ' ' + i
      )(x)

  ok (func() for func in funcs).join(', ') is '2 1, 4 2, 6 3'

  funcs = []

  results = for i in [1..3]
    do (i) ->
      z = (x * 3 for x in [1..i])
      ((a, b, c) -> [a, b, c].join(' ')).apply this, z

  ok results.join(', ') is '3  , 3 6 , 3 6 9'


test "Naked ranges are expanded into arrays.", ->

  array = [0..10]
  ok(num % 2 is 0 for num in array by 2)


test "Nested shared scopes.", ->

  foo = ->
    for i in [0..7]
      do (i) ->
        for j in [0..7]
          do (j) ->
            -> i + j

  eq foo()[3][4](), 7


test "Scoped loop pattern matching.", ->

  a = [[0], [1]]
  funcs = []

  for [v] in a
    do (v) ->
      funcs.push -> v

  eq funcs[0](), 0
  eq funcs[1](), 1


test "Nested comprehensions.", ->

  multiLiner =
    for x in [3..5]
      for y in [3..5]
        [x, y]

  singleLiner =
    (([x, y] for y in [3..5]) for x in [3..5])

  ok multiLiner.length is singleLiner.length
  ok 5 is multiLiner[2][2][1]
  ok 5 is singleLiner[2][2][1]


test "Comprehensions within parentheses.", ->

  result = null
  store = (obj) -> result = obj
  store (x * 2 for x in [3, 2, 1])

  ok result.join(' ') is '6 4 2'


test "Closure-wrapped comprehensions that refer to the 'arguments' object.", ->

  expr = ->
    result = (item * item for item in arguments)

  ok expr(2, 4, 8).join(' ') is '4 16 64'


test "Fast object comprehensions over all properties, including prototypal ones.", ->

  class Cat
    constructor: -> @name = 'Whiskers'
    breed: 'tabby'
    hair:  'cream'

  whiskers = new Cat
  own = (value for own key, value of whiskers)
  all = (value for key, value of whiskers)

  ok own.join(' ') is 'Whiskers'
  ok all.sort().join(' ') is 'Whiskers cream tabby'


test "Optimized range comprehensions.", ->

  exxes = ('x' for [0...10])
  ok exxes.join(' ') is 'x x x x x x x x x x'


test "#3671: Allow step in optimized range comprehensions.", ->

  exxes = ('x' for [0...10] by 2)
  eq exxes.join(' ') , 'x x x x x'


test "#3671: Disallow guard in optimized range comprehensions.", ->

  throws -> CoffeeScript.compile "exxes = ('x' for [0...10] when a)"


test "Loop variables should be able to reference outer variables", ->
  outer = 1
  do ->
    null for outer in [1, 2, 3]
  eq outer, 3


test "Lenient on pure statements not trying to reach out of the closure", ->

  val = for i in [1]
    for j in [] then break
    i
  ok val[0] is i


test "Comprehensions only wrap their last line in a closure, allowing other lines
  to have pure expressions in them.", ->

  func = -> for i in [1]
    break if i is 2
    j for j in [1]

  ok func()[0][0] is 1

  i = 6
  odds = while i--
    continue unless i & 1
    i

  ok odds.join(', ') is '5, 3, 1'


test "Issue #897: Ensure that plucked function variables aren't leaked.", ->

  facets = {}
  list = ['one', 'two']

  (->
    for entity in list
      facets[entity] = -> entity
  )()

  eq typeof entity, 'undefined'
  eq facets['two'](), 'two'


test "Issue #905. Soaks as the for loop subject.", ->

  a = {b: {c: [1, 2, 3]}}
  for d in a.b?.c
    e = d

  eq e, 3


test "Issue #948. Capturing loop variables.", ->

  funcs = []
  list  = ->
    [1, 2, 3]

  for y in list()
    do (y) ->
      z = y
      funcs.push -> "y is #{y} and z is #{z}"

  eq funcs[1](), "y is 2 and z is 2"


test "Cancel the comprehension if there's a jump inside the loop.", ->

  result = try
    for i in [0...10]
      continue if i < 5
    i

  eq result, 10


test "Comprehensions over break.", ->

  arrayEq (break for [1..10]), []


test "Comprehensions over continue.", ->

  arrayEq (continue for [1..10]), []


test "Comprehensions over function literals.", ->

  a = 0
  for f in [-> a = 1]
    do (f) ->
      do f

  eq a, 1


test "Comprehensions that mention arguments.", ->

  list = [arguments: 10]
  args = for f in list
    do (f) ->
      f.arguments
  eq args[0], 10


test "expression conversion under explicit returns", ->
  nonce = {}
  fn = ->
    return (nonce for x in [1,2,3])
  arrayEq [nonce,nonce,nonce], fn()
  fn = ->
    return [nonce for x in [1,2,3]][0]
  arrayEq [nonce,nonce,nonce], fn()
  fn = ->
    return [(nonce for x in [1..3])][0]
  arrayEq [nonce,nonce,nonce], fn()


test "implicit destructuring assignment in object of objects", ->
  a={}; b={}; c={}
  obj = {
    a: { d: a },
    b: { d: b }
    c: { d: c }
  }
  result = ([y,z] for y, { d: z } of obj)
  arrayEq [['a',a],['b',b],['c',c]], result


test "implicit destructuring assignment in array of objects", ->
  a={}; b={}; c={}; d={}; e={}; f={}
  arr = [
    { a: a, b: { c: b } },
    { a: c, b: { c: d } },
    { a: e, b: { c: f } }
  ]
  result = ([y,z] for { a: y, b: { c: z } } in arr)
  arrayEq [[a,b],[c,d],[e,f]], result


test "implicit destructuring assignment in array of arrays", ->
  a={}; b={}; c={}; d={}; e={}; f={}
  arr = [[a, [b]], [c, [d]], [e, [f]]]
  result = ([y,z] for [y, [z]] in arr)
  arrayEq [[a,b],[c,d],[e,f]], result

test "issue #1124: don't assign a variable in two scopes", ->
  lista = [1, 2, 3, 4, 5]
  listb = (_i + 1 for _i in lista)
  arrayEq [2, 3, 4, 5, 6], listb

test "#1326: \`by\` value is uncached", ->
  a = [0,1,2]
  fi = gi = hi = 0
  f = -> ++fi
  g = -> ++gi
  h = -> ++hi

  forCompile = []
  rangeCompileSimple = []

  #exercises For.compile
  for v, i in a by f()
    forCompile.push i

  #exercises Range.compileSimple
  rangeCompileSimple = (i for i in [0..2] by g())

  arrayEq a, forCompile
  arrayEq a, rangeCompileSimple
  #exercises Range.compile
  eq "#{i for i in [0..2] by h()}", '0,1,2'

test "#1669: break/continue should skip the result only for that branch", ->
  ns = for n in [0..99]
    if n > 9
      break
    else if n & 1
      continue
    else
      n
  eq "#{ns}", '0,2,4,6,8'

  # \`else undefined\` is implied.
  ns = for n in [1..9]
    if n % 2
      continue unless n % 5
      n
  eq "#{ns}", "1,,3,,,7,,9"

  # Ditto.
  ns = for n in [1..9]
    switch
      when n % 2
        continue unless n % 5
        n
  eq "#{ns}", "1,,3,,,7,,9"

test "#1850: inner \`for\` should not be expression-ized if \`return\`ing", ->
  eq '3,4,5', do ->
    for a in [1..9] then \\
    for b in [1..9]
      c = Math.sqrt a*a + b*b
      return String [a, b, c] unless c % 1

test "#1910: loop index should be mutable within a loop iteration and immutable between loop iterations", ->
  n = 1
  iterations = 0
  arr = [0..n]
  for v, k in arr
    ++iterations
    v = k = 5
    eq 5, k
  eq 2, k
  eq 2, iterations

  iterations = 0
  for v in [0..n]
    ++iterations
  eq 2, k
  eq 2, iterations

  arr = ([v, v + 1] for v in [0..5])
  iterations = 0
  for [v0, v1], k in arr when v0
    k += 3
    ++iterations
  eq 6, k
  eq 5, iterations

test "#2007: Return object literal from comprehension", ->
  y = for x in [1, 2]
    foo: "foo" + x
  eq 2, y.length
  eq "foo1", y[0].foo
  eq "foo2", y[1].foo

  x = 2
  y = while x
    x: --x
  eq 2, y.length
  eq 1, y[0].x
  eq 0, y[1].x

test "#2274: Allow @values as loop variables", ->
  obj = {
    item: null
    method: ->
      for @item in [1, 2, 3]
        null
  }
  eq obj.item, null
  obj.method()
  eq obj.item, 3

test "#4411: Allow @values as loop indices", ->
  obj =
    index: null
    get: -> @index
    method: ->
      @get() for _, @index in [1, 2, 3]
  eq obj.index, null
  arrayEq obj.method(), [0, 1, 2]
  eq obj.index, 3

test "#2525, #1187, #1208, #1758, looping over an array forwards", ->
  list = [0, 1, 2, 3, 4]

  ident = (x) -> x

  arrayEq (i for i in list), list

  arrayEq (index for i, index in list), list

  arrayEq (i for i in list by 1), list

  arrayEq (i for i in list by ident 1), list

  arrayEq (i for i in list by ident(1) * 2), [0, 2, 4]

  arrayEq (index for i, index in list by ident(1) * 2), [0, 2, 4]

test "#2525, #1187, #1208, #1758, looping over an array backwards", ->
  list = [0, 1, 2, 3, 4]
  backwards = [4, 3, 2, 1, 0]

  ident = (x) -> x

  arrayEq (i for i in list by -1), backwards

  arrayEq (index for i, index in list by -1), backwards

  arrayEq (i for i in list by ident -1), backwards

  arrayEq (i for i in list by ident(-1) * 2), [4, 2, 0]

  arrayEq (index for i, index in list by ident(-1) * 2), [4, 2, 0]

test "splats in destructuring in comprehensions", ->
  list = [[0, 1, 2], [2, 3, 4], [4, 5, 6]]
  arrayEq (seq for [rep, seq...] in list), [[1, 2], [3, 4], [5, 6]]

test "#156: expansion in destructuring in comprehensions", ->
  list = [[0, 1, 2], [2, 3, 4], [4, 5, 6]]
  arrayEq (last for [..., last] in list), [2, 4, 6]

test "#3778: Consistently always cache for loop range boundaries and steps, even
      if they are simple identifiers", ->
  a = 1; arrayEq [1, 2, 3], (for n in [1, 2, 3] by  a then a = 4; n)
  a = 1; arrayEq [1, 2, 3], (for n in [1, 2, 3] by +a then a = 4; n)
  a = 1; arrayEq [1, 2, 3], (for n in [a..3]          then a = 4; n)
  a = 1; arrayEq [1, 2, 3], (for n in [+a..3]         then a = 4; n)
  a = 3; arrayEq [1, 2, 3], (for n in [1..a]          then a = 4; n)
  a = 3; arrayEq [1, 2, 3], (for n in [1..+a]         then a = 4; n)
  a = 1; arrayEq [1, 2, 3], (for n in [1..3] by  a    then a = 4; n)
  a = 1; arrayEq [1, 2, 3], (for n in [1..3] by +a    then a = 4; n)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Comprehensions
# --------------

# * Array Comprehensions
# * Range Comprehensions
# * Object Comprehensions
# * Implicit Destructuring Assignment
# * Comprehensions with Nonstandard Step

# TODO: refactor comprehension tests

test 'Basic array comprehensions.', ->
  nums = (n * n for n in [1, 2, 3] when n & 1)
  results = (n * 2 for n in nums)

  ok results.join(',') is '2,18'

test 'Basic object comprehensions.', ->
  obj = one: 1, two: 2, three: 3
  names = (prop + '!' for prop of obj)
  odds = (prop + '!' for prop, value of obj when value & 1)

  ok names.join(' ') is 'one! two! three!'
  ok odds.join(' ') is 'one! three!'

test 'Basic range comprehensions.', ->
  nums = (i * 3 for i in [1..3])

  negs = (x for x in [-20..(-5 * 2)])
  negs = negs[0..2]

  result = nums.concat(negs).join ', '

  ok result is '3, 6, 9, -20, -19, -18'

test 'With range comprehensions, you can loop in steps.', ->
  results = (x for x in [0...15] by 5)
  ok results.join(' ') is '0 5 10'

  results = (x for x in [0..100] by 10)
  ok results.join(' ') is '0 10 20 30 40 50 60 70 80 90 100'

test 'And can loop downwards, with a negative step.', ->
  results = (x for x in [5..1])

  ok results.join(' ') is '5 4 3 2 1'
  ok results.join(' ') is [(10 - 5)..(-2 + 3)].join ' '

  results = (x for x in [10..1])
  ok results.join(' ') is [10..1].join ' '

  results = (x for x in [10...0] by -2)
  ok results.join(' ') is [10, 8, 6, 4, 2].join ' '

test 'Range comprehension gymnastics.', ->
  eq "#{i for i in [5..1]}", '5,4,3,2,1'
  eq "#{i for i in [5..-5] by -5}", '5,0,-5'

  a = 6
  b = 0
  c = -2

  eq "#{i for i in [a..b]}", '6,5,4,3,2,1,0'
  eq "#{i for i in [a..b] by c}", '6,4,2,0'

test 'Multiline array comprehension with filter.', ->
  evens = for num in [1, 2, 3, 4, 5, 6] when not (num & 1)
    num *= -1
    num -= 2
    num * -1
  eq evens + '', '4,6,8'

  test 'The in operator still works, standalone.', ->
    ok 2 of evens

test "all isn't reserved.", ->
  all = 1

test 'Ensure that the closure wrapper preserves local variables.', ->
  obj = {}

  for method in ['one', 'two', 'three'] then do (method) ->
    obj[method] = ->
      "I'm " + method

  ok obj.one() is "I'm one"
  ok obj.two() is "I'm two"
  ok obj.three() is "I'm three"

test 'Index values at the end of a loop.', ->
  i = 0
  for i in [1..3]
    -> 'func'
    break if false
  ok i is 4

test 'Ensure that local variables are closed over for range comprehensions.', ->
  funcs = for i in [1..3]
    do (i) ->
      -> -i

  eq (func() for func in funcs).join(' '), '-1 -2 -3'
  ok i is 4

test 'Even when referenced in the filter.', ->
  list = ['one', 'two', 'three']

  methods = for num, i in list when num isnt 'two' and i isnt 1
    do (num, i) ->
      -> num + ' ' + i

  ok methods.length is 2
  ok methods[0]() is 'one 0'
  ok methods[1]() is 'three 2'

test 'Even a convoluted one.', ->
  funcs = []

  for i in [1..3]
    do (i) ->
      x = i * 2
      ((z) ->
        funcs.push -> z + ' ' + i
      ) x

  ok (func() for func in funcs).join(', ') is '2 1, 4 2, 6 3'

  funcs = []

  results = for i in [1..3]
    do (i) ->
      z = (x * 3 for x in [1..i])
      ((a, b, c) -> [a, b, c].join ' ').apply this, z

  ok results.join(', ') is '3  , 3 6 , 3 6 9'

test 'Naked ranges are expanded into arrays.', ->
  array = [0..10]
  ok((num % 2) is 0 for num in array by 2)

test 'Nested shared scopes.', ->
  foo = ->
    for i in [0..7]
      do (i) ->
        for j in [0..7]
          do (j) ->
            -> i + j

  eq foo()[3][4](), 7

test 'Scoped loop pattern matching.', ->
  a = [[0], [1]]
  funcs = []

  for [v] in a
    do (v) ->
      funcs.push -> v

  eq funcs[0](), 0
  eq funcs[1](), 1

test 'Nested comprehensions.', ->
  multiLiner = for x in [3..5]
    for y in [3..5]
      [x, y]

  singleLiner = ([x, y] for y in [3..5] for x in [3..5])

  ok multiLiner.length is singleLiner.length
  ok 5 is multiLiner[2][2][1]
  ok 5 is singleLiner[2][2][1]

test 'Comprehensions within parentheses.', ->
  result = null
  store = (obj) -> result = obj
  store(x * 2 for x in [3, 2, 1])

  ok result.join(' ') is '6 4 2'

test "Closure-wrapped comprehensions that refer to the 'arguments' object.", ->
  expr = ->
    result = (item * item for item in arguments)

  ok expr(2, 4, 8).join(' ') is '4 16 64'

test 'Fast object comprehensions over all properties, including prototypal ones.', ->
  class Cat
    constructor: -> @name = 'Whiskers'
    breed: 'tabby'
    hair: 'cream'

  whiskers = new Cat()
  own = (value for own key, value of whiskers)
  all = (value for key, value of whiskers)

  ok own.join(' ') is 'Whiskers'
  ok all.sort().join(' ') is 'Whiskers cream tabby'

test 'Optimized range comprehensions.', ->
  exxes = ('x' for [0...10])
  ok exxes.join(' ') is 'x x x x x x x x x x'

test '#3671: Allow step in optimized range comprehensions.', ->
  exxes = ('x' for [0...10] by 2)
  eq exxes.join(' '), 'x x x x x'

test '#3671: Disallow guard in optimized range comprehensions.', ->
  throws -> CoffeeScript.compile "exxes = ('x' for [0...10] when a)"

test 'Loop variables should be able to reference outer variables', ->
  outer = 1
  do ->
    null for outer in [1, 2, 3]
  eq outer, 3

test 'Lenient on pure statements not trying to reach out of the closure', ->
  val = for i in [1]
    for j in [] then break
    i
  ok val[0] is i

test 'Comprehensions only wrap their last line in a closure, allowing other lines
  to have pure expressions in them.', ->
  func = ->
    for i in [1]
      break if i is 2
      j for j in [1]

  ok func()[0][0] is 1

  i = 6
  odds = while i--
    continue unless i & 1
    i

  ok odds.join(', ') is '5, 3, 1'

test "Issue #897: Ensure that plucked function variables aren't leaked.", ->
  facets = {}
  list = ['one', 'two']

  (->
    for entity in list
      facets[entity] = -> entity
  )()

  eq typeof entity, 'undefined'
  eq facets['two'](), 'two'

test 'Issue #905. Soaks as the for loop subject.', ->
  a = b: c: [1, 2, 3]
  for d in a.b?.c
    e = d

  eq e, 3

test 'Issue #948. Capturing loop variables.', ->
  funcs = []
  list = ->
    [1, 2, 3]

  for y in list()
    do (y) ->
      z = y
      funcs.push -> "y is #{y} and z is #{z}"

  eq funcs[1](), 'y is 2 and z is 2'

test "Cancel the comprehension if there's a jump inside the loop.", ->
  result = try
    for i in [0...10]
      continue if i < 5
    i

  eq result, 10

test 'Comprehensions over break.', ->
  arrayEq (break for [1..10]), []

test 'Comprehensions over continue.', ->
  arrayEq (continue for [1..10]), []

test 'Comprehensions over function literals.', ->
  a = 0
  for f in [-> a = 1]
    do (f) ->
      do f

  eq a, 1

test 'Comprehensions that mention arguments.', ->
  list = [arguments: 10]
  args = for f in list
    do (f) ->
      f.arguments
  eq args[0], 10

test 'expression conversion under explicit returns', ->
  nonce = {}
  fn = ->
    return (nonce for x in [1, 2, 3])
  arrayEq [nonce, nonce, nonce], fn()
  fn = ->
    return [nonce for x in [1, 2, 3]][0]
  arrayEq [nonce, nonce, nonce], fn()
  fn = ->
    return [nonce for x in [1..3]][0]
  arrayEq [nonce, nonce, nonce], fn()

test 'implicit destructuring assignment in object of objects', ->
  a = {}
  b = {}
  c = {}
  obj =
    a: d: a
    b: d: b
    c: d: c
  result = ([y, z] for y, { d: z } of obj)
  arrayEq [['a', a], ['b', b], ['c', c]], result

test 'implicit destructuring assignment in array of objects', ->
  a = {}
  b = {}
  c = {}
  d = {}
  e = {}
  f = {}
  arr = [{ a: a, b: c: b }, { a: c, b: c: d }, { a: e, b: c: f }]
  result = ([y, z] for { a: y, b: { c: z } } in arr)
  arrayEq [[a, b], [c, d], [e, f]], result

test 'implicit destructuring assignment in array of arrays', ->
  a = {}
  b = {}
  c = {}
  d = {}
  e = {}
  f = {}
  arr = [[a, [b]], [c, [d]], [e, [f]]]
  result = ([y, z] for [y, [z]] in arr)
  arrayEq [[a, b], [c, d], [e, f]], result

test "issue #1124: don't assign a variable in two scopes", ->
  lista = [1, 2, 3, 4, 5]
  listb = (_i + 1 for _i in lista)
  arrayEq [2, 3, 4, 5, 6], listb

test '#1326: \`by\` value is uncached', ->
  a = [0, 1, 2]
  fi = gi = hi = 0
  f = -> ++fi
  g = -> ++gi
  h = -> ++hi

  forCompile = []
  rangeCompileSimple = []

  #exercises For.compile
  for v, i in a by f()
    forCompile.push i

  #exercises Range.compileSimple
  rangeCompileSimple = (i for i in [0..2] by g())

  arrayEq a, forCompile
  arrayEq a, rangeCompileSimple
  #exercises Range.compile
  eq "#{i for i in [0..2] by h()}", '0,1,2'

test '#1669: break/continue should skip the result only for that branch', ->
  ns = for n in [0..99]
    if n > 9
      break
    else if n & 1
      continue
    else
      n
  eq "#{ns}", '0,2,4,6,8'

  # \`else undefined\` is implied.
  ns = for n in [1..9]
    if n % 2
      continue unless n % 5
      n
  eq "#{ns}", '1,,3,,,7,,9'

  # Ditto.
  ns = for n in [1..9]
    switch
      when n % 2
        continue unless n % 5
        n
  eq "#{ns}", '1,,3,,,7,,9'

test '#1850: inner \`for\` should not be expression-ized if \`return\`ing', ->
  eq '3,4,5', do ->
    for a in [1..9] then for b in [1..9]
      c = Math.sqrt a * a + b * b
      return String [a, b, c] unless c % 1

test '#1910: loop index should be mutable within a loop iteration and immutable between loop iterations', ->
  n = 1
  iterations = 0
  arr = [0..n]
  for v, k in arr
    ++iterations
    v = k = 5
    eq 5, k
  eq 2, k
  eq 2, iterations

  iterations = 0
  for v in [0..n]
    ++iterations
  eq 2, k
  eq 2, iterations

  arr = ([v, v + 1] for v in [0..5])
  iterations = 0
  for [v0, v1], k in arr when v0
    k += 3
    ++iterations
  eq 6, k
  eq 5, iterations

test '#2007: Return object literal from comprehension', ->
  y = for x in [1, 2]
    foo: 'foo' + x
  eq 2, y.length
  eq 'foo1', y[0].foo
  eq 'foo2', y[1].foo

  x = 2
  y = while x
    x: --x
  eq 2, y.length
  eq 1, y[0].x
  eq 0, y[1].x

test '#2274: Allow @values as loop variables', ->
  obj =
    item: null
    method: ->
      for @item in [1, 2, 3]
        null
  eq obj.item, null
  obj.method()
  eq obj.item, 3

test '#4411: Allow @values as loop indices', ->
  obj =
    index: null
    get: -> @index
    method: ->
      @get() for _, @index in [1, 2, 3]
  eq obj.index, null
  arrayEq obj.method(), [0, 1, 2]
  eq obj.index, 3

test '#2525, #1187, #1208, #1758, looping over an array forwards', ->
  list = [0, 1, 2, 3, 4]

  ident = (x) -> x

  arrayEq (i for i in list), list

  arrayEq (index for i, index in list), list

  arrayEq (i for i in list by 1), list

  arrayEq (i for i in list by ident(1)), list

  arrayEq (i for i in list by ident(1) * 2), [0, 2, 4]

  arrayEq (index for i, index in list by ident(1) * 2), [0, 2, 4]

test '#2525, #1187, #1208, #1758, looping over an array backwards', ->
  list = [0, 1, 2, 3, 4]
  backwards = [4, 3, 2, 1, 0]

  ident = (x) -> x

  arrayEq (i for i in list by -1), backwards

  arrayEq (index for i, index in list by -1), backwards

  arrayEq (i for i in list by ident(-1)), backwards

  arrayEq (i for i in list by ident(-1) * 2), [4, 2, 0]

  arrayEq (index for i, index in list by ident(-1) * 2), [4, 2, 0]

test 'splats in destructuring in comprehensions', ->
  list = [[0, 1, 2], [2, 3, 4], [4, 5, 6]]
  arrayEq (seq for [rep, seq...] in list), [[1, 2], [3, 4], [5, 6]]

test '#156: expansion in destructuring in comprehensions', ->
  list = [[0, 1, 2], [2, 3, 4], [4, 5, 6]]
  arrayEq (last for [..., last] in list), [2, 4, 6]

test '#3778: Consistently always cache for loop range boundaries and steps, even
      if they are simple identifiers', ->
  a = 1
  arrayEq(
    [1, 2, 3]
    for n in [1, 2, 3] by a
      a = 4
      n
  )
  a = 1
  arrayEq(
    [1, 2, 3]
    for n in [1, 2, 3] by +a
      a = 4
      n
  )
  a = 1
  arrayEq(
    [1, 2, 3]
    for n in [a..3]
      a = 4
      n
  )
  a = 1
  arrayEq(
    [1, 2, 3]
    for n in [+a..3]
      a = 4
      n
  )
  a = 3
  arrayEq(
    [1, 2, 3]
    for n in [1..a]
      a = 4
      n
  )
  a = 3
  arrayEq(
    [1, 2, 3]
    for n in [1..+a]
      a = 4
      n
  )
  a = 1
  arrayEq(
    [1, 2, 3]
    for n in [1..3] by a
      a = 4
      n
  )
  a = 1
  arrayEq(
    [1, 2, 3]
    for n in [1..3] by +a
      a = 4
      n
  )

`;

exports[`control_flow.coffee 1`] = `
# Control Flow
# ------------

# * Conditionals
# * Loops
#   * For
#   * While
#   * Until
#   * Loop
# * Switch
# * Throw

# TODO: make sure postfix forms and expression coercion are properly tested

# shared identity function
id = (_) -> if arguments.length is 1 then _ else Array::slice.call(arguments)

# Conditionals

test "basic conditionals", ->
  if false
    ok false
  else if false
    ok false
  else
    ok true

  if true
    ok true
  else if true
    ok false
  else
    ok true

  unless true
    ok false
  else unless true
    ok false
  else
    ok true

  unless false
    ok true
  else unless false
    ok false
  else
    ok true

test "single-line conditional", ->
  if false then ok false else ok true
  unless false then ok true else ok false

test "nested conditionals", ->
  nonce = {}
  eq nonce, (if true
    unless false
      if false then false else
        if true
          nonce)

test "nested single-line conditionals", ->
  nonce = {}

  a = if false then undefined else b = if 0 then undefined else nonce
  eq nonce, a
  eq nonce, b

  c = if false then undefined else (if 0 then undefined else nonce)
  eq nonce, c

  d = if true then id(if false then undefined else nonce)
  eq nonce, d

test "empty conditional bodies", ->
  eq undefined, (if false
  else if false
  else)

test "conditional bodies containing only comments", ->
  eq undefined, (if true
    ###
    block comment
    ###
  else
    # comment
  )

  eq undefined, (if false
    # comment
  else if true
    ###
    block comment
    ###
  else)

test "return value of if-else is from the proper body", ->
  nonce = {}
  eq nonce, if false then undefined else nonce

test "return value of unless-else is from the proper body", ->
  nonce = {}
  eq nonce, unless true then undefined else nonce

test "assign inside the condition of a conditional statement", ->
  nonce = {}
  if a = nonce then 1
  eq nonce, a
  1 if b = nonce
  eq nonce, b


# Interactions With Functions

test "single-line function definition with single-line conditional", ->
  fn = -> if 1 < 0.5 then 1 else -1
  ok fn() is -1

test "function resturns conditional value with no \`else\`", ->
  fn = ->
    return if false then true
  eq undefined, fn()

test "function returns a conditional value", ->
  a = {}
  fnA = ->
    return if false then undefined else a
  eq a, fnA()

  b = {}
  fnB = ->
    return unless false then b else undefined
  eq b, fnB()

test "passing a conditional value to a function", ->
  nonce = {}
  eq nonce, id if false then undefined else nonce

test "unmatched \`then\` should catch implicit calls", ->
  a = 0
  trueFn = -> true
  if trueFn undefined then a++
  eq 1, a


# if-to-ternary

test "if-to-ternary with instanceof requires parentheses", ->
  nonce = {}
  eq nonce, (if {} instanceof Object
    nonce
  else
    undefined)

test "if-to-ternary as part of a larger operation requires parentheses", ->
  ok 2, 1 + if false then 0 else 1


# Odd Formatting

test "if-else indented within an assignment", ->
  nonce = {}
  result =
    if false
      undefined
    else
      nonce
  eq nonce, result

test "suppressed indentation via assignment", ->
  nonce = {}
  result =
    if      false then undefined
    else if no    then undefined
    else if 0     then undefined
    else if 1 < 0 then undefined
    else               id(
         if false then undefined
         else          nonce
    )
  eq nonce, result

test "tight formatting with leading \`then\`", ->
  nonce = {}
  eq nonce,
  if true
  then nonce
  else undefined

test "#738: inline function defintion", ->
  nonce = {}
  fn = if true then -> nonce
  eq nonce, fn()

test "#748: trailing reserved identifiers", ->
  nonce = {}
  obj = delete: true
  result = if obj.delete
    nonce
  eq nonce, result

test 'if-else within an assignment, condition parenthesized', ->
  result = if (1 is 1) then 'correct'
  eq result, 'correct'

  result = if ('whatever' ? no) then 'correct'
  eq result, 'correct'

  f = -> 'wrong'
  result = if (f?()) then 'correct' else 'wrong'
  eq result, 'correct'

# Postfix

test "#3056: multiple postfix conditionals", ->
  temp = 'initial'
  temp = 'ignored' unless true if false
  eq temp, 'initial'

# Loops

test "basic \`while\` loops", ->

  i = 5
  list = while i -= 1
    i * 2
  ok list.join(' ') is "8 6 4 2"

  i = 5
  list = (i * 3 while i -= 1)
  ok list.join(' ') is "12 9 6 3"

  i = 5
  func   = (num) -> i -= num
  assert = -> ok i < 5 > 0
  results = while func 1
    assert()
    i
  ok results.join(' ') is '4 3 2 1'

  i = 10
  results = while i -= 1 when i % 2 is 0
    i * 2
  ok results.join(' ') is '16 12 8 4'


test "Issue 759: \`if\` within \`while\` condition", ->

  2 while if 1 then 0


test "assignment inside the condition of a \`while\` loop", ->

  nonce = {}
  count = 1
  a = nonce while count--
  eq nonce, a
  count = 1
  while count--
    b = nonce
  eq nonce, b


test "While over break.", ->

  i = 0
  result = while i < 10
    i++
    break
  arrayEq result, []


test "While over continue.", ->

  i = 0
  result = while i < 10
    i++
    continue
  arrayEq result, []


test "Basic \`until\`", ->

  value = false
  i = 0
  results = until value
    value = true if i is 5
    i++
  ok i is 6


test "Basic \`loop\`", ->

  i = 5
  list = []
  loop
    i -= 1
    break if i is 0
    list.push i * 2
  ok list.join(' ') is '8 6 4 2'


test "break at the top level", ->
  for i in [1,2,3]
    result = i
    if i == 2
      break
  eq 2, result

test "break *not* at the top level", ->
  someFunc = ->
    i = 0
    while ++i < 3
      result = i
      break if i > 1
    result
  eq 2, someFunc()

# Switch

test "basic \`switch\`", ->

  num = 10
  result = switch num
    when 5 then false
    when 'a'
      true
      true
      false
    when 10 then true


    # Mid-switch comment with whitespace
    # and multi line
    when 11 then false
    else false

  ok result


  func = (num) ->
    switch num
      when 2, 4, 6
        true
      when 1, 3, 5
        false

  ok func(2)
  ok func(6)
  ok !func(3)
  eq func(8), undefined


test "Ensure that trailing switch elses don't get rewritten.", ->

  result = false
  switch "word"
    when "one thing"
      doSomething()
    else
      result = true unless false

  ok result

  result = false
  switch "word"
    when "one thing"
      doSomething()
    when "other thing"
      doSomething()
    else
      result = true unless false

  ok result


test "Should be able to handle switches sans-condition.", ->

  result = switch
    when null                     then 0
    when !1                       then 1
    when '' not of {''}           then 2
    when [] not instanceof Array  then 3
    when true is false            then 4
    when 'x' < 'y' > 'z'          then 5
    when 'a' in ['b', 'c']        then 6
    when 'd' in (['e', 'f'])      then 7
    else ok

  eq result, ok


test "Should be able to use \`@properties\` within the switch clause.", ->

  obj = {
    num: 101
    func: ->
      switch @num
        when 101 then '101!'
        else 'other'
  }

  ok obj.func() is '101!'


test "Should be able to use \`@properties\` within the switch cases.", ->

  obj = {
    num: 101
    func: (yesOrNo) ->
      result = switch yesOrNo
        when yes then @num
        else 'other'
      result
  }

  ok obj.func(yes) is 101


test "Switch with break as the return value of a loop.", ->

  i = 10
  results = while i > 0
    i--
    switch i % 2
      when 1 then i
      when 0 then break

  eq results.join(', '), '9, 7, 5, 3, 1'


test "Issue #997. Switch doesn't fallthrough.", ->

  val = 1
  switch true
    when true
      if false
        return 5
    else
      val = 2

  eq val, 1

# Throw

test "Throw should be usable as an expression.", ->
  try
    false or throw 'up'
    throw new Error 'failed'
  catch e
    ok e is 'up'


test "#2555, strange function if bodies", ->
  success = -> ok true
  failure = -> ok false

  success() if do ->
    yes

  failure() if try
    false

test "#1057: \`catch\` or \`finally\` in single-line functions", ->
  ok do -> try throw 'up' catch then yes
  ok do -> try yes finally 'nothing'

test "#2367: super in for-loop", ->
  class Foo
    sum: 0
    add: (val) -> @sum += val

  class Bar extends Foo
    add: (vals...) ->
      super val for val in vals
      @sum

  eq 10, (new Bar).add 2, 3, 5

test "#4267: lots of for-loops in the same scope", ->
  # This used to include the invalid JavaScript \`var do = 0\`.
  code = """
    do ->
      #{Array(200).join('for [0..0] then\\n  ')}
      true
  """
  ok CoffeeScript.eval(code)

# Test for issue #2342: Lexer: Inline \`else\` binds to wrong \`if\`/\`switch\`
test "#2343: if / then / if / then / else", ->
  a = b = yes
  c = e = g = no
  d = 1
  f = 2
  h = 3
  i = 4

  s = ->
    if a
      if b
        if c
          d
        else
          if e
            f
          else
            if g
              h
            else
              i

  t = ->
    if a then if b
      if c then d
      else if e
        f
      else if g
        h
      else
        i

  u = ->
    if a then if b
      if c then d else if e
        f
      else if g
        h
      else i

  v = ->
    if a then if b
      if c then d else if e then f
      else if g then h
      else i

  w = ->
    if a then if b
      if c then d
      else if e
          f
        else
          if g then h
          else i

  x = -> if a then if b then if c then d else if e then f else if g then h else i

  y = -> if a then if b then (if c then d else (if e then f else (if g then h else i)))

  eq 4, s()
  eq 4, t()
  eq 4, u()
  eq 4, v()
  eq 4, w()
  eq 4, x()
  eq 4, y()

  c = yes
  eq 1, s()
  eq 1, t()
  eq 1, u()
  eq 1, v()
  eq 1, w()
  eq 1, x()
  eq 1, y()

  b = no
  eq undefined, s()
  eq undefined, t()
  eq undefined, u()
  eq undefined, v()
  eq undefined, w()
  eq undefined, x()
  eq undefined, y()

test "#2343: if / then / if / then / else / else", ->
  a = b = yes
  c = e = g = no
  d = 1
  f = 2
  h = 3
  i = 4
  j = 5
  k = 6

  s = ->
    if a
      if b
        if c
          d
        else
          e
          if e
            f
          else
            if g
              h
            else
              i
      else
        j
    else
      k

  t = ->
    if a
      if b
        if c then d
        else if e
          f
        else if g
          h
        else
          i
      else
        j
    else
      k

  u = ->
    if a
      if b
        if c then d else if e
          f
        else if g
          h
        else i
      else j
    else k

  v = ->
    if a
      if b
        if c then d else if e then f
        else if g then h
        else i
      else j else k

  w = ->
    if a then if b
        if c then d
        else if e
            f
          else
            if g then h
            else i
    else j else k

  x = -> if a then if b then if c then d else if e then f else if g then h else i else j else k

  y = -> if a then (if b then (if c then d else (if e then f else (if g then h else i))) else j) else k

  eq 4, s()
  eq 4, t()
  eq 4, u()
  eq 4, v()
  eq 4, w()
  eq 4, x()
  eq 4, y()

  c = yes
  eq 1, s()
  eq 1, t()
  eq 1, u()
  eq 1, v()
  eq 1, w()
  eq 1, x()
  eq 1, y()

  b = no
  eq 5, s()
  eq 5, t()
  eq 5, u()
  eq 5, v()
  eq 5, w()
  eq 5, x()
  eq 5, y()

  a = no
  eq 6, s()
  eq 6, t()
  eq 6, u()
  eq 6, v()
  eq 6, w()
  eq 6, x()
  eq 6, y()


test "#2343: switch / when / then / if / then / else", ->
  a = b = yes
  c = e = g = no
  d = 1
  f = 2
  h = 3
  i = 4

  s = ->
    switch
      when a
        if b
          if c
            d
          else
            if e
              f
            else
              if g
                h
              else
                i


  t = ->
    switch
      when a then if b
        if c then d
        else if e
          f
        else if g
          h
        else
          i

  u = ->
    switch
      when a then if b then if c then d
      else if e then f
      else if g then h else i

  v = ->
    switch
      when a then if b then if c then d else if e then f
      else if g then h else i

  w = ->
    switch
      when a then if b then if c then d else if e then f
      else if g
        h
      else i

  x = ->
    switch
     when a then if b then if c then d else if e then f else if g then h else i

  y = -> switch
    when a then if b then (if c then d else (if e then f else (if g then h else i)))

  eq 4, s()
  eq 4, t()
  eq 4, u()
  eq 4, v()
  eq 4, w()
  eq 4, x()
  eq 4, y()

  c = yes
  eq 1, s()
  eq 1, t()
  eq 1, u()
  eq 1, v()
  eq 1, w()
  eq 1, x()
  eq 1, y()

  b = no
  eq undefined, s()
  eq undefined, t()
  eq undefined, u()
  eq undefined, v()
  eq undefined, w()
  eq undefined, x()
  eq undefined, y()

test "#2343: switch / when / then / if / then / else / else", ->
  a = b = yes
  c = e = g = no
  d = 1
  f = 2
  h = 3
  i = 4

  s = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
      else
        0

  t = ->
    switch
      when a
        if b
          if c then d
          else if e
            f
          else if g
            h
          else i
      else 0

  u = ->
    switch
      when a
        if b then if c
            d
          else if e
            f
          else if g
            h
          else i
      else 0

  v = ->
    switch
      when a
        if b then if c then d
        else if e
          f
        else if g
          h
        else i
      else 0

  w = ->
    switch
      when a
        if b then if c then d
        else if e then f
        else if g then h
        else i
      else 0

  x = ->
    switch
     when a
       if b then if c then d else if e then f else if g then h else i
     else 0

  y = -> switch
    when a
      if b then (if c then d else (if e then f else (if g then h else i)))
    else 0

  eq 4, s()
  eq 4, t()
  eq 4, u()
  eq 4, v()
  eq 4, w()
  eq 4, x()
  eq 4, y()

  c = yes
  eq 1, s()
  eq 1, t()
  eq 1, u()
  eq 1, v()
  eq 1, w()
  eq 1, x()
  eq 1, y()

  b = no
  eq undefined, s()
  eq undefined, t()
  eq undefined, u()
  eq undefined, v()
  eq undefined, w()
  eq undefined, x()
  eq undefined, y()

  b = yes
  a = no
  eq 0, s()
  eq 0, t()
  eq 0, u()
  eq 0, v()
  eq 0, w()
  eq 0, x()
  eq 0, y()

test "#2343: switch / when / then / if / then / else / else / else", ->
  a = b = yes
  c = e = g = no
  d = 1
  f = 2
  h = 3
  i = 4
  j = 5

  s = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
        else
          j
      else
        0

  t = ->
    switch
      when a
        if b
          if c then d
          else if e
            f
          else if g
            h
          else i
        else
          j
      else 0

  u = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else i
        else j
      else 0

  v = ->
    switch
      when a
        if b
          if c then d
          else if e
            f
          else if g then h
          else i
        else j
      else 0

  w = ->
    switch
      when a
        if b
          if c then d
          else if e then f
          else if g then h
          else i
        else j
      else 0

  x = ->
    switch
     when a
       if b then if c then d else if e then f else if g then h else i else j
     else 0

  y = -> switch
    when a
      if b then (if c then d else (if e then f else (if g then h else i))) else j
    else 0

  eq 4, s()
  eq 4, t()
  eq 4, u()
  eq 4, v()
  eq 4, w()
  eq 4, x()
  eq 4, y()

  c = yes
  eq 1, s()
  eq 1, t()
  eq 1, u()
  eq 1, v()
  eq 1, w()
  eq 1, x()
  eq 1, y()

  b = no
  eq 5, s()
  eq 5, t()
  eq 5, u()
  eq 5, v()
  eq 5, w()
  eq 5, x()
  eq 5, y()

  b = yes
  a = no
  eq 0, s()
  eq 0, t()
  eq 0, u()
  eq 0, v()
  eq 0, w()
  eq 0, x()
  eq 0, y()

# Test for issue #3921: Inline function without parentheses used in condition fails to compile
test "#3921: \`if\` & \`unless\`", ->
  a = {}
  eq a, if do -> no then undefined else a
  a1 = undefined
  if do -> yes
    a1 = a
  eq a, a1

  b = {}
  eq b, unless do -> no then b else undefined
  b1 = undefined
  unless do -> no
    b1 = b
  eq b, b1

  c = 0
  if (arg = undefined) -> yes then c++
  eq 1, c
  d = 0
  if (arg = undefined) -> yes
    d++
  eq 1, d

  answer = 'correct'
  eq answer, if do -> 'wrong' then 'correct' else 'wrong'
  eq answer, unless do -> no then 'correct' else 'wrong'
  statm1 = undefined
  if do -> 'wrong'
    statm1 = 'correct'
  eq answer, statm1
  statm2 = undefined
  unless do -> no
    statm2 = 'correct'
  eq answer, statm2

test "#3921: \`post if\`", ->
  a = {}
  eq a, a unless do -> no
  a1 = a if do -> yes
  eq a, a1

  c = 0
  c++ if (arg = undefined) -> yes
  eq 1, c
  d = 0
  d++ if (arg = undefined) -> yes
  eq 1, d

  answer = 'correct'
  eq answer, 'correct' if do -> 'wrong'
  eq answer, 'correct' unless do -> not 'wrong'
  statm1 = undefined
  statm1 = 'correct' if do -> 'wrong'
  eq answer, statm1
  statm2 = undefined
  statm2 = 'correct' unless do -> not 'wrong'
  eq answer, statm2

test "Issue 3921: \`while\` & \`until\`", ->
  i = 5
  assert = (a) -> ok 5 > a > 0
  result1 = while do (num = 1) -> i -= num
    assert i
    i
  ok result1.join(' ') is '4 3 2 1'

  j = 5
  result2 = until do (num = 1) -> (j -= num) < 1
    assert j
    j
  ok result2.join(' ') is '4 3 2 1'

test "#3921: \`switch\`", ->
  i = 1
  a = switch do (m = 2) -> i * m
    when 5 then "five"
    when 4 then "four"
    when 3 then "three"
    when 2 then "two"
    when 1 then "one"
    else "none"
  eq "two", a

  j = 12
  b = switch do (m = 3) -> j / m
    when 5 then "five"
    when 4 then "four"
    when 3 then "three"
    when 2 then "two"
    when 1 then "one"
    else "none"
  eq "four", b

  k = 20
  c = switch do (m = 4) -> k / m
    when 5 then "five"
    when 4 then "four"
    when 3 then "three"
    when 2 then "two"
    when 1 then "one"
    else "none"
  eq "five", c

# Issue #3909: backslash to break line in \`for\` loops throw syntax error
test "#3909: backslash \`for own ... of\`", ->

  obj = {a: 1, b: 2, c: 3}
  arr = ['a', 'b', 'c']

  x1 \\
    = ( key for own key of obj )
  arrayEq x1, arr

  x2 = \\
    ( key for own key of obj )
  arrayEq x2, arr

  x3 = ( \\
    key for own key of obj )
  arrayEq x3, arr

  x4 = ( key \\
    for own key of obj )
  arrayEq x4, arr

  x5 = ( key for own key of \\
    obj )
  arrayEq x5, arr

  x6 = ( key for own key of obj \\
    )
  arrayEq x6, arr

  x7 = ( key for \\
    own key of obj )
  arrayEq x7, arr

  x8 = ( key for own \\
    key of obj )
  arrayEq x8, arr

  x9 = ( key for own key \\
    of obj )
  arrayEq x9, arr


test "#3909: backslash \`for ... of\`", ->
  obj = {a: 1, b: 2, c: 3}
  arr = ['a', 'b', 'c']

  x1 \\
    = ( key for key of obj )
  arrayEq x1, arr

  x2 = \\
    ( key for key of obj )
  arrayEq x2, arr

  x3 = ( \\
    key for key of obj )
  arrayEq x3, arr

  x4 = ( key \\
    for key of obj )
  arrayEq x4, arr

  x5 = ( key for key of \\
    obj )
  arrayEq x5, arr

  x6 = ( key for key of obj \\
    )
  arrayEq x6, arr

  x7 = ( key for \\
    key of obj )
  arrayEq x7, arr

  x8 = ( key for key \\
    of obj )
  arrayEq x8, arr


test "#3909: backslash \`for ... in\`", ->
  arr = ['a', 'b', 'c']

  x1 \\
    = ( key for key in arr )
  arrayEq x1, arr

  x2 = \\
    ( key for key in arr )
  arrayEq x2, arr

  x3 = ( \\
    key for key in arr )
  arrayEq x3, arr

  x4 = ( key \\
    for key in arr )
  arrayEq x4, arr

  x5 = ( key for key in \\
    arr )
  arrayEq x5, arr

  x6 = ( key for key in arr \\
    )
  arrayEq x6, arr

  x7 = ( key for \\
    key in arr )
  arrayEq x7, arr

  x8 = ( key for key \\
    in arr )
  arrayEq x8, arr

if a then b else if c then d else if e then f else g

if no
  1
else if yes
  2

test "#4898: Lexer: backslash line continuation is inconsistent", ->
  if ( \\
      false \\
      or \\
      true \\
    )
    a = 42

  eq a, 42

  if ( \\
      false \\
      or \\
      true \\
  )
    b = 42

  eq b, 42

  if ( \\
            false \\
         or \\
   true \\
  )
    c = 42

  eq c, 42

  if \\
   false \\
        or \\
   true
    d = 42

  eq d, 42

  if \\
              false or \\
  true
    e = 42

  eq e, 42

  if \\
       false or \\
    true \\
       then \\
   f = 42 \\
   else
     f = 24

  eq f, 42
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Control Flow
# ------------

# * Conditionals
# * Loops
#   * For
#   * While
#   * Until
#   * Loop
# * Switch
# * Throw

# TODO: make sure postfix forms and expression coercion are properly tested

# shared identity function
id = (_) -> if arguments.length is 1 then _ else Array::slice.call arguments

# Conditionals

test 'basic conditionals', ->
  if false
    ok false
  else if false
    ok false
  else
    ok true

  if true
    ok true
  else if true
    ok false
  else
    ok true

  unless true
    ok false
  else unless true
    ok false
  else
    ok true

  unless false
    ok true
  else unless false
    ok false
  else
    ok true

test 'single-line conditional', ->
  if false then ok false else ok true
  unless false then ok true else ok false

test 'nested conditionals', ->
  nonce = {}
  eq nonce,
    if true
      unless false
        if false
          false
        else
          if true
            nonce

test 'nested single-line conditionals', ->
  nonce = {}

  a = if false then undefined else (b = if 0 then undefined else nonce)
  eq nonce, a
  eq nonce, b

  c = if false then undefined else if 0 then undefined else nonce
  eq nonce, c

  d = if true then id (if false then undefined else nonce)
  eq nonce, d

test 'empty conditional bodies', ->
  eq undefined,
    if false
    else if false
    else

test 'conditional bodies containing only comments', ->
  eq undefined,
    if true
      ###
      block comment
      ###
    else
      # comment

  eq undefined,
    if false
      # comment
    else if true
      ###
      block comment
      ###
    else

test 'return value of if-else is from the proper body', ->
  nonce = {}
  eq nonce, if false then undefined else nonce

test 'return value of unless-else is from the proper body', ->
  nonce = {}
  eq nonce, unless true then undefined else nonce

test 'assign inside the condition of a conditional statement', ->
  nonce = {}
  if a = nonce then 1
  eq nonce, a
  1 if b = nonce
  eq nonce, b

# Interactions With Functions

test 'single-line function definition with single-line conditional', ->
  fn = -> if 1 < 0.5 then 1 else -1
  ok fn() is -1

test 'function resturns conditional value with no \`else\`', ->
  fn = ->
    return (if false then true)
  eq undefined, fn()

test 'function returns a conditional value', ->
  a = {}
  fnA = ->
    return (if false then undefined else a)
  eq a, fnA()

  b = {}
  fnB = ->
    return (unless false then b else undefined)
  eq b, fnB()

test 'passing a conditional value to a function', ->
  nonce = {}
  eq nonce, id if false then undefined else nonce

test 'unmatched \`then\` should catch implicit calls', ->
  a = 0
  trueFn = -> true
  if trueFn undefined then a++
  eq 1, a

# if-to-ternary

test 'if-to-ternary with instanceof requires parentheses', ->
  nonce = {}
  eq nonce,
    if {} instanceof Object
      nonce
    else
      undefined

test 'if-to-ternary as part of a larger operation requires parentheses', ->
  ok 2, 1 + (if false then 0 else 1)

# Odd Formatting

test 'if-else indented within an assignment', ->
  nonce = {}
  result = if false
    undefined
  else
    nonce
  eq nonce, result

test 'suppressed indentation via assignment', ->
  nonce = {}
  result = if false
    undefined
  else if no
    undefined
  else if 0
    undefined
  else if 1 < 0
    undefined
  else
    id if false then undefined else nonce
  eq nonce, result

test 'tight formatting with leading \`then\`', ->
  nonce = {}
  eq nonce,
    if true
      nonce
    else
      undefined

test '#738: inline function defintion', ->
  nonce = {}
  fn = if true then -> nonce
  eq nonce, fn()

test '#748: trailing reserved identifiers', ->
  nonce = {}
  obj = delete: true
  result = if obj.delete
    nonce
  eq nonce, result

test 'if-else within an assignment, condition parenthesized', ->
  result = if 1 is 1 then 'correct'
  eq result, 'correct'

  result = if 'whatever' ? no then 'correct'
  eq result, 'correct'

  f = -> 'wrong'
  result = if f?() then 'correct' else 'wrong'
  eq result, 'correct'

# Postfix

test '#3056: multiple postfix conditionals', ->
  temp = 'initial'
  temp = 'ignored' unless true if false
  eq temp, 'initial'

# Loops

test 'basic \`while\` loops', ->
  i = 5
  list = while i -= 1
    i * 2
  ok list.join(' ') is '8 6 4 2'

  i = 5
  list = (i * 3 while i -= 1)
  ok list.join(' ') is '12 9 6 3'

  i = 5
  func = (num) -> i -= num
  assert = -> ok i < 5 > 0
  results = while func 1
    assert()
    i
  ok results.join(' ') is '4 3 2 1'

  i = 10
  results = while i -= 1 when (i % 2) is 0
    i * 2
  ok results.join(' ') is '16 12 8 4'

test 'Issue 759: \`if\` within \`while\` condition', ->
  2 while (if 1 then 0)

test 'assignment inside the condition of a \`while\` loop', ->
  nonce = {}
  count = 1
  a = nonce while count--
  eq nonce, a
  count = 1
  while count--
    b = nonce
  eq nonce, b

test 'While over break.', ->
  i = 0
  result = while i < 10
    i++
    break
  arrayEq result, []

test 'While over continue.', ->
  i = 0
  result = while i < 10
    i++
    continue
  arrayEq result, []

test 'Basic \`until\`', ->
  value = false
  i = 0
  results = until value
    value = true if i is 5
    i++
  ok i is 6

test 'Basic \`loop\`', ->
  i = 5
  list = []
  loop
    i -= 1
    break if i is 0
    list.push i * 2
  ok list.join(' ') is '8 6 4 2'

test 'break at the top level', ->
  for i in [1, 2, 3]
    result = i
    if i == 2
      break
  eq 2, result

test 'break *not* at the top level', ->
  someFunc = ->
    i = 0
    while ++i < 3
      result = i
      break if i > 1
    result
  eq 2, someFunc()

# Switch

test 'basic \`switch\`', ->
  num = 10
  result = switch num
    when 5 then false
    when 'a'
      true
      true
      false
    when 10 then true

    # Mid-switch comment with whitespace
    # and multi line
    when 11 then false
    else false

  ok result

  func = (num) ->
    switch num
      when 2, 4, 6
        true
      when 1, 3, 5
        false

  ok func 2
  ok func 6
  ok !func 3
  eq func(8), undefined

test "Ensure that trailing switch elses don't get rewritten.", ->
  result = false
  switch 'word'
    when 'one thing'
      doSomething()
    else
      result = true unless false

  ok result

  result = false
  switch 'word'
    when 'one thing'
      doSomething()
    when 'other thing'
      doSomething()
    else
      result = true unless false

  ok result

test 'Should be able to handle switches sans-condition.', ->
  result = switch
    when null then 0
    when !1 then 1
    when '' not of { '' } then 2
    when [] not instanceof Array then 3
    when true is false then 4
    when 'x' < 'y' > 'z' then 5
    when 'a' in ['b', 'c'] then 6
    when 'd' in ['e', 'f'] then 7
    else ok

  eq result, ok

test 'Should be able to use \`@properties\` within the switch clause.', ->
  obj =
    num: 101
    func: ->
      switch @num
        when 101 then '101!'
        else 'other'

  ok obj.func() is '101!'

test 'Should be able to use \`@properties\` within the switch cases.', ->
  obj =
    num: 101
    func: (yesOrNo) ->
      result = switch yesOrNo
        when yes then @num
        else 'other'
      result

  ok obj.func(yes) is 101

test 'Switch with break as the return value of a loop.', ->
  i = 10
  results = while i > 0
    i--
    switch i % 2
      when 1 then i
      when 0 then break

  eq results.join(', '), '9, 7, 5, 3, 1'

test "Issue #997. Switch doesn't fallthrough.", ->
  val = 1
  switch true
    when true
      if false
        return 5
    else
      val = 2

  eq val, 1

# Throw

test 'Throw should be usable as an expression.', ->
  try
    false or throw 'up'
    throw new Error 'failed'
  catch e
    ok e is 'up'

test '#2555, strange function if bodies', ->
  success = -> ok true
  failure = -> ok false

  success() if do ->
    yes

  failure() if (
    try
      false
  )

test '#1057: \`catch\` or \`finally\` in single-line functions', ->
  ok do -> try throw 'up' catch then yes
  ok do -> try yes finally 'nothing'

test '#2367: super in for-loop', ->
  class Foo
    sum: 0
    add: (val) -> @sum += val

  class Bar extends Foo
    add: (vals...) ->
      super val for val in vals
      @sum

  eq 10, new Bar().add 2, 3, 5

test '#4267: lots of for-loops in the same scope', ->
  # This used to include the invalid JavaScript \`var do = 0\`.
  code = """
    do ->
      #{Array(200).join 'for [0..0] then\\n  '}
      true
  """
  ok CoffeeScript.eval code

# Test for issue #2342: Lexer: Inline \`else\` binds to wrong \`if\`/\`switch\`
test '#2343: if / then / if / then / else', ->
  a = b = yes
  c = e = g = no
  d = 1
  f = 2
  h = 3
  i = 4

  s = ->
    if a
      if b
        if c
          d
        else
          if e
            f
          else
            if g
              h
            else
              i

  t = ->
    if a
      if b
        if c
          d
        else if e
          f
        else if g
          h
        else
          i

  u = ->
    if a
      if b
        if c
          d
        else if e
          f
        else if g
          h
        else
          i

  v = ->
    if a
      if b
        if c then d else if e then f else if g then h else i

  w = ->
    if a
      if b
        if c
          d
        else if e
          f
        else
          if g then h else i

  x = ->
    if a then if b then if c then d else if e then f else if g then h else i

  y = ->
    if a then if b then (if c then d else if e then f else if g then h else i)

  eq 4, s()
  eq 4, t()
  eq 4, u()
  eq 4, v()
  eq 4, w()
  eq 4, x()
  eq 4, y()

  c = yes
  eq 1, s()
  eq 1, t()
  eq 1, u()
  eq 1, v()
  eq 1, w()
  eq 1, x()
  eq 1, y()

  b = no
  eq undefined, s()
  eq undefined, t()
  eq undefined, u()
  eq undefined, v()
  eq undefined, w()
  eq undefined, x()
  eq undefined, y()

test '#2343: if / then / if / then / else / else', ->
  a = b = yes
  c = e = g = no
  d = 1
  f = 2
  h = 3
  i = 4
  j = 5
  k = 6

  s = ->
    if a
      if b
        if c
          d
        else
          e
          if e
            f
          else
            if g
              h
            else
              i
      else
        j
    else
      k

  t = ->
    if a
      if b
        if c
          d
        else if e
          f
        else if g
          h
        else
          i
      else
        j
    else
      k

  u = ->
    if a
      if b
        if c
          d
        else if e
          f
        else if g
          h
        else
          i
      else
        j
    else
      k

  v = ->
    if a
      if b
        if c then d else if e then f else if g then h else i
      else
        j
    else
      k

  w = ->
    if a
      if b
        if c
          d
        else if e
          f
        else
          if g then h else i
      else
        j
    else
      k

  x = ->
    if a
      if b then if c then d else if e then f else if g then h else i else j
    else
      k

  y = ->
    if a
      if b then (if c then d else if e then f else if g then h else i) else j
    else
      k

  eq 4, s()
  eq 4, t()
  eq 4, u()
  eq 4, v()
  eq 4, w()
  eq 4, x()
  eq 4, y()

  c = yes
  eq 1, s()
  eq 1, t()
  eq 1, u()
  eq 1, v()
  eq 1, w()
  eq 1, x()
  eq 1, y()

  b = no
  eq 5, s()
  eq 5, t()
  eq 5, u()
  eq 5, v()
  eq 5, w()
  eq 5, x()
  eq 5, y()

  a = no
  eq 6, s()
  eq 6, t()
  eq 6, u()
  eq 6, v()
  eq 6, w()
  eq 6, x()
  eq 6, y()

test '#2343: switch / when / then / if / then / else', ->
  a = b = yes
  c = e = g = no
  d = 1
  f = 2
  h = 3
  i = 4

  s = ->
    switch
      when a
        if b
          if c
            d
          else
            if e
              f
            else
              if g
                h
              else
                i

  t = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i

  u = ->
    switch
      when a then if b then if c then d else if e then f else if g then h else i

  v = ->
    switch
      when a then if b then if c then d else if e then f else if g then h else i

  w = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i

  x = ->
    switch
      when a then if b then if c then d else if e then f else if g then h else i

  y = ->
    switch
      when a
        if b then (if c then d else if e then f else if g then h else i)

  eq 4, s()
  eq 4, t()
  eq 4, u()
  eq 4, v()
  eq 4, w()
  eq 4, x()
  eq 4, y()

  c = yes
  eq 1, s()
  eq 1, t()
  eq 1, u()
  eq 1, v()
  eq 1, w()
  eq 1, x()
  eq 1, y()

  b = no
  eq undefined, s()
  eq undefined, t()
  eq undefined, u()
  eq undefined, v()
  eq undefined, w()
  eq undefined, x()
  eq undefined, y()

test '#2343: switch / when / then / if / then / else / else', ->
  a = b = yes
  c = e = g = no
  d = 1
  f = 2
  h = 3
  i = 4

  s = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
      else
        0

  t = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
      else 0

  u = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
      else 0

  v = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
      else 0

  w = ->
    switch
      when a
        if b then if c then d else if e then f else if g then h else i
      else 0

  x = ->
    switch
      when a
        if b then if c then d else if e then f else if g then h else i
      else 0

  y = ->
    switch
      when a
        if b then (if c then d else if e then f else if g then h else i)
      else 0

  eq 4, s()
  eq 4, t()
  eq 4, u()
  eq 4, v()
  eq 4, w()
  eq 4, x()
  eq 4, y()

  c = yes
  eq 1, s()
  eq 1, t()
  eq 1, u()
  eq 1, v()
  eq 1, w()
  eq 1, x()
  eq 1, y()

  b = no
  eq undefined, s()
  eq undefined, t()
  eq undefined, u()
  eq undefined, v()
  eq undefined, w()
  eq undefined, x()
  eq undefined, y()

  b = yes
  a = no
  eq 0, s()
  eq 0, t()
  eq 0, u()
  eq 0, v()
  eq 0, w()
  eq 0, x()
  eq 0, y()

test '#2343: switch / when / then / if / then / else / else / else', ->
  a = b = yes
  c = e = g = no
  d = 1
  f = 2
  h = 3
  i = 4
  j = 5

  s = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
        else
          j
      else
        0

  t = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
        else
          j
      else 0

  u = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
        else
          j
      else 0

  v = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
        else
          j
      else 0

  w = ->
    switch
      when a
        if b
          if c then d else if e then f else if g then h else i
        else
          j
      else 0

  x = ->
    switch
      when a
        if b then if c then d else if e then f else if g then h else i else j
      else 0

  y = ->
    switch
      when a
        if b then (if c then d else if e then f else if g then h else i) else j
      else 0

  eq 4, s()
  eq 4, t()
  eq 4, u()
  eq 4, v()
  eq 4, w()
  eq 4, x()
  eq 4, y()

  c = yes
  eq 1, s()
  eq 1, t()
  eq 1, u()
  eq 1, v()
  eq 1, w()
  eq 1, x()
  eq 1, y()

  b = no
  eq 5, s()
  eq 5, t()
  eq 5, u()
  eq 5, v()
  eq 5, w()
  eq 5, x()
  eq 5, y()

  b = yes
  a = no
  eq 0, s()
  eq 0, t()
  eq 0, u()
  eq 0, v()
  eq 0, w()
  eq 0, x()
  eq 0, y()

# Test for issue #3921: Inline function without parentheses used in condition fails to compile
test '#3921: \`if\` & \`unless\`', ->
  a = {}
  eq a, if do -> no then undefined else a
  a1 = undefined
  if do -> yes
    a1 = a
  eq a, a1

  b = {}
  eq b, unless do -> no then b else undefined
  b1 = undefined
  unless do -> no
    b1 = b
  eq b, b1

  c = 0
  if (arg = undefined) -> yes then c++
  eq 1, c
  d = 0
  if (arg = undefined) -> yes
    d++
  eq 1, d

  answer = 'correct'
  eq answer, if do -> 'wrong' then 'correct' else 'wrong'
  eq answer, unless do -> no then 'correct' else 'wrong'
  statm1 = undefined
  if do -> 'wrong'
    statm1 = 'correct'
  eq answer, statm1
  statm2 = undefined
  unless do -> no
    statm2 = 'correct'
  eq answer, statm2

test '#3921: \`post if\`', ->
  a = {}
  eq a, a unless do -> no
  a1 = a if do -> yes
  eq a, a1

  c = 0
  c++ if (arg = undefined) -> yes
  eq 1, c
  d = 0
  d++ if (arg = undefined) -> yes
  eq 1, d

  answer = 'correct'
  eq answer, 'correct' if do -> 'wrong'
  eq answer, 'correct' unless do -> not 'wrong'
  statm1 = undefined
  statm1 = 'correct' if do -> 'wrong'
  eq answer, statm1
  statm2 = undefined
  statm2 = 'correct' unless do -> not 'wrong'
  eq answer, statm2

test 'Issue 3921: \`while\` & \`until\`', ->
  i = 5
  assert = (a) -> ok 5 > a > 0
  result1 = while do (num = 1) -> i -= num
    assert i
    i
  ok result1.join(' ') is '4 3 2 1'

  j = 5
  result2 = until do (num = 1) -> (j -= num) < 1
    assert j
    j
  ok result2.join(' ') is '4 3 2 1'

test '#3921: \`switch\`', ->
  i = 1
  a = switch do (m = 2) -> i * m
    when 5 then 'five'
    when 4 then 'four'
    when 3 then 'three'
    when 2 then 'two'
    when 1 then 'one'
    else 'none'
  eq 'two', a

  j = 12
  b = switch do (m = 3) -> j / m
    when 5 then 'five'
    when 4 then 'four'
    when 3 then 'three'
    when 2 then 'two'
    when 1 then 'one'
    else 'none'
  eq 'four', b

  k = 20
  c = switch do (m = 4) -> k / m
    when 5 then 'five'
    when 4 then 'four'
    when 3 then 'three'
    when 2 then 'two'
    when 1 then 'one'
    else 'none'
  eq 'five', c

# Issue #3909: backslash to break line in \`for\` loops throw syntax error
test '#3909: backslash \`for own ... of\`', ->
  obj = a: 1, b: 2, c: 3
  arr = ['a', 'b', 'c']

  x1 = (key for own key of obj)
  arrayEq x1, arr

  x2 = (key for own key of obj)
  arrayEq x2, arr

  x3 = (key for own key of obj)
  arrayEq x3, arr

  x4 = (key for own key of obj)
  arrayEq x4, arr

  x5 = (key for own key of obj)
  arrayEq x5, arr

  x6 = (key for own key of obj)
  arrayEq x6, arr

  x7 = (key for own key of obj)
  arrayEq x7, arr

  x8 = (key for own key of obj)
  arrayEq x8, arr

  x9 = (key for own key of obj)
  arrayEq x9, arr

test '#3909: backslash \`for ... of\`', ->
  obj = a: 1, b: 2, c: 3
  arr = ['a', 'b', 'c']

  x1 = (key for key of obj)
  arrayEq x1, arr

  x2 = (key for key of obj)
  arrayEq x2, arr

  x3 = (key for key of obj)
  arrayEq x3, arr

  x4 = (key for key of obj)
  arrayEq x4, arr

  x5 = (key for key of obj)
  arrayEq x5, arr

  x6 = (key for key of obj)
  arrayEq x6, arr

  x7 = (key for key of obj)
  arrayEq x7, arr

  x8 = (key for key of obj)
  arrayEq x8, arr

test '#3909: backslash \`for ... in\`', ->
  arr = ['a', 'b', 'c']

  x1 = (key for key in arr)
  arrayEq x1, arr

  x2 = (key for key in arr)
  arrayEq x2, arr

  x3 = (key for key in arr)
  arrayEq x3, arr

  x4 = (key for key in arr)
  arrayEq x4, arr

  x5 = (key for key in arr)
  arrayEq x5, arr

  x6 = (key for key in arr)
  arrayEq x6, arr

  x7 = (key for key in arr)
  arrayEq x7, arr

  x8 = (key for key in arr)
  arrayEq x8, arr

if a then b else if c then d else if e then f else g

if no
  1
else if yes
  2

test '#4898: Lexer: backslash line continuation is inconsistent', ->
  if false or true
    a = 42

  eq a, 42

  if false or true
    b = 42

  eq b, 42

  if false or true
    c = 42

  eq c, 42

  if false or true
    d = 42

  eq d, 42

  if false or true
    e = 42

  eq e, 42

  if false or true
    f = 42
  else
    f = 24

  eq f, 42

`;

exports[`csx.coffee 1`] = `
# We usually do not check the actual JS output from the compiler, but since
# JSX is not natively supported by Node, we do it in this case.

test 'self closing', ->
  eqJS '''
    <div />
  ''', '''
    <div />;
  '''

test 'self closing formatting', ->
  eqJS '''
    <div/>
  ''', '''
    <div />;
  '''

test 'self closing multiline', ->
  eqJS '''
    <div
    />
  ''', '''
    <div />;
  '''

test 'regex attribute', ->
  eqJS '''
    <div x={/>asds/} />
  ''', '''
    <div x={/>asds/} />;
  '''

test 'string attribute', ->
  eqJS '''
    <div x="a" />
  ''', '''
    <div x="a" />;
  '''

test 'simple attribute', ->
  eqJS '''
    <div x={42} />
  ''', '''
    <div x={42} />;
  '''

test 'assignment attribute', ->
  eqJS '''
    <div x={y = 42} />
  ''', '''
    var y;

    <div x={y = 42} />;
  '''

test 'object attribute', ->
  eqJS '''
    <div x={{y: 42}} />
  ''', '''
    <div x={{
        y: 42
      }} />;
  '''

test 'attribute without value', ->
  eqJS '''
    <div checked x="hello" />
  ''', '''
    <div checked x="hello" />;
  '''

test 'paired', ->
  eqJS '''
    <div></div>
  ''', '''
    <div></div>;
  '''

test 'simple content', ->
  eqJS '''
    <div>Hello world</div>
  ''', '''
    <div>Hello world</div>;
  '''

test 'content interpolation', ->
  eqJS '''
    <div>Hello {42}</div>
  ''', '''
    <div>Hello {42}</div>;
  '''

test 'nested tag', ->
  eqJS '''
    <div><span /></div>
  ''', '''
    <div><span /></div>;
  '''

test 'tag inside interpolation formatting', ->
  eqJS '''
    <div>Hello {<span />}</div>
  ''', '''
    <div>Hello <span /></div>;
  '''

test 'tag inside interpolation, tags are callable', ->
  eqJS '''
    <div>Hello {<span /> x}</div>
  ''', '''
    <div>Hello {<span />(x)}</div>;
  '''

test 'tags inside interpolation, tags trigger implicit calls', ->
  eqJS '''
    <div>Hello {f <span />}</div>
  ''', '''
    <div>Hello {f(<span />)}</div>;
  '''

test 'regex in interpolation', ->
  eqJS '''
    <div x={/>asds/}><div />{/>asdsad</}</div>
  ''', '''
    <div x={/>asds/}><div />{/>asdsad</}</div>;
  '''

test 'interpolation in string attribute value', ->
  eqJS '''
    <div x="Hello #{world}" />
  ''', '''
    <div x={\`Hello \${world}\`} />;
  '''

# Unlike in \`coffee-react-transform\`.
test 'bare numbers not allowed', ->
  throws -> CoffeeScript.compile '<div x=3 />'

test 'bare expressions not allowed', ->
  throws -> CoffeeScript.compile '<div x=y />'

test 'bare complex expressions not allowed', ->
  throws -> CoffeeScript.compile '<div x=f(3) />'

test 'unescaped opening tag angle bracket disallowed', ->
  throws -> CoffeeScript.compile '<Person><<</Person>'

test 'space around equal sign', ->
  eqJS '''
    <div popular = "yes" />
  ''', '''
    <div popular="yes" />;
  '''

# The following tests were adopted from James Friend’s
# [https://github.com/jsdf/coffee-react-transform](https://github.com/jsdf/coffee-react-transform).

test 'ambiguous tag-like expression', ->
  throws -> CoffeeScript.compile 'x = a <b > c'

test 'ambiguous tag', ->
  eqJS '''
    a <b > c </b>
  ''', '''
    a(<b> c </b>);
  '''

test 'escaped CoffeeScript attribute', ->
  eqJS '''
    <Person name={if test() then 'yes' else 'no'} />
  ''', '''
    <Person name={test() ? 'yes' : 'no'} />;
  '''

test 'escaped CoffeeScript attribute over multiple lines', ->
  eqJS '''
    <Person name={
      if test()
        'yes'
      else
        'no'
    } />
  ''', '''
    <Person name={test() ? 'yes' : 'no'} />;
  '''

test 'multiple line escaped CoffeeScript with nested CSX', ->
  eqJS '''
    <Person name={
      if test()
        'yes'
      else
        'no'
    }>
    {

      for n in a
        <div> a
          asf
          <li xy={"as"}>{ n+1 }<a /> <a /> </li>
        </div>
    }

    </Person>
  ''', '''
    var n;

    <Person name={test() ? 'yes' : 'no'}>
    {(function() {
      var i, len, results;
      results = [];
      for (i = 0, len = a.length; i < len; i++) {
        n = a[i];
        results.push(<div> a
          asf
          <li xy={"as"}>{n + 1}<a /> <a /> </li>
        </div>);
      }
      return results;
    })()}

    </Person>;
  '''

test 'nested CSX within an attribute, with object attr value', ->
  eqJS '''
    <Company>
      <Person name={<NameComponent attr3={ {'a': {}, b: '{'} } />} />
    </Company>
  ''', '''
    <Company>
      <Person name={<NameComponent attr3={{
          'a': {},
          b: '{'
        }} />} />
    </Company>;
  '''

test 'complex nesting', ->
  eqJS '''
    <div code={someFunc({a:{b:{}, C:'}{}{'}})} />
  ''', '''
    <div code={someFunc({
        a: {
          b: {},
          C: '}{}{'
        }
      })} />;
  '''

test 'multiline tag with nested CSX within an attribute', ->
  eqJS '''
    <Person
      name={
        name = formatName(user.name)
        <NameComponent name={name.toUppercase()} />
      }
    >
      blah blah blah
    </Person>
  ''', '''
    var name;

    <Person name={name = formatName(user.name), <NameComponent name={name.toUppercase()} />}>
      blah blah blah
    </Person>;
  '''

test 'escaped CoffeeScript with nested object literals', ->
  eqJS '''
    <Person>
      blah blah blah blah blah blah blah blah blah blah blah blah blah {
        {'a' : {}, 'asd': 'asd'}
      }
    </Person>
  ''', '''
    <Person>
      blah blah blah blah blah blah blah blah blah blah blah blah blah {{
      'a': {},
      'asd': 'asd'
    }}
    </Person>;
  '''

test 'multiline tag attributes with escaped CoffeeScript', ->
  eqJS '''
    <Person name={if isActive() then 'active' else 'inactive'}
    someattr='on new line' />
  ''', '''
    <Person name={isActive() ? 'active' : 'inactive'} someattr='on new line' />;
  '''

test 'lots of attributes', ->
  eqJS '''
    <Person eyes={2} friends={getFriends()} popular = "yes"
    active={ if isActive() then 'active' else 'inactive' } data-attr='works' checked check={me_out}
    />
  ''', '''
    <Person eyes={2} friends={getFriends()} popular="yes" active={isActive() ? 'active' : 'inactive'} data-attr='works' checked check={me_out} />;
  '''

# TODO: fix partially indented CSX
# test 'multiline elements', ->
#   eqJS '''
#     <div something={
#       do ->
#         test = /432/gm # this is a regex
#         6 /432/gm # this is division
#     }
#     >
#     <div>
#     <div>
#     <div>
#       <article name={ new Date() } number={203}
#        range={getRange()}
#       >
#       </article>
#     </div>
#     </div>
#     </div>
#     </div>
#   ''', '''
#     bla
#   '''

test 'complex regex', ->
  eqJS '''
    <Person />
    /\\\\/\\\\/<Person \\\\/>\\\\>\\\\//
  ''', '''
    <Person />;

    /\\\\/\\\\/<Person \\\\/>\\\\>\\\\//;
  '''

test 'heregex', ->
  eqJS '''
    test = /432/gm # this is a regex
    6 /432/gm # this is division
    <Tag>
    {test = /<Tag>/} this is a regex containing something which looks like a tag
    </Tag>
    <Person />
    REGEX = /// ^
      (/ (?! [\\s=] )   # comment comment <comment>comment</comment>
      [^ [ / \\n \\\\ ]*  # comment comment
      (?:
        <Tag />
        (?: \\\\[\\s\\S]   # comment comment
          | \\[         # comment comment
               [^ \\] \\n \\\\ ]*
               (?: \\\\[\\s\\S] [^ \\] \\n \\\\ ]* )*
               <Tag>tag</Tag>
             ]
        ) [^ [ / \\n \\\\ ]*
      )*
      /) ([imgy]{0,4}) (?!\\w)
    ///
    <Person />
  ''', '''
    var REGEX, test;

    test = /432/gm; // this is a regex

    6 / 432 / gm; // this is division

    <Tag>
    {(test = /<Tag>/)} this is a regex containing something which looks like a tag
    </Tag>;

    <Person />;

    REGEX = /^(\\\\/(?![s=])[^[\\\\/ ]*(?:<Tag\\\\/>(?:\\\\[sS]|[[^] ]*(?:\\\\[sS][^] ]*)*<Tag>tag<\\\\/Tag>])[^[\\\\/ ]*)*\\\\/)([imgy]{0,4})(?!w)/; // comment comment <comment>comment</comment>
    // comment comment
    // comment comment
    // comment comment

    <Person />;
  '''

test 'comment within CSX is not treated as comment', ->
  eqJS '''
    <Person>
    # i am not a comment
    </Person>
  ''', '''
    <Person>
    # i am not a comment
    </Person>;
  '''

test 'comment at start of CSX escape', ->
  eqJS '''
    <Person>
    {# i am a comment
      "i am a string"
    }
    </Person>
  ''', '''
    <Person>
    {// i am a comment
    "i am a string"}
    </Person>;
  '''

test 'comment at end of CSX escape', ->
  eqJS '''
    <Person>
    {"i am a string"
    # i am a comment
    }
    </Person>
  ''', '''
    <Person>
    {"i am a string"
    // i am a comment
    }
    </Person>;
  '''

test 'CSX comment cannot be used inside interpolation', ->
  throws -> CoffeeScript.compile '''
    <Person>
    {# i am a comment}
    </Person>
  '''

test 'comment syntax cannot be used inline', ->
  throws -> CoffeeScript.compile '''
    <Person>{#comment inline}</Person>
  '''

test 'string within CSX is ignored', ->
  eqJS '''
    <Person> "i am not a string" 'nor am i' </Person>
  ''', '''
    <Person> "i am not a string" 'nor am i' </Person>;
  '''

test 'special chars within CSX are ignored', ->
  eqJS """
    <Person> a,/';][' a\\''@$%^&˚¬∑˜˚∆å∂¬˚*()*&^%$>> '"''"'''\\'\\'m' i </Person>
  """, """
    <Person> a,/';][' a''@$%^&˚¬∑˜˚∆å∂¬˚*()*&^%$>> '"''"'''''m' i </Person>;
  """

test 'html entities (name, decimal, hex) within CSX', ->
  eqJS '''
    <Person>  &&&&euro;  &#8364; &#x20AC;;; </Person>
  ''', '''
    <Person>  &&&&euro;  &#8364; &#x20AC;;; </Person>;
  '''

test 'tag with {{}}', ->
  eqJS '''
    <Person name={{value: item, key, item}} />
  ''', '''
    <Person name={{
        value: item,
        key,
        item
      }} />;
  '''

test 'tag with namespace', ->
  eqJS '''
    <Something.Tag></Something.Tag>
  ''', '''
    <Something.Tag></Something.Tag>;
  '''

test 'tag with lowercase namespace', ->
  eqJS '''
    <something.tag></something.tag>
  ''', '''
    <something.tag></something.tag>;
  '''

test 'self closing tag with namespace', ->
  eqJS '''
    <Something.Tag />
  ''', '''
    <Something.Tag />;
  '''

test 'self closing tag with spread attribute', ->
  eqJS '''
    <Component a={b} {x...} b="c" />
  ''', '''
    <Component a={b} {...x} b="c" />;
  '''

test 'complex spread attribute', ->
  eqJS '''
    <Component {x...} a={b} {x...} b="c" {$my_xtraCoolVar123...} />
  ''', '''
    <Component {...x} a={b} {...x} b="c" {...$my_xtraCoolVar123} />;
  '''

test 'multiline spread attribute', ->
  eqJS '''
    <Component {
      x...} a={b} {x...} b="c" {z...}>
    </Component>
  ''', '''
    <Component {...x} a={b} {...x} b="c" {...z}>
    </Component>;
  '''

test 'multiline tag with spread attribute', ->
  eqJS '''
    <Component
      z="1"
      {x...}
      a={b}
      b="c"
    >
    </Component>
  ''', '''
    <Component z="1" {...x} a={b} b="c">
    </Component>;
  '''

test 'multiline tag with spread attribute first', ->
  eqJS '''
    <Component
      {x...}
      z="1"
      a={b}
      b="c"
    >
    </Component>
  ''', '''
    <Component {...x} z="1" a={b} b="c">
    </Component>;
  '''

test 'complex multiline spread attribute', ->
  eqJS '''
    <Component
      {y...
      } a={b} {x...} b="c" {z...}>
      <div code={someFunc({a:{b:{}, C:'}'}})} />
    </Component>
  ''', '''
    <Component {...y} a={b} {...x} b="c" {...z}>
      <div code={someFunc({
        a: {
          b: {},
          C: '}'
        }
      })} />
    </Component>;
  '''

test 'self closing spread attribute on single line', ->
  eqJS '''
    <Component a="b" c="d" {@props...} />
  ''', '''
    <Component a="b" c="d" {...this.props} />;
  '''

test 'self closing spread attribute on new line', ->
  eqJS '''
    <Component
      a="b"
      c="d"
      {@props...}
    />
  ''', '''
    <Component a="b" c="d" {...this.props} />;
  '''

test 'self closing spread attribute on same line', ->
  eqJS '''
    <Component
      a="b"
      c="d"
      {@props...} />
  ''', '''
    <Component a="b" c="d" {...this.props} />;
  '''

test 'self closing spread attribute on next line', ->
  eqJS '''
    <Component
      a="b"
      c="d"
      {@props...}

    />
  ''', '''
    <Component a="b" c="d" {...this.props} />;
  '''

test 'empty strings are not converted to true', ->
  eqJS '''
    <Component val="" />
  ''', '''
    <Component val="" />;
  '''

test 'CoffeeScript @ syntax in tag name', ->
  throws -> CoffeeScript.compile '''
    <@Component>
      <Component />
    </@Component>
  '''

test 'hyphens in tag names', ->
  eqJS '''
    <paper-button className="button">{text}</paper-button>
  ''', '''
    <paper-button className="button">{text}</paper-button>;
  '''

test 'closing tags must be closed', ->
  throws -> CoffeeScript.compile '''
    <a></a
  '''

# Tests for allowing less than operator without spaces when ther is no CSX

test 'unspaced less than without CSX: identifier', ->
  a = 3
  div = 5
  ok a<div

test 'unspaced less than without CSX: number', ->
  div = 5
  ok 3<div

test 'unspaced less than without CSX: paren', ->
  div = 5
  ok (3)<div

test 'unspaced less than without CSX: index', ->
  div = 5
  a = [3]
  ok a[0]<div

test 'tag inside CSX works following: identifier', ->
  eqJS '''
    <span>a<div /></span>
  ''', '''
    <span>a<div /></span>;
  '''

test 'tag inside CSX works following: number', ->
  eqJS '''
    <span>3<div /></span>
  ''', '''
    <span>3<div /></span>;
  '''

test 'tag inside CSX works following: paren', ->
  eqJS '''
    <span>(3)<div /></span>
  ''', '''
    <span>(3)<div /></span>;
  '''

test 'tag inside CSX works following: square bracket', ->
  eqJS '''
    <span>]<div /></span>
  ''', '''
    <span>]<div /></span>;
  '''

test 'unspaced less than inside CSX works but is not encouraged', ->
  eqJS '''
      a = 3
      div = 5
      html = <span>{a<div}</span>
    ''', '''
      var a, div, html;

      a = 3;

      div = 5;

      html = <span>{a < div}</span>;
    '''

test 'unspaced less than before CSX works but is not encouraged', ->
  eqJS '''
      div = 5
      res = 2<div
      html = <span />
    ''', '''
      var div, html, res;

      div = 5;

      res = 2 < div;

      html = <span />;
    '''

test 'unspaced less than after CSX works but is not encouraged', ->
  eqJS '''
      div = 5
      html = <span />
      res = 2<div
    ''', '''
      var div, html, res;

      div = 5;

      html = <span />;

      res = 2 < div;
    '''

test '#4686: comments inside interpolations that also contain CSX tags', ->
  eqJS '''
    <div>
      {
        # comment
        <div />
      }
    </div>
  ''', '''
    <div>
      {  // comment
    <div />}
    </div>;
  '''

test '#4686: comments inside interpolations that also contain CSX attributes', ->
  eqJS '''
    <div>
      <div anAttr={
        # comment
        "value"
      } />
    </div>
  ''', '''
    <div>
      <div anAttr={  // comment
    "value"} />
    </div>;
  '''

# https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html
test 'JSX fragments: empty fragment', ->
  eqJS '''
    <></>
  ''', '''
    <></>;
  '''

test 'JSX fragments: fragment with text nodes', ->
  eqJS '''
    <>
      Some text.
      <h2>A heading</h2>
      More text.
      <h2>Another heading</h2>
      Even more text.
    </>
  ''', '''
    <>
      Some text.
      <h2>A heading</h2>
      More text.
      <h2>Another heading</h2>
      Even more text.
    </>;
  '''

test 'JSX fragments: fragment with component nodes', ->
  eqJS '''
   Component = (props) =>
     <Fragment>
       <OtherComponent />
       <OtherComponent />
     </Fragment>
  ''', '''
    var Component;

    Component = (props) => {
      return <Fragment>
        <OtherComponent />
        <OtherComponent />
      </Fragment>;
    };
  '''

test '#5055: JSX expression indentation bug', ->
  eqJS '''
    <div>
      {someCondition &&
        <span />
      }
    </div>
  ''', '''
    <div>
      {someCondition && <span />}
    </div>;
  '''

  eqJS '''
    <div>{someString +
         "abc"
      }
    </div>
  ''', '''
    <div>{someString + "abc"}
    </div>;
  '''

  eqJS '''
    <div>
      {a ?
      <span />
      }
    </div>
  ''', '''
    <div>
      {typeof a !== "undefined" && a !== null ? a : <span />}
    </div>;
  '''
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# We usually do not check the actual JS output from the compiler, but since
# JSX is not natively supported by Node, we do it in this case.

test 'self closing', ->
  eqJS(
    '''
    <div />
  '''
    '''
    <div />;
  '''
  )

test 'self closing formatting', ->
  eqJS(
    '''
    <div/>
  '''
    '''
    <div />;
  '''
  )

test 'self closing multiline', ->
  eqJS(
    '''
    <div
    />
  '''
    '''
    <div />;
  '''
  )

test 'regex attribute', ->
  eqJS(
    '''
    <div x={/>asds/} />
  '''
    '''
    <div x={/>asds/} />;
  '''
  )

test 'string attribute', ->
  eqJS(
    '''
    <div x="a" />
  '''
    '''
    <div x="a" />;
  '''
  )

test 'simple attribute', ->
  eqJS(
    '''
    <div x={42} />
  '''
    '''
    <div x={42} />;
  '''
  )

test 'assignment attribute', ->
  eqJS(
    '''
    <div x={y = 42} />
  '''
    '''
    var y;

    <div x={y = 42} />;
  '''
  )

test 'object attribute', ->
  eqJS(
    '''
    <div x={{y: 42}} />
  '''
    '''
    <div x={{
        y: 42
      }} />;
  '''
  )

test 'attribute without value', ->
  eqJS(
    '''
    <div checked x="hello" />
  '''
    '''
    <div checked x="hello" />;
  '''
  )

test 'paired', ->
  eqJS(
    '''
    <div></div>
  '''
    '''
    <div></div>;
  '''
  )

test 'simple content', ->
  eqJS(
    '''
    <div>Hello world</div>
  '''
    '''
    <div>Hello world</div>;
  '''
  )

test 'content interpolation', ->
  eqJS(
    '''
    <div>Hello {42}</div>
  '''
    '''
    <div>Hello {42}</div>;
  '''
  )

test 'nested tag', ->
  eqJS(
    '''
    <div><span /></div>
  '''
    '''
    <div><span /></div>;
  '''
  )

test 'tag inside interpolation formatting', ->
  eqJS(
    '''
    <div>Hello {<span />}</div>
  '''
    '''
    <div>Hello <span /></div>;
  '''
  )

test 'tag inside interpolation, tags are callable', ->
  eqJS(
    '''
    <div>Hello {<span /> x}</div>
  '''
    '''
    <div>Hello {<span />(x)}</div>;
  '''
  )

test 'tags inside interpolation, tags trigger implicit calls', ->
  eqJS(
    '''
    <div>Hello {f <span />}</div>
  '''
    '''
    <div>Hello {f(<span />)}</div>;
  '''
  )

test 'regex in interpolation', ->
  eqJS(
    '''
    <div x={/>asds/}><div />{/>asdsad</}</div>
  '''
    '''
    <div x={/>asds/}><div />{/>asdsad</}</div>;
  '''
  )

test 'interpolation in string attribute value', ->
  eqJS(
    '''
    <div x="Hello #{world}" />
  '''
    '''
    <div x={\`Hello \${world}\`} />;
  '''
  )

# Unlike in \`coffee-react-transform\`.
test 'bare numbers not allowed', ->
  throws -> CoffeeScript.compile '<div x=3 />'

test 'bare expressions not allowed', ->
  throws -> CoffeeScript.compile '<div x=y />'

test 'bare complex expressions not allowed', ->
  throws -> CoffeeScript.compile '<div x=f(3) />'

test 'unescaped opening tag angle bracket disallowed', ->
  throws -> CoffeeScript.compile '<Person><<</Person>'

test 'space around equal sign', ->
  eqJS(
    '''
    <div popular = "yes" />
  '''
    '''
    <div popular="yes" />;
  '''
  )

# The following tests were adopted from James Friend’s
# [https://github.com/jsdf/coffee-react-transform](https://github.com/jsdf/coffee-react-transform).

test 'ambiguous tag-like expression', ->
  throws -> CoffeeScript.compile 'x = a <b > c'

test 'ambiguous tag', ->
  eqJS(
    '''
    a <b > c </b>
  '''
    '''
    a(<b> c </b>);
  '''
  )

test 'escaped CoffeeScript attribute', ->
  eqJS(
    '''
    <Person name={if test() then 'yes' else 'no'} />
  '''
    '''
    <Person name={test() ? 'yes' : 'no'} />;
  '''
  )

test 'escaped CoffeeScript attribute over multiple lines', ->
  eqJS(
    '''
    <Person name={
      if test()
        'yes'
      else
        'no'
    } />
  '''
    '''
    <Person name={test() ? 'yes' : 'no'} />;
  '''
  )

test 'multiple line escaped CoffeeScript with nested CSX', ->
  eqJS(
    '''
    <Person name={
      if test()
        'yes'
      else
        'no'
    }>
    {

      for n in a
        <div> a
          asf
          <li xy={"as"}>{ n+1 }<a /> <a /> </li>
        </div>
    }

    </Person>
  '''
    '''
    var n;

    <Person name={test() ? 'yes' : 'no'}>
    {(function() {
      var i, len, results;
      results = [];
      for (i = 0, len = a.length; i < len; i++) {
        n = a[i];
        results.push(<div> a
          asf
          <li xy={"as"}>{n + 1}<a /> <a /> </li>
        </div>);
      }
      return results;
    })()}

    </Person>;
  '''
  )

test 'nested CSX within an attribute, with object attr value', ->
  eqJS(
    '''
    <Company>
      <Person name={<NameComponent attr3={ {'a': {}, b: '{'} } />} />
    </Company>
  '''
    '''
    <Company>
      <Person name={<NameComponent attr3={{
          'a': {},
          b: '{'
        }} />} />
    </Company>;
  '''
  )

test 'complex nesting', ->
  eqJS(
    '''
    <div code={someFunc({a:{b:{}, C:'}{}{'}})} />
  '''
    '''
    <div code={someFunc({
        a: {
          b: {},
          C: '}{}{'
        }
      })} />;
  '''
  )

test 'multiline tag with nested CSX within an attribute', ->
  eqJS(
    '''
    <Person
      name={
        name = formatName(user.name)
        <NameComponent name={name.toUppercase()} />
      }
    >
      blah blah blah
    </Person>
  '''
    '''
    var name;

    <Person name={name = formatName(user.name), <NameComponent name={name.toUppercase()} />}>
      blah blah blah
    </Person>;
  '''
  )

test 'escaped CoffeeScript with nested object literals', ->
  eqJS(
    '''
    <Person>
      blah blah blah blah blah blah blah blah blah blah blah blah blah {
        {'a' : {}, 'asd': 'asd'}
      }
    </Person>
  '''
    '''
    <Person>
      blah blah blah blah blah blah blah blah blah blah blah blah blah {{
      'a': {},
      'asd': 'asd'
    }}
    </Person>;
  '''
  )

test 'multiline tag attributes with escaped CoffeeScript', ->
  eqJS(
    '''
    <Person name={if isActive() then 'active' else 'inactive'}
    someattr='on new line' />
  '''
    '''
    <Person name={isActive() ? 'active' : 'inactive'} someattr='on new line' />;
  '''
  )

test 'lots of attributes', ->
  eqJS(
    '''
    <Person eyes={2} friends={getFriends()} popular = "yes"
    active={ if isActive() then 'active' else 'inactive' } data-attr='works' checked check={me_out}
    />
  '''
    '''
    <Person eyes={2} friends={getFriends()} popular="yes" active={isActive() ? 'active' : 'inactive'} data-attr='works' checked check={me_out} />;
  '''
  )

# TODO: fix partially indented CSX
# test 'multiline elements', ->
#   eqJS '''
#     <div something={
#       do ->
#         test = /432/gm # this is a regex
#         6 /432/gm # this is division
#     }
#     >
#     <div>
#     <div>
#     <div>
#       <article name={ new Date() } number={203}
#        range={getRange()}
#       >
#       </article>
#     </div>
#     </div>
#     </div>
#     </div>
#   ''', '''
#     bla
#   '''

test 'complex regex', ->
  eqJS(
    '''
    <Person />
    /\\\\/\\\\/<Person \\\\/>\\\\>\\\\//
  '''
    '''
    <Person />;

    /\\\\/\\\\/<Person \\\\/>\\\\>\\\\//;
  '''
  )

test 'heregex', ->
  eqJS(
    '''
    test = /432/gm # this is a regex
    6 /432/gm # this is division
    <Tag>
    {test = /<Tag>/} this is a regex containing something which looks like a tag
    </Tag>
    <Person />
    REGEX = /// ^
      (/ (?! [\\s=] )   # comment comment <comment>comment</comment>
      [^ [ / \\n \\\\ ]*  # comment comment
      (?:
        <Tag />
        (?: \\\\[\\s\\S]   # comment comment
          | \\[         # comment comment
               [^ \\] \\n \\\\ ]*
               (?: \\\\[\\s\\S] [^ \\] \\n \\\\ ]* )*
               <Tag>tag</Tag>
             ]
        ) [^ [ / \\n \\\\ ]*
      )*
      /) ([imgy]{0,4}) (?!\\w)
    ///
    <Person />
  '''
    '''
    var REGEX, test;

    test = /432/gm; // this is a regex

    6 / 432 / gm; // this is division

    <Tag>
    {(test = /<Tag>/)} this is a regex containing something which looks like a tag
    </Tag>;

    <Person />;

    REGEX = /^(\\\\/(?![s=])[^[\\\\/ ]*(?:<Tag\\\\/>(?:\\\\[sS]|[[^] ]*(?:\\\\[sS][^] ]*)*<Tag>tag<\\\\/Tag>])[^[\\\\/ ]*)*\\\\/)([imgy]{0,4})(?!w)/; // comment comment <comment>comment</comment>
    // comment comment
    // comment comment
    // comment comment

    <Person />;
  '''
  )

test 'comment within CSX is not treated as comment', ->
  eqJS(
    '''
    <Person>
    # i am not a comment
    </Person>
  '''
    '''
    <Person>
    # i am not a comment
    </Person>;
  '''
  )

test 'comment at start of CSX escape', ->
  eqJS(
    '''
    <Person>
    {# i am a comment
      "i am a string"
    }
    </Person>
  '''
    '''
    <Person>
    {// i am a comment
    "i am a string"}
    </Person>;
  '''
  )

test 'comment at end of CSX escape', ->
  eqJS(
    '''
    <Person>
    {"i am a string"
    # i am a comment
    }
    </Person>
  '''
    '''
    <Person>
    {"i am a string"
    // i am a comment
    }
    </Person>;
  '''
  )

test 'CSX comment cannot be used inside interpolation', ->
  throws ->
    CoffeeScript.compile '''
    <Person>
    {# i am a comment}
    </Person>
  '''

test 'comment syntax cannot be used inline', ->
  throws ->
    CoffeeScript.compile '''
    <Person>{#comment inline}</Person>
  '''

test 'string within CSX is ignored', ->
  eqJS(
    '''
    <Person> "i am not a string" 'nor am i' </Person>
  '''
    '''
    <Person> "i am not a string" 'nor am i' </Person>;
  '''
  )

test 'special chars within CSX are ignored', ->
  eqJS(
    """
    <Person> a,/';][' a\\''@$%^&˚¬∑˜˚∆å∂¬˚*()*&^%$>> '"''"'''\\'\\'m' i </Person>
  """
    """
    <Person> a,/';][' a''@$%^&˚¬∑˜˚∆å∂¬˚*()*&^%$>> '"''"'''''m' i </Person>;
  """
  )

test 'html entities (name, decimal, hex) within CSX', ->
  eqJS(
    '''
    <Person>  &&&&euro;  &#8364; &#x20AC;;; </Person>
  '''
    '''
    <Person>  &&&&euro;  &#8364; &#x20AC;;; </Person>;
  '''
  )

test 'tag with {{}}', ->
  eqJS(
    '''
    <Person name={{value: item, key, item}} />
  '''
    '''
    <Person name={{
        value: item,
        key,
        item
      }} />;
  '''
  )

test 'tag with namespace', ->
  eqJS(
    '''
    <Something.Tag></Something.Tag>
  '''
    '''
    <Something.Tag></Something.Tag>;
  '''
  )

test 'tag with lowercase namespace', ->
  eqJS(
    '''
    <something.tag></something.tag>
  '''
    '''
    <something.tag></something.tag>;
  '''
  )

test 'self closing tag with namespace', ->
  eqJS(
    '''
    <Something.Tag />
  '''
    '''
    <Something.Tag />;
  '''
  )

test 'self closing tag with spread attribute', ->
  eqJS(
    '''
    <Component a={b} {x...} b="c" />
  '''
    '''
    <Component a={b} {...x} b="c" />;
  '''
  )

test 'complex spread attribute', ->
  eqJS(
    '''
    <Component {x...} a={b} {x...} b="c" {$my_xtraCoolVar123...} />
  '''
    '''
    <Component {...x} a={b} {...x} b="c" {...$my_xtraCoolVar123} />;
  '''
  )

test 'multiline spread attribute', ->
  eqJS(
    '''
    <Component {
      x...} a={b} {x...} b="c" {z...}>
    </Component>
  '''
    '''
    <Component {...x} a={b} {...x} b="c" {...z}>
    </Component>;
  '''
  )

test 'multiline tag with spread attribute', ->
  eqJS(
    '''
    <Component
      z="1"
      {x...}
      a={b}
      b="c"
    >
    </Component>
  '''
    '''
    <Component z="1" {...x} a={b} b="c">
    </Component>;
  '''
  )

test 'multiline tag with spread attribute first', ->
  eqJS(
    '''
    <Component
      {x...}
      z="1"
      a={b}
      b="c"
    >
    </Component>
  '''
    '''
    <Component {...x} z="1" a={b} b="c">
    </Component>;
  '''
  )

test 'complex multiline spread attribute', ->
  eqJS(
    '''
    <Component
      {y...
      } a={b} {x...} b="c" {z...}>
      <div code={someFunc({a:{b:{}, C:'}'}})} />
    </Component>
  '''
    '''
    <Component {...y} a={b} {...x} b="c" {...z}>
      <div code={someFunc({
        a: {
          b: {},
          C: '}'
        }
      })} />
    </Component>;
  '''
  )

test 'self closing spread attribute on single line', ->
  eqJS(
    '''
    <Component a="b" c="d" {@props...} />
  '''
    '''
    <Component a="b" c="d" {...this.props} />;
  '''
  )

test 'self closing spread attribute on new line', ->
  eqJS(
    '''
    <Component
      a="b"
      c="d"
      {@props...}
    />
  '''
    '''
    <Component a="b" c="d" {...this.props} />;
  '''
  )

test 'self closing spread attribute on same line', ->
  eqJS(
    '''
    <Component
      a="b"
      c="d"
      {@props...} />
  '''
    '''
    <Component a="b" c="d" {...this.props} />;
  '''
  )

test 'self closing spread attribute on next line', ->
  eqJS(
    '''
    <Component
      a="b"
      c="d"
      {@props...}

    />
  '''
    '''
    <Component a="b" c="d" {...this.props} />;
  '''
  )

test 'empty strings are not converted to true', ->
  eqJS(
    '''
    <Component val="" />
  '''
    '''
    <Component val="" />;
  '''
  )

test 'CoffeeScript @ syntax in tag name', ->
  throws ->
    CoffeeScript.compile '''
    <@Component>
      <Component />
    </@Component>
  '''

test 'hyphens in tag names', ->
  eqJS(
    '''
    <paper-button className="button">{text}</paper-button>
  '''
    '''
    <paper-button className="button">{text}</paper-button>;
  '''
  )

test 'closing tags must be closed', ->
  throws ->
    CoffeeScript.compile '''
    <a></a
  '''

# Tests for allowing less than operator without spaces when ther is no CSX

test 'unspaced less than without CSX: identifier', ->
  a = 3
  div = 5
  ok a < div

test 'unspaced less than without CSX: number', ->
  div = 5
  ok 3 < div

test 'unspaced less than without CSX: paren', ->
  div = 5
  ok 3 < div

test 'unspaced less than without CSX: index', ->
  div = 5
  a = [3]
  ok a[0] < div

test 'tag inside CSX works following: identifier', ->
  eqJS(
    '''
    <span>a<div /></span>
  '''
    '''
    <span>a<div /></span>;
  '''
  )

test 'tag inside CSX works following: number', ->
  eqJS(
    '''
    <span>3<div /></span>
  '''
    '''
    <span>3<div /></span>;
  '''
  )

test 'tag inside CSX works following: paren', ->
  eqJS(
    '''
    <span>(3)<div /></span>
  '''
    '''
    <span>(3)<div /></span>;
  '''
  )

test 'tag inside CSX works following: square bracket', ->
  eqJS(
    '''
    <span>]<div /></span>
  '''
    '''
    <span>]<div /></span>;
  '''
  )

test 'unspaced less than inside CSX works but is not encouraged', ->
  eqJS(
    '''
      a = 3
      div = 5
      html = <span>{a<div}</span>
    '''
    '''
      var a, div, html;

      a = 3;

      div = 5;

      html = <span>{a < div}</span>;
    '''
  )

test 'unspaced less than before CSX works but is not encouraged', ->
  eqJS(
    '''
      div = 5
      res = 2<div
      html = <span />
    '''
    '''
      var div, html, res;

      div = 5;

      res = 2 < div;

      html = <span />;
    '''
  )

test 'unspaced less than after CSX works but is not encouraged', ->
  eqJS(
    '''
      div = 5
      html = <span />
      res = 2<div
    '''
    '''
      var div, html, res;

      div = 5;

      html = <span />;

      res = 2 < div;
    '''
  )

test '#4686: comments inside interpolations that also contain CSX tags', ->
  eqJS(
    '''
    <div>
      {
        # comment
        <div />
      }
    </div>
  '''
    '''
    <div>
      {  // comment
    <div />}
    </div>;
  '''
  )

test '#4686: comments inside interpolations that also contain CSX attributes', ->
  eqJS(
    '''
    <div>
      <div anAttr={
        # comment
        "value"
      } />
    </div>
  '''
    '''
    <div>
      <div anAttr={  // comment
    "value"} />
    </div>;
  '''
  )

# https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html
test 'JSX fragments: empty fragment', ->
  eqJS(
    '''
    <></>
  '''
    '''
    <></>;
  '''
  )

test 'JSX fragments: fragment with text nodes', ->
  eqJS(
    '''
    <>
      Some text.
      <h2>A heading</h2>
      More text.
      <h2>Another heading</h2>
      Even more text.
    </>
  '''
    '''
    <>
      Some text.
      <h2>A heading</h2>
      More text.
      <h2>Another heading</h2>
      Even more text.
    </>;
  '''
  )

test 'JSX fragments: fragment with component nodes', ->
  eqJS(
    '''
   Component = (props) =>
     <Fragment>
       <OtherComponent />
       <OtherComponent />
     </Fragment>
  '''
    '''
    var Component;

    Component = (props) => {
      return <Fragment>
        <OtherComponent />
        <OtherComponent />
      </Fragment>;
    };
  '''
  )

test '#5055: JSX expression indentation bug', ->
  eqJS(
    '''
    <div>
      {someCondition &&
        <span />
      }
    </div>
  '''
    '''
    <div>
      {someCondition && <span />}
    </div>;
  '''
  )

  eqJS(
    '''
    <div>{someString +
         "abc"
      }
    </div>
  '''
    '''
    <div>{someString + "abc"}
    </div>;
  '''
  )

  eqJS(
    '''
    <div>
      {a ?
      <span />
      }
    </div>
  '''
    '''
    <div>
      {typeof a !== "undefined" && a !== null ? a : <span />}
    </div>;
  '''
  )

`;

exports[`exception_handling.coffee 1`] = `
# Exception Handling
# ------------------

# shared nonce
nonce = {}


# Throw

test "basic exception throwing", ->
  throws (-> throw 'error'), /^error$/


# Empty Try/Catch/Finally

test "try can exist alone", ->
  try

test "try/catch with empty try, empty catch", ->
  try
    # nothing
  catch err
    # nothing

test "single-line try/catch with empty try, empty catch", ->
  try catch err

test "try/finally with empty try, empty finally", ->
  try
    # nothing
  finally
    # nothing

test "single-line try/finally with empty try, empty finally", ->
  try finally

test "try/catch/finally with empty try, empty catch, empty finally", ->
  try
  catch err
  finally

test "single-line try/catch/finally with empty try, empty catch, empty finally", ->
  try catch err then finally


# Try/Catch/Finally as an Expression

test "return the result of try when no exception is thrown", ->
  result = try
    nonce
  catch err
    undefined
  finally
    undefined
  eq nonce, result

test "single-line result of try when no exception is thrown", ->
  result = try nonce catch err then undefined
  eq nonce, result

test "return the result of catch when an exception is thrown", ->
  fn = ->
    try
      throw ->
    catch err
      nonce
  doesNotThrow fn
  eq nonce, fn()

test "single-line result of catch when an exception is thrown", ->
  fn = ->
    try throw (->) catch err then nonce
  doesNotThrow fn
  eq nonce, fn()

test "optional catch", ->
  fn = ->
    try throw ->
    nonce
  doesNotThrow fn
  eq nonce, fn()


# Try/Catch/Finally Interaction With Other Constructs

test "try/catch with empty catch as last statement in a function body", ->
  fn = ->
    try nonce
    catch err
  eq nonce, fn()

test "#1595: try/catch with a reused variable name", ->
  # \`catch\` shouldn’t lead to broken scoping.
  do ->
    try
      inner = 5
    catch inner
      # nothing
  eq typeof inner, 'undefined'

test "#2580: try/catch with destructuring the exception object", ->
  result = try
    missing.object
  catch {message}
    message

  eq message, 'missing is not defined'

test "Try catch finally as implicit arguments", ->
  first = (x) -> x

  foo = no
  try
    first try iamwhoiam() finally foo = yes
  catch e
  eq foo, yes

  bar = no
  try
    first try iamwhoiam() catch e finally
    bar = yes
  catch e
  eq bar, yes

test "#2900: parameter-less catch clause", ->
  # \`catch\` should not require a parameter.
  try
    throw new Error 'failed'
  catch
    ok true

  try throw new Error 'failed' catch finally ok true

  ok try throw new Error 'failed' catch then true

test "#3709: throwing an if statement", ->
  # \`throw if\` should return a closure around the \`if\` block, so that the
  # output is valid JavaScript.
  try
    throw if no
        new Error 'drat!'
      else
        new Error 'no escape!'
  catch err
    eq err.message, 'no escape!'

  try
    throw if yes then new Error 'huh?' else null
  catch err
    eq err.message, 'huh?'

test "#3709: throwing a switch statement", ->
  i = 3
  try
    throw switch i
      when 2
        new Error 'not this one'
      when 3
        new Error 'oh no!'
  catch err
    eq err.message, 'oh no!'

test "#3709: throwing a for loop", ->
  # \`throw for\` should return a closure around the \`for\` block, so that the
  # output is valid JavaScript.
  try
    throw for i in [0..3]
      i * 2
  catch err
    arrayEq err, [0, 2, 4, 6]

test "#3709: throwing a while loop", ->
  i = 0
  try
    throw while i < 3
      i++
  catch err
    eq i, 3

test "#3789: throwing a throw", ->
  try
    throw throw throw new Error 'whoa!'
  catch err
    eq err.message, 'whoa!'
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Exception Handling
# ------------------

# shared nonce
nonce = {}

# Throw

test 'basic exception throwing', ->
  throws (-> throw 'error'), /^error$/

# Empty Try/Catch/Finally

test 'try can exist alone', ->
  try

test 'try/catch with empty try, empty catch', ->
  try
    # nothing
  catch err
    # nothing

test 'single-line try/catch with empty try, empty catch', ->
  try catch err

test 'try/finally with empty try, empty finally', ->
  try
    # nothing
  finally
    # nothing

test 'single-line try/finally with empty try, empty finally', ->
  try finally

test 'try/catch/finally with empty try, empty catch, empty finally', ->
  try
  catch err
  finally

test 'single-line try/catch/finally with empty try, empty catch, empty finally', ->
  try catch err finally

# Try/Catch/Finally as an Expression

test 'return the result of try when no exception is thrown', ->
  result = try
    nonce
  catch err
    undefined
  finally
    undefined
  eq nonce, result

test 'single-line result of try when no exception is thrown', ->
  result = try nonce catch err then undefined
  eq nonce, result

test 'return the result of catch when an exception is thrown', ->
  fn = ->
    try
      throw ->
    catch err
      nonce
  doesNotThrow fn
  eq nonce, fn()

test 'single-line result of catch when an exception is thrown', ->
  fn = ->
    try throw -> catch err then nonce
  doesNotThrow fn
  eq nonce, fn()

test 'optional catch', ->
  fn = ->
    try throw ->
    nonce
  doesNotThrow fn
  eq nonce, fn()

# Try/Catch/Finally Interaction With Other Constructs

test 'try/catch with empty catch as last statement in a function body', ->
  fn = ->
    try
      nonce
    catch err
  eq nonce, fn()

test '#1595: try/catch with a reused variable name', ->
  # \`catch\` shouldn’t lead to broken scoping.
  do ->
    try
      inner = 5
    catch inner
      # nothing
  eq typeof inner, 'undefined'

test '#2580: try/catch with destructuring the exception object', ->
  result = try
    missing.object
  catch { message }
    message

  eq message, 'missing is not defined'

test 'Try catch finally as implicit arguments', ->
  first = (x) -> x

  foo = no
  try
    first try iamwhoiam() finally foo = yes
  catch e
  eq foo, yes

  bar = no
  try
    first try iamwhoiam() catch e finally
    bar = yes
  catch e
  eq bar, yes

test '#2900: parameter-less catch clause', ->
  # \`catch\` should not require a parameter.
  try
    throw new Error 'failed'
  catch
    ok true

  try throw new Error 'failed' catch finally ok true

  ok try throw new Error 'failed' catch then true

test '#3709: throwing an if statement', ->
  # \`throw if\` should return a closure around the \`if\` block, so that the
  # output is valid JavaScript.
  try
    throw (
      if no
        new Error 'drat!'
      else
        new Error 'no escape!'
    )
  catch err
    eq err.message, 'no escape!'

  try
    throw (if yes then new Error 'huh?' else null)
  catch err
    eq err.message, 'huh?'

test '#3709: throwing a switch statement', ->
  i = 3
  try
    throw switch i
      when 2
        new Error 'not this one'
      when 3
        new Error 'oh no!'
  catch err
    eq err.message, 'oh no!'

test '#3709: throwing a for loop', ->
  # \`throw for\` should return a closure around the \`for\` block, so that the
  # output is valid JavaScript.
  try
    throw for i in [0..3]
      i * 2
  catch err
    arrayEq err, [0, 2, 4, 6]

test '#3709: throwing a while loop', ->
  i = 0
  try
    throw while i < 3
      i++
  catch err
    eq i, 3

test '#3789: throwing a throw', ->
  try
    throw throw throw new Error 'whoa!'
  catch err
    eq err.message, 'whoa!'

`;

exports[`exponentiation.coffee 1`] = `
# The \`**\` and \`**=\` operators are only supported in Node 7.5+, so the tests
# for these exponentiation operators are split out into their own file to be
# loaded only by supported runtimes.

test "exponentiation operator", ->
  eq 27, 3 ** 3

test "exponentiation operator has higher precedence than other maths operators", ->
  eq 55, 1 + 3 ** 3 * 2
  eq -4, -2 ** 2
  eq 0, (!2) ** 2

test "exponentiation operator is right associative", ->
  eq 2, 2 ** 1 ** 3

test "exponentiation operator compound assignment", ->
  a = 2
  a **= 3
  eq 8, a
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# The \`**\` and \`**=\` operators are only supported in Node 7.5+, so the tests
# for these exponentiation operators are split out into their own file to be
# loaded only by supported runtimes.

test 'exponentiation operator', ->
  eq 27, 3 ** 3

test 'exponentiation operator has higher precedence than other maths operators', ->
  eq 55, 1 + 3 ** 3 * 2
  eq -4, -(2 ** 2)
  eq 0, (!2) ** 2

test 'exponentiation operator is right associative', ->
  eq 2, 2 ** (1 ** 3)

test 'exponentiation operator compound assignment', ->
  a = 2
  a **= 3
  eq 8, a

`;

exports[`formatting.coffee 1`] = `
# Formatting
# ----------

# TODO: maybe this file should be split up into their respective sections:
#   operators -> operators
#   array literals -> array literals
#   string literals -> string literals
#   function invocations -> function invocations

doesNotThrow -> CoffeeScript.compile "a = then b"

test "multiple semicolon-separated statements in parentheticals", ->
  nonce = {}
  eq nonce, (1; 2; nonce)
  eq nonce, (-> return (1; 2; nonce))()

# * Line Continuation
#   * Property Accesss
#   * Operators
#   * Array Literals
#   * Function Invocations
#   * String Literals

# Property Access

test "chained accesses split on period/newline, backwards and forwards", ->
  str = 'abc'
  result = str.
    split('').
    reverse().
    reverse().
    reverse()
  arrayEq ['c','b','a'], result
  arrayEq ['c','b','a'], str.
    split('').
    reverse().
    reverse().
    reverse()
  result = str
    .split('')
    .reverse()
    .reverse()
    .reverse()
  arrayEq ['c','b','a'], result
  arrayEq ['c','b','a'],
    str
    .split('')
    .reverse()
    .reverse()
    .reverse()
  arrayEq ['c','b','a'],
    str.
    split('')
    .reverse().
    reverse()
    .reverse()

# Operators

test "newline suppression for operators", ->
  six =
    1 +
    2 +
    3
  eq 6, six

test "\`?.\` and \`::\` should continue lines", ->
  ok not (
    Date
    ::
    ?.foo
  )

  ok not (
    Date
    ?::
    ?.foo
  )
  #eq Object::toString, Date?.
  #prototype
  #::
  #?.foo

doesNotThrow -> CoffeeScript.compile """
  oh. yes
  oh?. true
  oh:: return
  """

doesNotThrow -> CoffeeScript.compile """
  a?[b..]
  a?[...b]
  a?[b..c]
  """

test "#1768: space between \`::\` and index is ignored", ->
  eq 'function', typeof String:: ['toString']

# Array Literals

test "indented array literals don't trigger whitespace rewriting", ->
  getArgs = -> arguments
  result = getArgs(
    [[[[[],
                  []],
                [[]]]],
      []])
  eq 1, result.length

# Function Invocations

doesNotThrow -> CoffeeScript.compile """
  obj = then fn 1,
    1: 1
    a:
      b: ->
        fn c,
          d: e
    f: 1
  """

# String Literals

test "indented heredoc", ->
  result = ((_) -> _)(
                """
                abc
                """)
  eq "abc", result

# Chaining - all open calls are closed by property access starting a new line
# * chaining after
#   * indented argument
#   * function block
#   * indented object
#
#   * single line arguments
#   * inline function literal
#   * inline object literal
#
# * chaining inside
#   * implicit object literal

test "chaining after outdent", ->
  id = (x) -> x

  # indented argument
  ff = id parseInt "ff",
    16
  .toString()
  eq '255', ff

  # function block
  str = 'abc'
  zero = parseInt str.replace /\\w/, (letter) ->
    0
  .toString()
  eq '0', zero

  # indented object
  a = id id
    a: 1
  .a
  eq 1, a

test "#1495, method call chaining", ->
  str = 'abc'

  result = str.split ''
              .join ', '
  eq 'a, b, c', result

  result = str
  .split ''
  .join ', '
  eq 'a, b, c', result

  eq 'a, b, c', (str
    .split ''
    .join ', '
  )

  eq 'abc',
    'aaabbbccc'.replace /(\\w)\\1\\1/g, '$1$1'
               .replace /([abc])\\1/g, '$1'

  # Nested calls
  result = [1..3]
    .slice Math.max 0, 1
    .concat [3]
  arrayEq [2, 3, 3], result

  # Single line function arguments
  result = [1..6]
    .map (x) -> x * x
    .filter (x) -> x % 2 is 0
    .reverse()
  arrayEq [36, 16, 4], result

  # Single line implicit objects
  id = (x) -> x
  result = id a: 1
    .a
  eq 1, result

  # The parens are forced
  result = str.split(''.
    split ''
    .join ''
  ).join ', '
  eq 'a, b, c', result

test "chaining should not wrap spilling ternary", ->
  throws -> CoffeeScript.compile """
    if 0 then 1 else g
      a: 42
    .h()
  """

test "chaining should wrap calls containing spilling ternary", ->
  f = (x) -> h: x
  id = (x) -> x
  result = f if true then 42 else id
      a: 2
  .h
  eq 42, result

test "chaining should work within spilling ternary", ->
  f = (x) -> h: x
  id = (x) -> x
  result = f if false then 1 else id
      a: 3
      .a
  eq 3, result.h

test "method call chaining inside objects", ->
  f = (x) -> c: 42
  result =
    a: f 1
    b: f a: 1
      .c
  eq 42, result.b

test "#4568: refine sameLine implicit object tagging", ->
  condition = yes
  fn = -> yes

  x =
    fn bar: {
      foo: 123
    } if not condition
  eq x, undefined

# Nested blocks caused by paren unwrapping
test "#1492: Nested blocks don't cause double semicolons", ->
  js = CoffeeScript.compile '(0;0)'
  eq -1, js.indexOf ';;'

test "#1195 Ignore trailing semicolons (before newlines or as the last char in a program)", ->
  preNewline = (numSemicolons) ->
    """
    nonce = {}; nonce2 = {}
    f = -> nonce#{Array(numSemicolons+1).join(';')}
    nonce2
    unless f() is nonce then throw new Error('; before linebreak should = newline')
    """
  CoffeeScript.run(preNewline(n), bare: true) for n in [1,2,3]

  lastChar = '-> lastChar;'
  doesNotThrow -> CoffeeScript.compile lastChar, bare: true

test "#1299: Disallow token misnesting", ->
  try
    CoffeeScript.compile '''
      [{
         ]}
    '''
    ok no
  catch e
    eq 'unmatched ]', e.message

test "#2981: Enforce initial indentation", ->
  try
    CoffeeScript.compile '  a\\nb-'
    ok no
  catch e
    eq 'missing indentation', e.message

test "'single-line' expression containing multiple lines", ->
  doesNotThrow -> CoffeeScript.compile """
    (a, b) -> if a
      -a
    else if b
    then -b
    else null
  """

test "#1275: allow indentation before closing brackets", ->
  array = [
      1
      2
      3
    ]
  eq array, array
  do ->
  (
    a = 1
   )
  eq 1, a

test "don’t allow mixing of spaces and tabs for indentation", ->
  try
    CoffeeScript.compile '''
      new Layer
       x: 0
      	y: 1
    '''
    ok no
  catch e
    eq 'indentation mismatch', e.message

test "each code block that starts at indentation 0 can use a different style", ->
  doesNotThrow ->
    CoffeeScript.compile '''
      new Layer
       x: 0
       y: 1
      new Layer
      	x: 0
      	y: 1
    '''

test "tabs and spaces cannot be mixed for indentation", ->
  try
    CoffeeScript.compile '''
      new Layer
      	 x: 0
      	 y: 1
    '''
    ok no
  catch e
    eq 'mixed indentation', e.message

test "#4487: Handle unusual outdentation", ->
  a =
    switch 1
      when 2
          no
         when 3 then no
      when 1 then yes
  eq yes, a

  b = do ->
    if no
      if no
            1
       2
      3
  eq b, undefined

test "#3906: handle further indentation inside indented chain", ->
  eq 1, CoffeeScript.eval '''
    z = b: -> d: 2
    e = ->
    f = 3

    z
        .b ->
            c
        .d

    e(
        f
    )

    1
  '''

  eq 1, CoffeeScript.eval '''
    z = -> b: -> e: ->

    z()
        .b
            c: 'd'
        .e()

    f = [
        'g'
    ]

    1
  '''

  eq 1, CoffeeScript.eval '''
    z = -> c: -> c: ->

    z('b')
      .c 'a',
        {b: 'a'}
      .c()
    z(
      'b'
    )
    1
  '''

test "#3199: throw multiline implicit object", ->
  x = do ->
    if no then throw
      type: 'a'
      msg: 'b'
  eq undefined, x

  y = do ->
    if no then return
      type: 'a'
      msg: 'b'
  eq undefined, y

test "#4576: multiple row function chaining", ->
  ->
    eq @a, 3
  .call a: 3

test "#4576: function chaining on separate rows", ->
  do ->
    Promise
    .resolve()
    .then ->
      yes
    .then ok

test "#3736: chaining after do IIFE", ->
  eq 3,
    do ->
      a: 3
    .a

  eq 3,
    do (b = (c) -> c) -> a: 3
    ?.a

  b = 3
  eq 3,
    do (
      b
      {d} = {}
    ) ->
      a: b
    .a

  # preserve existing chaining behavior for non-IIFE \`do\`
  b = c: -> 4
  eq 4,
    do b
    .c
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Formatting
# ----------

# TODO: maybe this file should be split up into their respective sections:
#   operators -> operators
#   array literals -> array literals
#   string literals -> string literals
#   function invocations -> function invocations

doesNotThrow -> CoffeeScript.compile 'a = then b'

test 'multiple semicolon-separated statements in parentheticals', ->
  nonce = {}
  eq nonce, (1; 2; nonce)
  eq nonce, (-> return (1; 2; nonce))()

# * Line Continuation
#   * Property Accesss
#   * Operators
#   * Array Literals
#   * Function Invocations
#   * String Literals

# Property Access

test 'chained accesses split on period/newline, backwards and forwards', ->
  str = 'abc'
  result = str
    .split ''
    .reverse()
    .reverse()
    .reverse()
  arrayEq ['c', 'b', 'a'], result
  arrayEq(
    ['c', 'b', 'a']
    str
      .split ''
      .reverse()
      .reverse()
      .reverse()
  )
  result = str
    .split ''
    .reverse()
    .reverse()
    .reverse()
  arrayEq ['c', 'b', 'a'], result
  arrayEq(
    ['c', 'b', 'a']
    str
      .split ''
      .reverse()
      .reverse()
      .reverse()
  )
  arrayEq(
    ['c', 'b', 'a']
    str
      .split ''
      .reverse()
      .reverse()
      .reverse()
  )

# Operators

test 'newline suppression for operators', ->
  six = 1 + 2 + 3
  eq 6, six

test '\`?.\` and \`::\` should continue lines', ->
  ok not Date::?.foo

  ok not Date?::?.foo
  #eq Object::toString, Date?.
  #prototype
  #::
  #?.foo

doesNotThrow ->
  CoffeeScript.compile '''
  oh. yes
  oh?. true
  oh:: return
  '''

doesNotThrow ->
  CoffeeScript.compile '''
  a?[b..]
  a?[...b]
  a?[b..c]
  '''

test '#1768: space between \`::\` and index is ignored', ->
  eq 'function', typeof String::['toString']

# Array Literals

test "indented array literals don't trigger whitespace rewriting", ->
  getArgs = -> arguments
  result = getArgs [[[[[], []], [[]]]], []]
  eq 1, result.length

# Function Invocations

doesNotThrow ->
  CoffeeScript.compile '''
  obj = then fn 1,
    1: 1
    a:
      b: ->
        fn c,
          d: e
    f: 1
  '''

# String Literals

test 'indented heredoc', ->
  result =
    ((_) -> _)(
      '''
                abc
                '''
    )
  eq 'abc', result

# Chaining - all open calls are closed by property access starting a new line
# * chaining after
#   * indented argument
#   * function block
#   * indented object
#
#   * single line arguments
#   * inline function literal
#   * inline object literal
#
# * chaining inside
#   * implicit object literal

test 'chaining after outdent', ->
  id = (x) -> x

  # indented argument
  ff = id(parseInt 'ff', 16).toString()
  eq '255', ff

  # function block
  str = 'abc'
  zero = parseInt(
    str.replace /\\w/, (letter) ->
      0
  ).toString()
  eq '0', zero

  # indented object
  a = id(id a: 1).a
  eq 1, a

test '#1495, method call chaining', ->
  str = 'abc'

  result = str.split('').join ', '
  eq 'a, b, c', result

  result = str.split('').join ', '
  eq 'a, b, c', result

  eq 'a, b, c', str.split('').join ', '

  eq 'abc', 'aaabbbccc'.replace(/(\\w)\\1\\1/g, '$1$1').replace /([abc])\\1/g, '$1'

  # Nested calls
  result = [1..3].slice(Math.max 0, 1).concat [3]
  arrayEq [2, 3, 3], result

  # Single line function arguments
  result = [1..6]
    .map (x) -> x * x
    .filter (x) -> (x % 2) is 0
    .reverse()
  arrayEq [36, 16, 4], result

  # Single line implicit objects
  id = (x) -> x
  result = id(a: 1).a
  eq 1, result

  # The parens are forced
  result = str.split(''.split('').join '').join ', '
  eq 'a, b, c', result

test 'chaining should not wrap spilling ternary', ->
  throws ->
    CoffeeScript.compile '''
    if 0 then 1 else g
      a: 42
    .h()
  '''

test 'chaining should wrap calls containing spilling ternary', ->
  f = (x) -> h: x
  id = (x) -> x
  result = f(if true then 42 else id a: 2).h
  eq 42, result

test 'chaining should work within spilling ternary', ->
  f = (x) -> h: x
  id = (x) -> x
  result = f if false then 1 else id { a: 3 }.a
  eq 3, result.h

test 'method call chaining inside objects', ->
  f = (x) -> c: 42
  result =
    a: f 1
    b: f(a: 1).c
  eq 42, result.b

test '#4568: refine sameLine implicit object tagging', ->
  condition = yes
  fn = -> yes

  x =
    fn(
      bar:
        foo: 123
    ) if not condition
  eq x, undefined

# Nested blocks caused by paren unwrapping
test "#1492: Nested blocks don't cause double semicolons", ->
  js = CoffeeScript.compile '(0;0)'
  eq -1, js.indexOf ';;'

test '#1195 Ignore trailing semicolons (before newlines or as the last char in a program)', ->
  preNewline = (numSemicolons) ->
    """
    nonce = {}; nonce2 = {}
    f = -> nonce#{Array(numSemicolons + 1).join ';'}
    nonce2
    unless f() is nonce then throw new Error('; before linebreak should = newline')
    """
  CoffeeScript.run preNewline(n), bare: true for n in [1, 2, 3]

  lastChar = '-> lastChar;'
  doesNotThrow -> CoffeeScript.compile lastChar, bare: true

test '#1299: Disallow token misnesting', ->
  try
    CoffeeScript.compile '''
      [{
         ]}
    '''
    ok no
  catch e
    eq 'unmatched ]', e.message

test '#2981: Enforce initial indentation', ->
  try
    CoffeeScript.compile '  a\\nb-'
    ok no
  catch e
    eq 'missing indentation', e.message

test "'single-line' expression containing multiple lines", ->
  doesNotThrow ->
    CoffeeScript.compile '''
    (a, b) -> if a
      -a
    else if b
    then -b
    else null
  '''

test '#1275: allow indentation before closing brackets', ->
  array = [1, 2, 3]
  eq array, array
  do ->
  a = 1
  eq 1, a

test 'don’t allow mixing of spaces and tabs for indentation', ->
  try
    CoffeeScript.compile '''
      new Layer
       x: 0
      	y: 1
    '''
    ok no
  catch e
    eq 'indentation mismatch', e.message

test 'each code block that starts at indentation 0 can use a different style', ->
  doesNotThrow ->
    CoffeeScript.compile '''
      new Layer
       x: 0
       y: 1
      new Layer
      	x: 0
      	y: 1
    '''

test 'tabs and spaces cannot be mixed for indentation', ->
  try
    CoffeeScript.compile '''
      new Layer
      	 x: 0
      	 y: 1
    '''
    ok no
  catch e
    eq 'mixed indentation', e.message

test '#4487: Handle unusual outdentation', ->
  a = switch 1
    when 2
      no
    when 3 then no
    when 1 then yes
  eq yes, a

  b = do ->
    if no
      if no
        1
      2
      3
  eq b, undefined

test '#3906: handle further indentation inside indented chain', ->
  eq(
    1
    CoffeeScript.eval '''
    z = b: -> d: 2
    e = ->
    f = 3

    z
        .b ->
            c
        .d

    e(
        f
    )

    1
  '''
  )

  eq(
    1
    CoffeeScript.eval '''
    z = -> b: -> e: ->

    z()
        .b
            c: 'd'
        .e()

    f = [
        'g'
    ]

    1
  '''
  )

  eq(
    1
    CoffeeScript.eval '''
    z = -> c: -> c: ->

    z('b')
      .c 'a',
        {b: 'a'}
      .c()
    z(
      'b'
    )
    1
  '''
  )

test '#3199: throw multiline implicit object', ->
  x = do ->
    if no
      throw
        type: 'a'
        msg: 'b'
  eq undefined, x

  y = do ->
    if no
      return
        type: 'a'
        msg: 'b'
  eq undefined, y

test '#4576: multiple row function chaining', ->
  (->
    eq @a, 3
  ).call a: 3

test '#4576: function chaining on separate rows', ->
  do ->
    Promise.resolve()
      .then ->
        yes
      .then ok

test '#3736: chaining after do IIFE', ->
  eq(
    3
    do ->
      a: 3
    .a
  )

  eq 3, (do (b = (c) -> c) -> a: 3)?.a

  b = 3
  eq(
    3
    do (b, { d } = {}) ->
      a: b
    .a
  )

  # preserve existing chaining behavior for non-IIFE \`do\`
  b = c: -> 4
  eq 4, do b.c

`;

exports[`function_invocation.coffee 1`] = `
# Function Invocation
# -------------------

# * Function Invocation
# * Splats in Function Invocations
# * Implicit Returns
# * Explicit Returns

# shared identity function
id = (_) -> if arguments.length is 1 then _ else [arguments...]

# helper to assert that a string should fail compilation
cantCompile = (code) ->
  throws -> CoffeeScript.compile code

test "basic argument passing", ->

  a = {}
  b = {}
  c = {}
  eq 1, (id 1)
  eq 2, (id 1, 2)[1]
  eq a, (id a)
  eq c, (id a, b, c)[2]


test "passing arguments on separate lines", ->

  a = {}
  b = {}
  c = {}
  ok(id(
    a
    b
    c
  )[1] is b)
  eq(0, id(
    0
    10
  )[0])
  eq(a,id(
    a
  ))
  eq b,
  (id b)


test "optional parens can be used in a nested fashion", ->

  call = (func) -> func()
  add = (a,b) -> a + b
  result = call ->
    inner = call ->
      add 5, 5
  ok result is 10


test "hanging commas and semicolons in argument list", ->

  fn = () -> arguments.length
  eq 2, fn(0,1,)
  eq 3, fn 0, 1,
  2
  eq 2, fn(0, 1;)
  # TODO: this test fails (the string compiles), but should it?
  #throws -> CoffeeScript.compile "fn(0,1,;)"
  throws -> CoffeeScript.compile "fn(0,1,;;)"
  throws -> CoffeeScript.compile "fn(0, 1;,)"
  throws -> CoffeeScript.compile "fn(,0)"
  throws -> CoffeeScript.compile "fn(;0)"


test "function invocation", ->

  func = ->
    return if true
  eq undefined, func()

  result = ("hello".slice) 3
  ok result is 'lo'


test "And even with strange things like this:", ->

  funcs  = [((x) -> x), ((x) -> x * x)]
  result = funcs[1] 5
  ok result is 25


test "More fun with optional parens.", ->

  fn = (arg) -> arg
  ok fn(fn {prop: 101}).prop is 101

  okFunc = (f) -> ok(f())
  okFunc -> true


test "chained function calls", ->
  nonce = {}
  identityWrap = (x) ->
    -> x
  eq nonce, identityWrap(identityWrap(nonce))()()
  eq nonce, (identityWrap identityWrap nonce)()()


test "Multi-blocks with optional parens.", ->

  fn = (arg) -> arg
  result = fn( ->
    fn ->
      "Wrapped"
  )
  ok result()() is 'Wrapped'


test "method calls", ->

  fnId = (fn) -> -> fn.apply this, arguments
  math = {
    add: (a, b) -> a + b
    anonymousAdd: (a, b) -> a + b
    fastAdd: fnId (a, b) -> a + b
  }
  ok math.add(5, 5) is 10
  ok math.anonymousAdd(10, 10) is 20
  ok math.fastAdd(20, 20) is 40


test "Ensure that functions can have a trailing comma in their argument list", ->

  mult = (x, mids..., y) ->
    x *= n for n in mids
    x *= y
  #ok mult(1, 2,) is 2
  #ok mult(1, 2, 3,) is 6
  ok mult(10, (i for i in [1..6])...) is 7200


test "\`@\` and \`this\` should both be able to invoke a method", ->
  nonce = {}
  fn          = (arg) -> eq nonce, arg
  fn.withAt   = -> @ nonce
  fn.withThis = -> this nonce
  fn.withAt()
  fn.withThis()


test "Trying an implicit object call with a trailing function.", ->

  a = null
  meth = (arg, obj, func) -> a = [obj.a, arg, func()].join ' '
  meth 'apple', b: 1, a: 13, ->
    'orange'
  ok a is '13 apple orange'


test "Ensure that empty functions don't return mistaken values.", ->

  obj =
    func: (@param, @rest...) ->
  ok obj.func(101, 102, 103, 104) is undefined
  ok obj.param is 101
  ok obj.rest.join(' ') is '102 103 104'


test "Passing multiple functions without paren-wrapping is legal, and should compile.", ->

  sum = (one, two) -> one() + two()
  result = sum ->
    7 + 9
  , ->
    1 + 3
  ok result is 20


test "Implicit call with a trailing if statement as a param.", ->

  func = -> arguments[1]
  result = func 'one', if false then 100 else 13
  ok result is 13


test "Test more function passing:", ->

  sum = (one, two) -> one() + two()

  result = sum( ->
    1 + 2
  , ->
    2 + 1
  )
  ok result is 6

  sum = (a, b) -> a + b
  result = sum(1
  , 2)
  ok result is 3


test "Chained blocks, with proper indentation levels:", ->

  counter =
    results: []
    tick: (func) ->
      @results.push func()
      this
  counter
    .tick ->
      3
    .tick ->
      2
    .tick ->
      1
  arrayEq [3,2,1], counter.results


test "This is a crazy one.", ->

  x = (obj, func) -> func obj
  ident = (x) -> x
  result = x {one: ident 1}, (obj) ->
    inner = ident(obj)
    ident inner
  ok result.one is 1


test "More paren compilation tests:", ->

  reverse = (obj) -> obj.reverse()
  ok reverse([1, 2].concat 3).join(' ') is '3 2 1'


test "Test for inline functions with parentheses and implicit calls.", ->

  combine = (func, num) -> func() * num
  result  = combine (-> 1 + 2), 3
  ok result is 9


test "Test for calls/parens/multiline-chains.", ->

  f = (x) -> x
  result = (f 1).toString()
    .length
  ok result is 1


test "Test implicit calls in functions in parens:", ->

  result = ((val) ->
    [].push val
    val
  )(10)
  ok result is 10


test "Ensure that chained calls with indented implicit object literals below are alright.", ->

  result = null
  obj =
    method: (val)  -> this
    second: (hash) -> result = hash.three
  obj
    .method(
      101
    ).second(
      one:
        two: 2
      three: 3
    )
  eq result, 3


test "Test newline-supressed call chains with nested functions.", ->

  obj  =
    call: -> this
  func = ->
    obj
      .call ->
        one two
      .call ->
        three four
    101
  eq func(), 101


test "Implicit objects with number arguments.", ->

  func = (x, y) -> y
  obj =
    prop: func "a", 1
  ok obj.prop is 1


test "Non-spaced unary and binary operators should cause a function call.", ->

  func = (val) -> val + 1
  ok (func +5) is 6
  ok (func -5) is -4


test "Prefix unary assignment operators are allowed in parenless calls.", ->

  func = (val) -> val + 1
  val = 5
  ok (func --val) is 5

test "#855: execution context for \`func arr...\` should be \`null\`", ->
  contextTest = -> eq @, if window? then window else global
  array = []
  contextTest array
  contextTest.apply null, array
  contextTest array...

test "#904: Destructuring function arguments with same-named variables in scope", ->
  a = b = nonce = {}
  fn = ([a,b]) -> {a:a,b:b}
  result = fn([c={},d={}])
  eq c, result.a
  eq d, result.b
  eq nonce, a
  eq nonce, b

test "Simple Destructuring function arguments with same-named variables in scope", ->
  x = 1
  f = ([x]) -> x
  eq f([2]), 2
  eq x, 1

test "#4843: Bad output when assigning to @prop in destructuring assignment with defaults", ->
  works = "maybe"
  drinks = "beer"
  class A
    constructor: ({@works = 'no', @drinks = 'wine'}) ->
  a = new A {works: 'yes', drinks: 'coffee'}
  eq a.works, 'yes'
  eq a.drinks, 'coffee'

test "caching base value", ->

  obj =
    index: 0
    0: {method: -> this is obj[0]}
  ok obj[obj.index++].method([]...)


test "passing splats to functions", ->
  arrayEq [0..4], id id [0..4]...
  fn = (a, b, c..., d) -> [a, b, c, d]
  range = [0..3]
  [first, second, others, last] = fn range..., 4, [5...8]...
  eq 0, first
  eq 1, second
  arrayEq [2..6], others
  eq 7, last

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  arrayEq [0..4], id id [0..4] ...
  fn = (a, b, c ..., d) -> [a, b, c, d]
  range = [0..3]
  [first, second, others, last] = fn range ..., 4, [5 ... 8] ...
  eq 0, first
  eq 1, second
  arrayEq [2..6], others
  eq 7, last

test "splat variables are local to the function", ->
  outer = "x"
  clobber = (avar, outer...) -> outer
  clobber "foo", "bar"
  eq "x", outer

test "Issue 4631: left and right spread dots with preceding space", ->
  a = []
  f = (a) -> a
  eq yes, (f ...a) is (f ... a) is (f a...) is (f a ...) is f(a...) is f(...a) is f(a ...) is f(... a)

test "Issue 894: Splatting against constructor-chained functions.", ->

  x = null
  class Foo
    bar: (y) -> x = y
  new Foo().bar([101]...)
  eq x, 101


test "Functions with splats being called with too few arguments.", ->

  pen = null
  method = (first, variable..., penultimate, ultimate) ->
    pen = penultimate
  method 1, 2, 3, 4, 5, 6, 7, 8, 9
  ok pen is 8
  method 1, 2, 3
  ok pen is 2
  method 1, 2
  ok pen is 2


test "splats with super() within classes.", ->

  class Parent
    meth: (args...) ->
      args
  class Child extends Parent
    meth: ->
      nums = [3, 2, 1]
      super nums...
  ok (new Child).meth().join(' ') is '3 2 1'

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  class Parent
    meth: (args ...) ->
      args
  class Child extends Parent
    meth: ->
      nums = [3, 2, 1]
      super nums ...
  ok (new Child).meth().join(' ') is '3 2 1'


test "#1011: passing a splat to a method of a number", ->
  eq '1011', 11.toString [2]...
  eq '1011', (31).toString [3]...
  eq '1011', 69.0.toString [4]...
  eq '1011', (131.0).toString [5]...

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  eq '1011', 11.toString [2] ...
  eq '1011', (31).toString [3] ...
  eq '1011', 69.0.toString [4] ...
  eq '1011', (131.0).toString [5] ...

test "splats and the \`new\` operator: functions that return \`null\` should construct their instance", ->
  args = []
  child = new (constructor = -> null) args...
  ok child instanceof constructor

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  child = new (constructor = -> null) args ...
  ok child instanceof constructor

test "splats and the \`new\` operator: functions that return functions should construct their return value", ->
  args = []
  fn = ->
  child = new (constructor = -> fn) args...
  ok child not instanceof constructor
  eq fn, child

test "implicit return", ->

  eq ok, new ->
    ok
    ### Should \`return\` implicitly   ###
    ### even with trailing comments. ###


test "implicit returns with multiple branches", ->
  nonce = {}
  fn = ->
    if false
      for a in b
        return c if d
    else
      nonce
  eq nonce, fn()


test "implicit returns with switches", ->
  nonce = {}
  fn = ->
    switch nonce
      when nonce then nonce
      else return undefined
  eq nonce, fn()


test "preserve context when generating closure wrappers for expression conversions", ->
  nonce = {}
  obj =
    property: nonce
    method: ->
      this.result = if false
        10
      else
        "a"
        "b"
        this.property
  eq nonce, obj.method()
  eq nonce, obj.property


test "don't wrap 'pure' statements in a closure", ->
  nonce = {}
  items = [0, 1, 2, 3, nonce, 4, 5]
  fn = (items) ->
    for item in items
      return item if item is nonce
  eq nonce, fn items


test "usage of \`new\` is careful about where the invocation parens end up", ->
  eq 'object', typeof new try Array
  eq 'object', typeof new do -> ->


test "implicit call against control structures", ->
  result = null
  save   = (obj) -> result = obj

  save switch id false
    when true
      'true'
    when false
      'false'

  eq result, 'false'

  save if id false
    'false'
  else
    'true'

  eq result, 'true'

  save unless id false
    'true'
  else
    'false'

  eq result, 'true'

  save try
    doesnt exist
  catch error
    'caught'

  eq result, 'caught'

  save try doesnt(exist) catch error then 'caught2'

  eq result, 'caught2'


test "#1420: things like \`(fn() ->)\`; there are no words for this one", ->
  fn = -> (f) -> f()
  nonce = {}
  eq nonce, (fn() -> nonce)

test "#1416: don't omit one 'new' when compiling 'new new'", ->
  nonce = {}
  obj = new new -> -> {prop: nonce}
  eq obj.prop, nonce

test "#1416: don't omit one 'new' when compiling 'new new fn()()'", ->
  nonce = {}
  argNonceA = {}
  argNonceB = {}
  fn = (a) -> (b) -> {a, b, prop: nonce}
  obj = new new fn(argNonceA)(argNonceB)
  eq obj.prop, nonce
  eq obj.a, argNonceA
  eq obj.b, argNonceB

test "#1840: accessing the \`prototype\` after function invocation should compile", ->
  doesNotThrow -> CoffeeScript.compile 'fn()::prop'

  nonce = {}
  class Test then id: nonce

  dotAccess = -> Test::
  protoAccess = -> Test

  eq dotAccess().id, nonce
  eq protoAccess()::id, nonce

test "#960: improved 'do'", ->

  do (nonExistent = 'one') ->
    eq nonExistent, 'one'

  overridden = 1
  do (overridden = 2) ->
    eq overridden, 2

  two = 2
  do (one = 1, two, three = 3) ->
    eq one, 1
    eq two, 2
    eq three, 3

  ret = do func = (two) ->
    eq two, 2
    func
  eq ret, func

test "#2617: implicit call before unrelated implicit object", ->
  pass = ->
    true

  result = if pass 1
    one: 1
  eq result.one, 1

test "#2292, b: f (z),(x)", ->
  f = (x, y) -> y
  one = 1
  two = 2
  o = b: f (one),(two)
  eq o.b, 2

test "#2297, Different behaviors on interpreting literal", ->
  foo = (x, y) -> y
  bar =
    baz: foo 100, on

  eq bar.baz, on

  qux = (x) -> x
  quux = qux
    corge: foo 100, true

  eq quux.corge, on

  xyzzy =
    e: 1
    f: foo
      a: 1
      b: 2
    ,
      one: 1
      two: 2
      three: 3
    g:
      a: 1
      b: 2
      c: foo 2,
        one: 1
        two: 2
        three: 3
      d: 3
    four: 4
    h: foo one: 1, two: 2, three: three: three: 3,
      2

  eq xyzzy.f.two, 2
  eq xyzzy.g.c.three, 3
  eq xyzzy.four, 4
  eq xyzzy.h, 2

test "#2715, Chained implicit calls", ->
  first  = (x)    -> x
  second = (x, y) -> y

  foo = first first
    one: 1
  eq foo.one, 1

  bar = first second
    one: 1, 2
  eq bar, 2

  baz = first second
    one: 1,
    2
  eq baz, 2

test "Implicit calls and new", ->
  first = (x) -> x
  foo = (@x) ->
  bar = first new foo first 1
  eq bar.x, 1

  third = (x, y, z) -> z
  baz = first new foo new foo third
        one: 1
        two: 2
        1
        three: 3
        2
  eq baz.x.x.three, 3

test "Loose tokens inside of explicit call lists", ->
  first = (x) -> x
  second = (x, y) -> y
  one = 1

  foo = second( one
                2)
  eq foo, 2

  bar = first( first
               one: 1)
  eq bar.one, 1

test "Non-callable literals shouldn't compile", ->
  cantCompile '1(2)'
  cantCompile '1 2'
  cantCompile '/t/(2)'
  cantCompile '/t/ 2'
  cantCompile '///t///(2)'
  cantCompile '///t/// 2'
  cantCompile "''(2)"
  cantCompile "'' 2"
  cantCompile '""(2)'
  cantCompile '"" 2'
  cantCompile '""""""(2)'
  cantCompile '"""""" 2'
  cantCompile '{}(2)'
  cantCompile '{} 2'
  cantCompile '[](2)'
  cantCompile '[] 2'
  cantCompile '[2..9] 2'
  cantCompile '[2..9](2)'
  cantCompile '[1..10][2..9] 2'
  cantCompile '[1..10][2..9](2)'

test "implicit invocation with implicit object literal", ->
  f = (obj) -> eq 1, obj.a

  f
    a: 1
  obj =
    if f
      a: 2
    else
      a: 1
  eq 2, obj.a

  f
    "a": 1
  obj =
    if f
      "a": 2
    else
      "a": 1
  eq 2, obj.a

  # #3935: Implicit call when the first key of an implicit object has interpolation.
  a = 'a'
  f
    "#{a}": 1
  obj =
    if f
      "#{a}": 2
    else
      "#{a}": 1
  eq 2, obj.a

test "get and set can be used as function names when not ambiguous with \`get\`/\`set\` keywords", ->
  get = (val) -> val
  set = (val) -> val
  eq 2, get(2)
  eq 3, set(3)
  eq 'a', get('a')
  eq 'b', set('b')
  eq 4, get 4
  eq 5, set 5
  eq 'c', get 'c'
  eq 'd', set 'd'

  @get = get
  @set = set
  eq 6, @get 6
  eq 7, @set 7

  get = ({val}) -> val
  set = ({val}) -> val
  eq 8, get({val: 8})
  eq 9, set({val: 9})
  eq 'e', get({val: 'e'})
  eq 'f', set({val: 'f'})
  eq 10, get {val: 10}
  eq 11, set {val: 11}
  eq 'g', get {val: 'g'}
  eq 'h', set {val: 'h'}

test "get and set can be used as variable and property names", ->
  get = 2
  set = 3
  eq 2, get
  eq 3, set

  {get} = {get: 4}
  {set} = {set: 5}
  eq 4, get
  eq 5, set

test "get and set can be used as class method names", ->
  class A
    get: -> 2
    set: -> 3

  a = new A()
  eq 2, a.get()
  eq 3, a.set()

  class B
    @get = -> 4
    @set = -> 5

  eq 4, B.get()
  eq 5, B.set()

test "#4524: functions named get or set can be used without parentheses when attached to an object", ->
  obj =
    get: (x) -> x + 2
    set: (x) -> x + 3

  class A
    get: (x) -> x + 4
    set: (x) -> x + 5

  a = new A()

  class B
    get: (x) -> x.value + 6
    set: (x) -> x.value + 7

  b = new B()

  eq 12, obj.get 10
  eq 13, obj.set 10
  eq 12, obj?.get 10
  eq 13, obj?.set 10

  eq 14, a.get 10
  eq 15, a.set 10

  @ten = 10

  eq 12, obj.get @ten
  eq 13, obj.set @ten

  eq 14, a.get @ten
  eq 15, a.set @ten

  obj.obj = obj

  eq 12, obj.obj.get @ten
  eq 13, obj.obj.set @ten

  eq 16, b.get value: 10
  eq 17, b.set value: 10

  eq 16, b.get value: @ten
  eq 17, b.set value: @ten

test "#4836: functions named get or set can be used without parentheses when attached to this or @", ->
  @get = (x) -> x + 2
  @set = (x) -> x + 3
  @a = 4

  eq 12, this.get 10
  eq 13, this.set 10
  eq 12, this?.get 10
  eq 13, this?.set 10
  eq 6, this.get @a
  eq 7, this.set @a
  eq 6, this?.get @a
  eq 7, this?.set @a

  eq 12, @get 10
  eq 13, @set 10
  eq 12, @?.get 10
  eq 13, @?.set 10
  eq 6, @get @a
  eq 7, @set @a
  eq 6, @?.get @a
  eq 7, @?.set @a

test "#4852: functions named get or set can be used without parentheses when attached to this or @, with an argument of an implicit object", ->
  @get = ({ x }) -> x + 2
  @set = ({ x }) -> x + 3

  eq 12, @get x: 10
  eq 13, @set x: 10
  eq 12, @?.get x: 10
  eq 13, @?.set x: 10
  eq 12, this?.get x: 10
  eq 13, this?.set x: 10

test "#4473: variable scope in chained calls", ->
  obj =
    foo: -> this
    bar: (a) ->
      a()
      this

  obj.foo(a = 1).bar(-> a = 2)
  eq a, 2

  obj.bar(-> b = 2).foo(b = 1)
  eq b, 1

  obj.foo(c = 1).bar(-> c = 2).foo(c = 3)
  eq c, 3

  obj.foo([d, e] = [1, 2]).bar(-> d = 4)
  eq d, 4

  obj.foo({f} = {f: 1}).bar(-> f = 5)
  eq f, 5

test "#5052: implicit call of class with no body", ->
  doesNotThrow -> CoffeeScript.compile 'f class'
  doesNotThrow -> CoffeeScript.compile 'f class A'
  doesNotThrow -> CoffeeScript.compile 'f class A extends B'

  f = (args...) -> args
  a = 1

  [klass, shouldBeA] = f class A, a
  eq shouldBeA, a

  [shouldBeA] = f a, class A
  eq shouldBeA, a

  [obj, klass, shouldBeA] =
    f
      b: 1
      class A
      a
  eq shouldBeA, a

f class
f class A
f class A extends B
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Function Invocation
# -------------------

# * Function Invocation
# * Splats in Function Invocations
# * Implicit Returns
# * Explicit Returns

# shared identity function
id = (_) -> if arguments.length is 1 then _ else [arguments...]

# helper to assert that a string should fail compilation
cantCompile = (code) ->
  throws -> CoffeeScript.compile code

test 'basic argument passing', ->
  a = {}
  b = {}
  c = {}
  eq 1, id 1
  eq 2, id(1, 2)[1]
  eq a, id a
  eq c, id(a, b, c)[2]

test 'passing arguments on separate lines', ->
  a = {}
  b = {}
  c = {}
  ok id(a, b, c)[1] is b
  eq 0, id(0, 10)[0]
  eq a, id a
  eq b, id b

test 'optional parens can be used in a nested fashion', ->
  call = (func) -> func()
  add = (a, b) -> a + b
  result = call ->
    inner = call ->
      add 5, 5
  ok result is 10

test 'hanging commas and semicolons in argument list', ->
  fn = -> arguments.length
  eq 2, fn 0, 1
  eq 3, fn 0, 1, 2
  eq 2, fn 0, 1
  # TODO: this test fails (the string compiles), but should it?
  #throws -> CoffeeScript.compile "fn(0,1,;)"
  throws -> CoffeeScript.compile 'fn(0,1,;;)'
  throws -> CoffeeScript.compile 'fn(0, 1;,)'
  throws -> CoffeeScript.compile 'fn(,0)'
  throws -> CoffeeScript.compile 'fn(;0)'

test 'function invocation', ->
  func = ->
    return if true
  eq undefined, func()

  result = 'hello'.slice 3
  ok result is 'lo'

test 'And even with strange things like this:', ->
  funcs = [
    (x) -> x
    (x) -> x * x
  ]
  result = funcs[1] 5
  ok result is 25

test 'More fun with optional parens.', ->
  fn = (arg) -> arg
  ok fn(fn prop: 101).prop is 101

  okFunc = (f) -> ok f()
  okFunc -> true

test 'chained function calls', ->
  nonce = {}
  identityWrap = (x) ->
    -> x
  eq nonce, identityWrap(identityWrap nonce)()()
  eq nonce, identityWrap(identityWrap nonce)()()

test 'Multi-blocks with optional parens.', ->
  fn = (arg) -> arg
  result = fn ->
    fn ->
      'Wrapped'
  ok result()() is 'Wrapped'

test 'method calls', ->
  fnId = (fn) -> -> fn.apply this, arguments
  math =
    add: (a, b) -> a + b
    anonymousAdd: (a, b) -> a + b
    fastAdd: fnId (a, b) -> a + b
  ok math.add(5, 5) is 10
  ok math.anonymousAdd(10, 10) is 20
  ok math.fastAdd(20, 20) is 40

test 'Ensure that functions can have a trailing comma in their argument list', ->
  mult = (x, mids..., y) ->
    (x *= n) for n in mids
    x *= y
  #ok mult(1, 2,) is 2
  #ok mult(1, 2, 3,) is 6
  ok mult(10, (i for i in [1..6])...) is 7200

test '\`@\` and \`this\` should both be able to invoke a method', ->
  nonce = {}
  fn = (arg) -> eq nonce, arg
  fn.withAt = -> @ nonce
  fn.withThis = -> this nonce
  fn.withAt()
  fn.withThis()

test 'Trying an implicit object call with a trailing function.', ->
  a = null
  meth = (arg, obj, func) -> a = [obj.a, arg, func()].join ' '
  meth 'apple', b: 1, a: 13, ->
    'orange'
  ok a is '13 apple orange'

test "Ensure that empty functions don't return mistaken values.", ->
  obj = func: (@param, @rest...) ->
  ok obj.func(101, 102, 103, 104) is undefined
  ok obj.param is 101
  ok obj.rest.join(' ') is '102 103 104'

test 'Passing multiple functions without paren-wrapping is legal, and should compile.', ->
  sum = (one, two) -> one() + two()
  result = sum(
    ->
      7 + 9
  ,
    ->
      1 + 3
  )
  ok result is 20

test 'Implicit call with a trailing if statement as a param.', ->
  func = -> arguments[1]
  result = func 'one', if false then 100 else 13
  ok result is 13

test 'Test more function passing:', ->
  sum = (one, two) -> one() + two()

  result = sum(
    ->
      1 + 2
  ,
    ->
      2 + 1
  )
  ok result is 6

  sum = (a, b) -> a + b
  result = sum 1, 2
  ok result is 3

test 'Chained blocks, with proper indentation levels:', ->
  counter =
    results: []
    tick: (func) ->
      @results.push func()
      this
  counter
    .tick ->
      3
    .tick ->
      2
    .tick ->
      1
  arrayEq [3, 2, 1], counter.results

test 'This is a crazy one.', ->
  x = (obj, func) -> func obj
  ident = (x) -> x
  result = x one: ident(1), (obj) ->
    inner = ident obj
    ident inner
  ok result.one is 1

test 'More paren compilation tests:', ->
  reverse = (obj) -> obj.reverse()
  ok reverse([1, 2].concat 3).join(' ') is '3 2 1'

test 'Test for inline functions with parentheses and implicit calls.', ->
  combine = (func, num) -> func() * num
  result = combine (-> 1 + 2), 3
  ok result is 9

test 'Test for calls/parens/multiline-chains.', ->
  f = (x) -> x
  result = f(1).toString().length
  ok result is 1

test 'Test implicit calls in functions in parens:', ->
  result =
    ((val) ->
      [].push val
      val
    ) 10
  ok result is 10

test 'Ensure that chained calls with indented implicit object literals below are alright.', ->
  result = null
  obj =
    method: (val) -> this
    second: (hash) -> result = hash.three
  obj.method(101).second
    one:
      two: 2
    three: 3
  eq result, 3

test 'Test newline-supressed call chains with nested functions.', ->
  obj = call: -> this
  func = ->
    obj
      .call ->
        one two
      .call ->
        three four
    101
  eq func(), 101

test 'Implicit objects with number arguments.', ->
  func = (x, y) -> y
  obj = prop: func 'a', 1
  ok obj.prop is 1

test 'Non-spaced unary and binary operators should cause a function call.', ->
  func = (val) -> val + 1
  ok func(+5) is 6
  ok func(-5) is -4

test 'Prefix unary assignment operators are allowed in parenless calls.', ->
  func = (val) -> val + 1
  val = 5
  ok func(--val) is 5

test '#855: execution context for \`func arr...\` should be \`null\`', ->
  contextTest = -> eq @, if window? then window else global
  array = []
  contextTest array
  contextTest.apply null, array
  contextTest array...

test '#904: Destructuring function arguments with same-named variables in scope', ->
  a = b = nonce = {}
  fn = ([a, b]) -> a: a, b: b
  result = fn [(c = {}), (d = {})]
  eq c, result.a
  eq d, result.b
  eq nonce, a
  eq nonce, b

test 'Simple Destructuring function arguments with same-named variables in scope', ->
  x = 1
  f = ([x]) -> x
  eq f([2]), 2
  eq x, 1

test '#4843: Bad output when assigning to @prop in destructuring assignment with defaults', ->
  works = 'maybe'
  drinks = 'beer'
  class A
    constructor: ({ @works = 'no', @drinks = 'wine' }) ->
  a = new A works: 'yes', drinks: 'coffee'
  eq a.works, 'yes'
  eq a.drinks, 'coffee'

test 'caching base value', ->
  obj =
    index: 0
    0: method: -> this is obj[0]
  ok obj[obj.index++].method []...

test 'passing splats to functions', ->
  arrayEq [0..4], id id [0..4]...
  fn = (a, b, c..., d) -> [a, b, c, d]
  range = [0..3]
  [first, second, others, last] = fn range..., 4, [5...8]...
  eq 0, first
  eq 1, second
  arrayEq [2..6], others
  eq 7, last

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  arrayEq [0..4], id id [0..4]...
  fn = (a, b, c..., d) -> [a, b, c, d]
  range = [0..3]
  [first, second, others, last] = fn range..., 4, [5...8]...
  eq 0, first
  eq 1, second
  arrayEq [2..6], others
  eq 7, last

test 'splat variables are local to the function', ->
  outer = 'x'
  clobber = (avar, outer...) -> outer
  clobber 'foo', 'bar'
  eq 'x', outer

test 'Issue 4631: left and right spread dots with preceding space', ->
  a = []
  f = (a) -> a
  eq(
    yes
    f(...a) is
    f(...a) is
    f(a...) is
    f(a...) is
    f(a...) is
    f(...a) is
    f(a...) is
    f(...a)
  )

test 'Issue 894: Splatting against constructor-chained functions.', ->
  x = null
  class Foo
    bar: (y) -> x = y
  new Foo().bar [101]...
  eq x, 101

test 'Functions with splats being called with too few arguments.', ->
  pen = null
  method = (first, variable..., penultimate, ultimate) ->
    pen = penultimate
  method 1, 2, 3, 4, 5, 6, 7, 8, 9
  ok pen is 8
  method 1, 2, 3
  ok pen is 2
  method 1, 2
  ok pen is 2

test 'splats with super() within classes.', ->
  class Parent
    meth: (args...) ->
      args
  class Child extends Parent
    meth: ->
      nums = [3, 2, 1]
      super nums...
  ok new Child().meth().join(' ') is '3 2 1'

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  class Parent
    meth: (args...) ->
      args
  class Child extends Parent
    meth: ->
      nums = [3, 2, 1]
      super nums...
  ok new Child().meth().join(' ') is '3 2 1'

test '#1011: passing a splat to a method of a number', ->
  eq '1011', 11.toString [2]...
  eq '1011', 31.toString [3]...
  eq '1011', 69.0.toString [4]...
  eq '1011', 131.0.toString [5]...

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  eq '1011', 11.toString [2]...
  eq '1011', 31.toString [3]...
  eq '1011', 69.0.toString [4]...
  eq '1011', 131.0.toString [5]...

test 'splats and the \`new\` operator: functions that return \`null\` should construct their instance', ->
  args = []
  child = new (constructor = -> null) args...
  ok child instanceof constructor

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  child = new (constructor = -> null) args...
  ok child instanceof constructor

test 'splats and the \`new\` operator: functions that return functions should construct their return value', ->
  args = []
  fn = ->
  child = new (constructor = -> fn) args...
  ok child not instanceof constructor
  eq fn, child

test 'implicit return', ->
  eq(
    ok
    new (->
      ok
      ### Should \`return\` implicitly   ###
      ### even with trailing comments. ###
    )()
  )

test 'implicit returns with multiple branches', ->
  nonce = {}
  fn = ->
    if false
      for a in b
        return c if d
    else
      nonce
  eq nonce, fn()

test 'implicit returns with switches', ->
  nonce = {}
  fn = ->
    switch nonce
      when nonce then nonce
      else return undefined
  eq nonce, fn()

test 'preserve context when generating closure wrappers for expression conversions', ->
  nonce = {}
  obj =
    property: nonce
    method: ->
      this.result = if false
        10
      else
        'a'
        'b'
        this.property
  eq nonce, obj.method()
  eq nonce, obj.property

test "don't wrap 'pure' statements in a closure", ->
  nonce = {}
  items = [0, 1, 2, 3, nonce, 4, 5]
  fn = (items) ->
    for item in items
      return item if item is nonce
  eq nonce, fn items

test 'usage of \`new\` is careful about where the invocation parens end up', ->
  eq 'object', typeof new (try Array)()
  eq 'object', typeof new (do -> ->)()

test 'implicit call against control structures', ->
  result = null
  save = (obj) -> result = obj

  save(
    switch id false
      when true
        'true'
      when false
        'false'
  )

  eq result, 'false'

  save(
    if id false
      'false'
    else
      'true'
  )

  eq result, 'true'

  save(
    unless id false
      'true'
    else
      'false'
  )

  eq result, 'true'

  save(
    try
      doesnt exist
    catch error
      'caught'
  )

  eq result, 'caught'

  save try doesnt exist catch error then 'caught2'

  eq result, 'caught2'

test '#1420: things like \`(fn() ->)\`; there are no words for this one', ->
  fn = -> (f) -> f()
  nonce = {}
  eq nonce, fn() -> nonce

test "#1416: don't omit one 'new' when compiling 'new new'", ->
  nonce = {}
  obj = new new (-> -> prop: nonce)()()
  eq obj.prop, nonce

test "#1416: don't omit one 'new' when compiling 'new new fn()()'", ->
  nonce = {}
  argNonceA = {}
  argNonceB = {}
  fn = (a) -> (b) -> { a, b, prop: nonce }
  obj = new new fn(argNonceA) argNonceB
  eq obj.prop, nonce
  eq obj.a, argNonceA
  eq obj.b, argNonceB

test '#1840: accessing the \`prototype\` after function invocation should compile', ->
  doesNotThrow -> CoffeeScript.compile 'fn()::prop'

  nonce = {}
  class Test
    id: nonce

  dotAccess = -> Test::
  protoAccess = -> Test

  eq dotAccess().id, nonce
  eq protoAccess()::id, nonce

test "#960: improved 'do'", ->
  do (nonExistent = 'one') ->
    eq nonExistent, 'one'

  overridden = 1
  do (overridden = 2) ->
    eq overridden, 2

  two = 2
  do (one = 1, two, three = 3) ->
    eq one, 1
    eq two, 2
    eq three, 3

  ret = do func = (two) ->
    eq two, 2
    func
  eq ret, func

test '#2617: implicit call before unrelated implicit object', ->
  pass = ->
    true

  result = if pass 1
    one: 1
  eq result.one, 1

test '#2292, b: f (z),(x)', ->
  f = (x, y) -> y
  one = 1
  two = 2
  o = b: f one, two
  eq o.b, 2

test '#2297, Different behaviors on interpreting literal', ->
  foo = (x, y) -> y
  bar = baz: foo 100, on

  eq bar.baz, on

  qux = (x) -> x
  quux = qux corge: foo 100, true

  eq quux.corge, on

  xyzzy =
    e: 1
    f: foo(
      a: 1
      b: 2
    ,
      one: 1
      two: 2
      three: 3
    )
    g:
      a: 1
      b: 2
      c: foo 2,
        one: 1
        two: 2
        three: 3
      d: 3
    four: 4
    h: foo { one: 1, two: 2, three: three: three: 3 }, 2

  eq xyzzy.f.two, 2
  eq xyzzy.g.c.three, 3
  eq xyzzy.four, 4
  eq xyzzy.h, 2

test '#2715, Chained implicit calls', ->
  first = (x) -> x
  second = (x, y) -> y

  foo = first first one: 1
  eq foo.one, 1

  bar = first second { one: 1 }, 2
  eq bar, 2

  baz = first second { one: 1 }, 2
  eq baz, 2

test 'Implicit calls and new', ->
  first = (x) -> x
  foo = (@x) ->
  bar = first new foo first 1
  eq bar.x, 1

  third = (x, y, z) -> z
  baz = first(
    new foo(
      new foo(
        third
          one: 1
          two: 2
        ,
          1
        ,
          three: 3
        ,
          2
      )
    )
  )
  eq baz.x.x.three, 3

test 'Loose tokens inside of explicit call lists', ->
  first = (x) -> x
  second = (x, y) -> y
  one = 1

  foo = second one, 2
  eq foo, 2

  bar = first first one: 1
  eq bar.one, 1

test "Non-callable literals shouldn't compile", ->
  cantCompile '1(2)'
  cantCompile '1 2'
  cantCompile '/t/(2)'
  cantCompile '/t/ 2'
  cantCompile '///t///(2)'
  cantCompile '///t/// 2'
  cantCompile "''(2)"
  cantCompile "'' 2"
  cantCompile '""(2)'
  cantCompile '"" 2'
  cantCompile '""""""(2)'
  cantCompile '"""""" 2'
  cantCompile '{}(2)'
  cantCompile '{} 2'
  cantCompile '[](2)'
  cantCompile '[] 2'
  cantCompile '[2..9] 2'
  cantCompile '[2..9](2)'
  cantCompile '[1..10][2..9] 2'
  cantCompile '[1..10][2..9](2)'

test 'implicit invocation with implicit object literal', ->
  f = (obj) -> eq 1, obj.a

  f a: 1
  obj = if f
    a: 2
  else
    a: 1
  eq 2, obj.a

  f a: 1
  obj = if f
    a: 2
  else
    a: 1
  eq 2, obj.a

  # #3935: Implicit call when the first key of an implicit object has interpolation.
  a = 'a'
  f "#{a}": 1
  obj = if f
    "#{a}": 2
  else
    "#{a}": 1
  eq 2, obj.a

test 'get and set can be used as function names when not ambiguous with \`get\`/\`set\` keywords', ->
  get = (val) -> val
  set = (val) -> val
  eq 2, get(2)
  eq 3, set(3)
  eq 'a', get('a')
  eq 'b', set('b')
  eq 4, get(4)
  eq 5, set(5)
  eq 'c', get('c')
  eq 'd', set('d')

  @get = get
  @set = set
  eq 6, @get 6
  eq 7, @set 7

  get = ({ val }) -> val
  set = ({ val }) -> val
  eq 8, get(val: 8)
  eq 9, set(val: 9)
  eq 'e', get(val: 'e')
  eq 'f', set(val: 'f')
  eq 10, get(val: 10)
  eq 11, set(val: 11)
  eq 'g', get(val: 'g')
  eq 'h', set(val: 'h')

test 'get and set can be used as variable and property names', ->
  get = 2
  set = 3
  eq 2, get
  eq 3, set

  { get } = get: 4
  { set } = set: 5
  eq 4, get
  eq 5, set

test 'get and set can be used as class method names', ->
  class A
    get: -> 2
    set: -> 3

  a = new A()
  eq 2, a.get()
  eq 3, a.set()

  class B
    @get = -> 4
    @set = -> 5

  eq 4, B.get()
  eq 5, B.set()

test '#4524: functions named get or set can be used without parentheses when attached to an object', ->
  obj =
    get: (x) -> x + 2
    set: (x) -> x + 3

  class A
    get: (x) -> x + 4
    set: (x) -> x + 5

  a = new A()

  class B
    get: (x) -> x.value + 6
    set: (x) -> x.value + 7

  b = new B()

  eq 12, obj.get 10
  eq 13, obj.set 10
  eq 12, obj?.get 10
  eq 13, obj?.set 10

  eq 14, a.get 10
  eq 15, a.set 10

  @ten = 10

  eq 12, obj.get @ten
  eq 13, obj.set @ten

  eq 14, a.get @ten
  eq 15, a.set @ten

  obj.obj = obj

  eq 12, obj.obj.get @ten
  eq 13, obj.obj.set @ten

  eq 16, b.get value: 10
  eq 17, b.set value: 10

  eq 16, b.get value: @ten
  eq 17, b.set value: @ten

test '#4836: functions named get or set can be used without parentheses when attached to this or @', ->
  @get = (x) -> x + 2
  @set = (x) -> x + 3
  @a = 4

  eq 12, this.get 10
  eq 13, this.set 10
  eq 12, this?.get 10
  eq 13, this?.set 10
  eq 6, this.get @a
  eq 7, this.set @a
  eq 6, this?.get @a
  eq 7, this?.set @a

  eq 12, @get 10
  eq 13, @set 10
  eq 12, @?.get 10
  eq 13, @?.set 10
  eq 6, @get @a
  eq 7, @set @a
  eq 6, @?.get @a
  eq 7, @?.set @a

test '#4852: functions named get or set can be used without parentheses when attached to this or @, with an argument of an implicit object', ->
  @get = ({ x }) -> x + 2
  @set = ({ x }) -> x + 3

  eq 12, @get x: 10
  eq 13, @set x: 10
  eq 12, @?.get x: 10
  eq 13, @?.set x: 10
  eq 12, this?.get x: 10
  eq 13, this?.set x: 10

test '#4473: variable scope in chained calls', ->
  obj =
    foo: -> this
    bar: (a) ->
      a()
      this

  obj
    .foo(a = 1)
    .bar -> a = 2
  eq a, 2

  obj
    .bar -> b = 2
    .foo(b = 1)
  eq b, 1

  obj
    .foo(c = 1)
    .bar -> c = 2
    .foo(c = 3)
  eq c, 3

  obj
    .foo([d, e] = [1, 2])
    .bar -> d = 4
  eq d, 4

  obj
    .foo({ f } = f: 1)
    .bar -> f = 5
  eq f, 5

test '#5052: implicit call of class with no body', ->
  doesNotThrow -> CoffeeScript.compile 'f class'
  doesNotThrow -> CoffeeScript.compile 'f class A'
  doesNotThrow -> CoffeeScript.compile 'f class A extends B'

  f = (args...) -> args
  a = 1

  [klass, shouldBeA] = f class A, a
  eq shouldBeA, a

  [shouldBeA] = f a, class A
  eq shouldBeA, a

  [obj, klass, shouldBeA] = f { b: 1 }, class A, a
  eq shouldBeA, a

f class
f class A
f class A extends B

`;

exports[`functions.coffee 1`] = `
# Function Literals
# -----------------

# TODO: add indexing and method invocation tests: (->)[0], (->).call()

# * Function Definition
# * Bound Function Definition
# * Parameter List Features
#   * Splat Parameters
#   * Context (@) Parameters
#   * Parameter Destructuring
#   * Default Parameters

# Function Definition

x = 1
y = {}
y.x = -> 3
ok x is 1
ok typeof(y.x) is 'function'
ok y.x instanceof Function
ok y.x() is 3

# The empty function should not cause a syntax error.
->
() ->

# Multiple nested function declarations mixed with implicit calls should not
# cause a syntax error.
(one) -> (two) -> three four, (five) -> six seven, eight, (nine) ->

# with multiple single-line functions on the same line.
func = (x) -> (x) -> (x) -> x
ok func(1)(2)(3) is 3

# Make incorrect indentation safe.
func = ->
  obj = {
          key: 10
        }
  obj.key - 5
eq func(), 5

# Ensure that functions with the same name don't clash with helper functions.
del = -> 5
ok del() is 5


# Bound Function Definition

obj =
  bound: ->
    (=> this)()
  unbound: ->
    (-> this)()
  nested: ->
    (=>
      (=>
        (=> this)()
      )()
    )()
eq obj, obj.bound()
ok obj isnt obj.unbound()
eq obj, obj.nested()


test "even more fancy bound functions", ->
  obj =
    one: ->
      do =>
        return this.two()
    two: ->
      do =>
        do =>
          do =>
            return this.three
    three: 3

  eq obj.one(), 3


test "arguments in bound functions inherit from parent function", ->
  # The \`arguments\` object in an ES arrow function refers to the \`arguments\`
  # of the parent scope, just like \`this\`. In the CoffeeScript 1.x
  # implementation of \`=>\`, the \`arguments\` object referred to the arguments
  # of the arrow function; but per the ES2015 spec, \`arguments\` should refer
  # to the parent.
  arrayEq ((a...) -> a)([1, 2, 3]), ((a...) => a)([1, 2, 3])

  parent = (a, b, c) ->
    (bound = =>
      [arguments[0], arguments[1], arguments[2]]
    )()
  arrayEq [1, 2, 3], parent(1, 2, 3)


test "self-referencing functions", ->
  changeMe = ->
    changeMe = 2

  changeMe()
  eq changeMe, 2


# Parameter List Features

test "splats", ->
  arrayEq [0, 1, 2], (((splat...) -> splat) 0, 1, 2)
  arrayEq [2, 3], (((_, _1, splat...) -> splat) 0, 1, 2, 3)
  arrayEq [0, 1], (((splat..., _, _1) -> splat) 0, 1, 2, 3)
  arrayEq [2], (((_, _1, splat..., _2) -> splat) 0, 1, 2, 3)

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  arrayEq [0, 1, 2], (((splat ...) -> splat) 0, 1, 2)
  arrayEq [2, 3], (((_, _1, splat ...) -> splat) 0, 1, 2, 3)
  arrayEq [0, 1], (((splat ..., _, _1) -> splat) 0, 1, 2, 3)
  arrayEq [2], (((_, _1, splat ..., _2) -> splat) 0, 1, 2, 3)

test "destructured splatted parameters", ->
  arr = [0,1,2]
  splatArray = ([a...]) -> a
  splatArrayRest = ([a...],b...) -> arrayEq(a,b); b
  arrayEq splatArray(arr), arr
  arrayEq splatArrayRest(arr,0,1,2), arr

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  splatArray = ([a ...]) -> a
  splatArrayRest = ([a ...],b ...) -> arrayEq(a,b); b

test "#4884: object-destructured splatted parameters", ->
  f = ({length}...) -> length
  eq f(4, 5, 6), 3
  f = ({length: len}...) -> len
  eq f(4, 5, 6), 3
  f = ({length}..., last) -> [length, last]
  arrayEq f(4, 5, 6), [2, 6]
  f = ({length: len}..., last) -> [len, last]
  arrayEq f(4, 5, 6), [2, 6]

test "@-parameters: automatically assign an argument's value to a property of the context", ->
  nonce = {}

  ((@prop) ->).call context = {}, nonce
  eq nonce, context.prop

  # Allow splats alongside the special argument
  ((splat..., @prop) ->).apply context = {}, [0, 0, nonce]
  eq nonce, context.prop

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  ((splat ..., @prop) ->).apply context = {}, [0, 0, nonce]
  eq nonce, context.prop

  # Allow the argument itself to be a splat
  ((@prop...) ->).call context = {}, 0, nonce, 0
  eq nonce, context.prop[1]

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  ((@prop ...) ->).call context = {}, 0, nonce, 0
  eq nonce, context.prop[1]

  # The argument should not be able to be referenced normally
  code = '((@prop) -> prop).call {}'
  doesNotThrow -> CoffeeScript.compile code
  throws (-> CoffeeScript.run code), ReferenceError
  code = '((@prop) -> _at_prop).call {}'
  doesNotThrow -> CoffeeScript.compile code
  throws (-> CoffeeScript.run code), ReferenceError

test "@-parameters and splats with constructors", ->
  a = {}
  b = {}
  class Klass
    constructor: (@first, splat..., @last) ->

  obj = new Klass a, 0, 0, b
  eq a, obj.first
  eq b, obj.last

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  class Klass
    constructor: (@first, splat ..., @last) ->

  obj = new Klass a, 0, 0, b
  eq a, obj.first
  eq b, obj.last

test "destructuring in function definition", ->
  (([{a: [b], c}]...) ->
    eq 1, b
    eq 2, c
  ) {a: [1], c: 2}

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  (([{a: [b], c}] ...) ->
    eq 1, b
    eq 2, c
  ) {a: [1], c: 2}

  context = {}
  (([{a: [b, c = 2], @d, e = 4}]...) ->
    eq 1, b
    eq 2, c
    eq @d, 3
    eq context.d, 3
    eq e, 4
  ).call context, {a: [1], d: 3}

  (({a: aa = 1, b: bb = 2}) ->
    eq 5, aa
    eq 2, bb
  ) {a: 5}

  ajax = (url, {
    async = true,
    beforeSend = (->),
    cache = true,
    method = 'get',
    data = {}
  }) ->
    {url, async, beforeSend, cache, method, data}

  fn = ->
  deepEqual ajax('/home', beforeSend: fn, method: 'post'), {
    url: '/home', async: true, beforeSend: fn, cache: true, method: 'post', data: {}
  }

test "#4005: \`([a = {}]..., b) ->\` weirdness", ->
  fn = ([a = {}]..., b) -> [a, b]
  deepEqual fn(5), [{}, 5]

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  fn = ([a = {}] ..., b) -> [a, b]
  deepEqual fn(5), [{}, 5]

test "default values", ->
  nonceA = {}
  nonceB = {}
  a = (_,_1,arg=nonceA) -> arg
  eq nonceA, a()
  eq nonceA, a(0)
  eq nonceB, a(0,0,nonceB)
  eq nonceA, a(0,0,undefined)
  eq null, a(0,0,null) # Per ES2015, \`null\` doesn’t trigger a parameter default value
  eq false , a(0,0,false)
  eq nonceB, a(undefined,undefined,nonceB,undefined)
  b = (_,arg=nonceA,_1,_2) -> arg
  eq nonceA, b()
  eq nonceA, b(0)
  eq nonceB, b(0,nonceB)
  eq nonceA, b(0,undefined)
  eq null, b(0,null)
  eq false , b(0,false)
  eq nonceB, b(undefined,nonceB,undefined)
  c = (arg=nonceA,_,_1) -> arg
  eq nonceA, c()
  eq      0, c(0)
  eq nonceB, c(nonceB)
  eq nonceA, c(undefined)
  eq null, c(null)
  eq false , c(false)
  eq nonceB, c(nonceB,undefined,undefined)

test "default values with @-parameters", ->
  a = {}
  b = {}
  obj = f: (q = a, @p = b) -> q
  eq a, obj.f()
  eq b, obj.p

test "default values with splatted arguments", ->
  withSplats = (a = 2, b..., c = 3, d = 5) -> a * (b.length + 1) * c * d
  eq 30, withSplats()
  eq 15, withSplats(1)
  eq  5, withSplats(1,1)
  eq  1, withSplats(1,1,1)
  eq  2, withSplats(1,1,1,1)

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  withSplats = (a = 2, b ..., c = 3, d = 5) -> a * (b.length + 1) * c * d
  eq 30, withSplats()
  eq 15, withSplats(1)
  eq  5, withSplats(1,1)
  eq  1, withSplats(1,1,1)
  eq  2, withSplats(1,1,1,1)

test "#156: parameter lists with expansion", ->
  expandArguments = (first, ..., lastButOne, last) ->
    eq 1, first
    eq 4, lastButOne
    last
  eq 5, expandArguments 1, 2, 3, 4, 5

  throws (-> CoffeeScript.compile "(..., a, b...) ->"), null, "prohibit expansion and a splat"
  throws (-> CoffeeScript.compile "(...) ->"),          null, "prohibit lone expansion"

test "#156: parameter lists with expansion in array destructuring", ->
  expandArray = (..., [..., last]) ->
    last
  eq 3, expandArray 1, 2, 3, [1, 2, 3]

test "#3502: variable definitions and expansion", ->
  a = b = 0
  f = (a, ..., b) -> [a, b]
  arrayEq [1, 5], f 1, 2, 3, 4, 5
  eq 0, a
  eq 0, b

test "variable definitions and splat", ->
  a = b = 0
  f = (a, middle..., b) -> [a, middle, b]
  arrayEq [1, [2, 3, 4], 5], f 1, 2, 3, 4, 5
  eq 0, a
  eq 0, b

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  f = (a, middle ..., b) -> [a, middle, b]
  arrayEq [1, [2, 3, 4], 5], f 1, 2, 3, 4, 5
  eq 0, a
  eq 0, b

test "default values with function calls", ->
  doesNotThrow -> CoffeeScript.compile "(x = f()) ->"

(x = f()) ->

test "arguments vs parameters", ->
  doesNotThrow -> CoffeeScript.compile "f(x) ->"
  f = (g) -> g()
  eq 5, f (x) -> 5

f(x) ->

test "reserved keyword as parameters", ->
  f = (_case, @case) -> [_case, @case]
  [a, b] = f(1, 2)
  eq 1, a
  eq 2, b

  f = (@case, _case...) -> [@case, _case...]
  [a, b, c] = f(1, 2, 3)
  eq 1, a
  eq 2, b
  eq 3, c

test "reserved keyword at-splat", ->
  f = (@case...) -> @case
  [a, b] = f(1, 2)
  eq 1, a
  eq 2, b

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  f = (@case ...) -> @case
  [a, b] = f(1, 2)
  eq 1, a
  eq 2, b

test "#1574: Destructuring and a parameter named _arg", ->
  f = ({a, b}, _arg, _arg1) -> [a, b, _arg, _arg1]
  arrayEq [1, 2, 3, 4], f a: 1, b: 2, 3, 4

test "#1844: bound functions in nested comprehensions causing empty var statements", ->
  a = ((=>) for a in [0] for b in [0])
  eq 1, a.length

test "#1859: inline function bodies shouldn't modify prior postfix ifs", ->
  list = [1, 2, 3]
  return if list.some (x) -> x is 2
  ok no

test "#2258: allow whitespace-style parameter lists in function definitions", ->
  func = (
    a, b, c
  ) -> c
  eq func(1, 2, 3), 3

  func = (
    a
    b
    c
  ) -> b
  eq func(1, 2, 3), 2

test "#2621: fancy destructuring in parameter lists", ->
  func = ({ prop1: { key1 }, prop2: { key2, key3: [a, b, c] } }) ->
    eq(key2, 'key2')
    eq(a, 'a')

  func({prop1: {key1: 'key1'}, prop2: {key2: 'key2', key3: ['a', 'b', 'c']}})

test "#1435 Indented property access", ->
  rec = -> rec: rec

  eq 1, do ->
    rec()
      .rec ->
        rec()
          .rec ->
            rec.rec()
          .rec()
    1

test "#1038 Optimize trailing return statements", ->
  compile = (code) -> CoffeeScript.compile(code, bare: yes).trim().replace(/\\s+/g, " ")

  eq "(function() {});",                 compile("->")
  eq "(function() {});",                 compile("-> return")
  eq "(function() { return void 0; });", compile("-> undefined")
  eq "(function() { return void 0; });", compile("-> return undefined")
  eq "(function() { foo(); });",         compile("""
                                                 ->
                                                   foo()
                                                   return
                                                 """)

test "#4406 Destructured parameter default evaluation order with incrementing variable", ->
  i = 0
  f = ({ a = ++i }, b = ++i) -> [a, b]
  arrayEq f({}), [1, 2]

test "#4406 Destructured parameter default evaluation order with generator function", ->
  current = 0
  next    = -> ++current
  foo = ({ a = next() }, b = next()) -> [ a, b ]
  arrayEq foo({}), [1, 2]

test "Destructured parameter with default value, that itself has a default value", ->
  # Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment
  draw = ({size = 'big', coords = {x: 0, y: 0}, radius = 25} = {}) -> "#{size}-#{coords.x}-#{coords.y}-#{radius}"
  output = draw
    coords:
      x: 18
      y: 30
    radius: 30
  eq output, 'big-18-30-30'

test "#4566: destructuring with nested default values", ->
  f = ({a: {b = 1}}) ->
    b
  eq 2, f a: b: 2

test "#1043: comma after function glyph", ->
  x = (a=->, b=2) ->
    a()
  eq x(), undefined

  f = (a) -> a()
  g = f ->, 2
  eq g, undefined
  h = f(=>, 2)
  eq h, undefined

test "#3845/#3446: chain after function glyph", ->
  angular = module: -> controller: -> controller: ->

  eq undefined,
    angular.module 'foo'
    .controller 'EmailLoginCtrl', ->
    .controller 'EmailSignupCtrl', ->

  beforeEach = (f) -> f()
  getPromise = -> then: -> catch: ->

  eq undefined,
    beforeEach ->
      getPromise()
      .then (@result) =>
      .catch (@error) =>

  doThing = -> then: -> catch: (f) -> f()
  handleError = -> 3
  eq 3,
    doThing()
    .then (@result) =>
    .catch handleError

test "#4413: expressions in function parameters that create generated variables have those variables declared correctly", ->
  'use strict'
  # We’re in strict mode because we want an error to be thrown if the generated
  # variable (\`ref\`) is assigned before being declared.
  foo = -> null
  bar = -> 33
  f = (a = foo() ? bar()) -> a
  g = (a = foo() ? bar()) -> a + 1
  eq f(), 33
  eq g(), 34

test "#4657: destructured array param declarations", ->
  a = 1
  b = 2
  f = ([a..., b]) ->
  f [3, 4, 5]
  eq a, 1
  eq b, 2

test "#4657: destructured array parameters", ->
  f = ([a..., b]) -> {a, b}
  result = f [1, 2, 3, 4]
  arrayEq result.a, [1, 2, 3]
  eq result.b, 4

# TODO: add tests for newly supported shouldCache() params with default eg ([..., last] = 1) ->, (..., [..., last] = 1) ->
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Function Literals
# -----------------

# TODO: add indexing and method invocation tests: (->)[0], (->).call()

# * Function Definition
# * Bound Function Definition
# * Parameter List Features
#   * Splat Parameters
#   * Context (@) Parameters
#   * Parameter Destructuring
#   * Default Parameters

# Function Definition

x = 1
y = {}
y.x = -> 3
ok x is 1
ok typeof y.x is 'function'
ok y.x instanceof Function
ok y.x() is 3

# The empty function should not cause a syntax error.
->
->

# Multiple nested function declarations mixed with implicit calls should not
# cause a syntax error.
(one) -> (two) -> three four, (five) -> six seven, eight, (nine) ->

# with multiple single-line functions on the same line.
func = (x) -> (x) -> (x) -> x
ok func(1)(2)(3) is 3

# Make incorrect indentation safe.
func = ->
  obj =
    key: 10
  obj.key - 5
eq func(), 5

# Ensure that functions with the same name don't clash with helper functions.
del = -> 5
ok del() is 5

# Bound Function Definition

obj =
  bound: ->
    (=> this)()
  unbound: ->
    (-> this)()
  nested: ->
    (=>
      (=>
        (=> this)()
      )()
    )()
eq obj, obj.bound()
ok obj isnt obj.unbound()
eq obj, obj.nested()

test 'even more fancy bound functions', ->
  obj =
    one: ->
      do =>
        return this.two()
    two: ->
      do =>
        do =>
          do =>
            return this.three
    three: 3

  eq obj.one(), 3

test 'arguments in bound functions inherit from parent function', ->
  # The \`arguments\` object in an ES arrow function refers to the \`arguments\`
  # of the parent scope, just like \`this\`. In the CoffeeScript 1.x
  # implementation of \`=>\`, the \`arguments\` object referred to the arguments
  # of the arrow function; but per the ES2015 spec, \`arguments\` should refer
  # to the parent.
  arrayEq ((a...) -> a)([1, 2, 3]), ((a...) => a) [1, 2, 3]

  parent = (a, b, c) ->
    (bound = =>
      [arguments[0], arguments[1], arguments[2]]
    )()
  arrayEq [1, 2, 3], parent 1, 2, 3

test 'self-referencing functions', ->
  changeMe = ->
    changeMe = 2

  changeMe()
  eq changeMe, 2

# Parameter List Features

test 'splats', ->
  arrayEq [0, 1, 2], ((splat...) -> splat) 0, 1, 2
  arrayEq [2, 3], ((_, _1, splat...) -> splat) 0, 1, 2, 3
  arrayEq [0, 1], ((splat..., _, _1) -> splat) 0, 1, 2, 3
  arrayEq [2], ((_, _1, splat..., _2) -> splat) 0, 1, 2, 3

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  arrayEq [0, 1, 2], ((splat...) -> splat) 0, 1, 2
  arrayEq [2, 3], ((_, _1, splat...) -> splat) 0, 1, 2, 3
  arrayEq [0, 1], ((splat..., _, _1) -> splat) 0, 1, 2, 3
  arrayEq [2], ((_, _1, splat..., _2) -> splat) 0, 1, 2, 3

test 'destructured splatted parameters', ->
  arr = [0, 1, 2]
  splatArray = ([a...]) -> a
  splatArrayRest = ([a...], b...) ->
    arrayEq a, b
    b
  arrayEq splatArray(arr), arr
  arrayEq splatArrayRest(arr, 0, 1, 2), arr

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  splatArray = ([a...]) -> a
  splatArrayRest = ([a...], b...) ->
    arrayEq a, b
    b

test '#4884: object-destructured splatted parameters', ->
  f = ({ length }...) -> length
  eq f(4, 5, 6), 3
  f = ({ length: len }...) -> len
  eq f(4, 5, 6), 3
  f = ({ length }..., last) -> [length, last]
  arrayEq f(4, 5, 6), [2, 6]
  f = ({ length: len }..., last) -> [len, last]
  arrayEq f(4, 5, 6), [2, 6]

test "@-parameters: automatically assign an argument's value to a property of the context", ->
  nonce = {}

  ((@prop) ->).call (context = {}), nonce
  eq nonce, context.prop

  # Allow splats alongside the special argument
  ((splat..., @prop) ->).apply (context = {}), [0, 0, nonce]
  eq nonce, context.prop

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  ((splat..., @prop) ->).apply (context = {}), [0, 0, nonce]
  eq nonce, context.prop

  # Allow the argument itself to be a splat
  ((@prop...) ->).call (context = {}), 0, nonce, 0
  eq nonce, context.prop[1]

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  ((@prop...) ->).call (context = {}), 0, nonce, 0
  eq nonce, context.prop[1]

  # The argument should not be able to be referenced normally
  code = '((@prop) -> prop).call {}'
  doesNotThrow -> CoffeeScript.compile code
  throws (-> CoffeeScript.run code), ReferenceError
  code = '((@prop) -> _at_prop).call {}'
  doesNotThrow -> CoffeeScript.compile code
  throws (-> CoffeeScript.run code), ReferenceError

test '@-parameters and splats with constructors', ->
  a = {}
  b = {}
  class Klass
    constructor: (@first, splat..., @last) ->

  obj = new Klass a, 0, 0, b
  eq a, obj.first
  eq b, obj.last

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  class Klass
    constructor: (@first, splat..., @last) ->

  obj = new Klass a, 0, 0, b
  eq a, obj.first
  eq b, obj.last

test 'destructuring in function definition', ->
  (([{ a: [b], c }]...) ->
    eq 1, b
    eq 2, c
  ) a: [1], c: 2

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  (([{ a: [b], c }]...) ->
    eq 1, b
    eq 2, c
  ) a: [1], c: 2

  context = {}
  (([{ a: [b, c = 2], @d, e = 4 }]...) ->
    eq 1, b
    eq 2, c
    eq @d, 3
    eq context.d, 3
    eq e, 4
  ).call context, a: [1], d: 3

  (({ a: aa = 1, b: bb = 2 }) ->
    eq 5, aa
    eq 2, bb
  ) a: 5

  ajax = (
    url
    { async = true, beforeSend = ->, cache = true, method = 'get', data = {} }
  ) ->
    { url, async, beforeSend, cache, method, data }

  fn = ->
  deepEqual ajax('/home', beforeSend: fn, method: 'post'),
    url: '/home'
    async: true
    beforeSend: fn
    cache: true
    method: 'post'
    data: {}

test '#4005: \`([a = {}]..., b) ->\` weirdness', ->
  fn = ([a = {}]..., b) -> [a, b]
  deepEqual fn(5), [{}, 5]

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  fn = ([a = {}]..., b) -> [a, b]
  deepEqual fn(5), [{}, 5]

test 'default values', ->
  nonceA = {}
  nonceB = {}
  a = (_, _1, arg = nonceA) -> arg
  eq nonceA, a()
  eq nonceA, a 0
  eq nonceB, a 0, 0, nonceB
  eq nonceA, a 0, 0, undefined
  eq null, a 0, 0, null # Per ES2015, \`null\` doesn’t trigger a parameter default value
  eq false, a 0, 0, false
  eq nonceB, a undefined, undefined, nonceB, undefined
  b = (_, arg = nonceA, _1, _2) -> arg
  eq nonceA, b()
  eq nonceA, b 0
  eq nonceB, b 0, nonceB
  eq nonceA, b 0, undefined
  eq null, b 0, null
  eq false, b 0, false
  eq nonceB, b undefined, nonceB, undefined
  c = (arg = nonceA, _, _1) -> arg
  eq nonceA, c()
  eq 0, c 0
  eq nonceB, c nonceB
  eq nonceA, c undefined
  eq null, c null
  eq false, c false
  eq nonceB, c nonceB, undefined, undefined

test 'default values with @-parameters', ->
  a = {}
  b = {}
  obj = f: (q = a, @p = b) -> q
  eq a, obj.f()
  eq b, obj.p

test 'default values with splatted arguments', ->
  withSplats = (a = 2, b..., c = 3, d = 5) -> a * (b.length + 1) * c * d
  eq 30, withSplats()
  eq 15, withSplats 1
  eq 5, withSplats 1, 1
  eq 1, withSplats 1, 1, 1
  eq 2, withSplats 1, 1, 1, 1

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  withSplats = (a = 2, b..., c = 3, d = 5) -> a * (b.length + 1) * c * d
  eq 30, withSplats()
  eq 15, withSplats 1
  eq 5, withSplats 1, 1
  eq 1, withSplats 1, 1, 1
  eq 2, withSplats 1, 1, 1, 1

test '#156: parameter lists with expansion', ->
  expandArguments = (first, ..., lastButOne, last) ->
    eq 1, first
    eq 4, lastButOne
    last
  eq 5, expandArguments 1, 2, 3, 4, 5

  throws(
    -> CoffeeScript.compile '(..., a, b...) ->'
    null
    'prohibit expansion and a splat'
  )
  throws (-> CoffeeScript.compile '(...) ->'), null, 'prohibit lone expansion'

test '#156: parameter lists with expansion in array destructuring', ->
  expandArray = (..., [..., last]) ->
    last
  eq 3, expandArray 1, 2, 3, [1, 2, 3]

test '#3502: variable definitions and expansion', ->
  a = b = 0
  f = (a, ..., b) -> [a, b]
  arrayEq [1, 5], f 1, 2, 3, 4, 5
  eq 0, a
  eq 0, b

test 'variable definitions and splat', ->
  a = b = 0
  f = (a, middle..., b) -> [a, middle, b]
  arrayEq [1, [2, 3, 4], 5], f 1, 2, 3, 4, 5
  eq 0, a
  eq 0, b

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  f = (a, middle..., b) -> [a, middle, b]
  arrayEq [1, [2, 3, 4], 5], f 1, 2, 3, 4, 5
  eq 0, a
  eq 0, b

test 'default values with function calls', ->
  doesNotThrow -> CoffeeScript.compile '(x = f()) ->'

(x = f()) ->

test 'arguments vs parameters', ->
  doesNotThrow -> CoffeeScript.compile 'f(x) ->'
  f = (g) -> g()
  eq 5, f (x) -> 5

f(x) ->

test 'reserved keyword as parameters', ->
  f = (_case, @case) -> [_case, @case]
  [a, b] = f 1, 2
  eq 1, a
  eq 2, b

  f = (@case, _case...) -> [@case, _case...]
  [a, b, c] = f 1, 2, 3
  eq 1, a
  eq 2, b
  eq 3, c

test 'reserved keyword at-splat', ->
  f = (@case...) -> @case
  [a, b] = f 1, 2
  eq 1, a
  eq 2, b

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  f = (@case...) -> @case
  [a, b] = f 1, 2
  eq 1, a
  eq 2, b

test '#1574: Destructuring and a parameter named _arg', ->
  f = ({ a, b }, _arg, _arg1) -> [a, b, _arg, _arg1]
  arrayEq [1, 2, 3, 4], f { a: 1, b: 2 }, 3, 4

test '#1844: bound functions in nested comprehensions causing empty var statements', ->
  a = ((=>) for a in [0] for b in [0])
  eq 1, a.length

test "#1859: inline function bodies shouldn't modify prior postfix ifs", ->
  list = [1, 2, 3]
  return if list.some (x) -> x is 2
  ok no

test '#2258: allow whitespace-style parameter lists in function definitions', ->
  func = (a, b, c) -> c
  eq func(1, 2, 3), 3

  func = (a, b, c) -> b
  eq func(1, 2, 3), 2

test '#2621: fancy destructuring in parameter lists', ->
  func = ({ prop1: { key1 }, prop2: { key2, key3: [a, b, c] } }) ->
    eq key2, 'key2'
    eq a, 'a'

  func prop1: { key1: 'key1' }, prop2: key2: 'key2', key3: ['a', 'b', 'c']

test '#1435 Indented property access', ->
  rec = -> rec: rec

  eq 1, do ->
    rec().rec ->
      rec()
        .rec ->
          rec.rec()
        .rec()
    1

test '#1038 Optimize trailing return statements', ->
  compile = (code) ->
    CoffeeScript.compile code, bare: yes
      .trim()
      .replace /\\s+/g, ' '

  eq '(function() {});', compile '->'
  eq '(function() {});', compile '-> return'
  eq '(function() { return void 0; });', compile '-> undefined'
  eq '(function() { return void 0; });', compile '-> return undefined'
  eq(
    '(function() { foo(); });'
    compile '''
                                                 ->
                                                   foo()
                                                   return
                                                 '''
  )

test '#4406 Destructured parameter default evaluation order with incrementing variable', ->
  i = 0
  f = ({ a = ++i }, b = ++i) -> [a, b]
  arrayEq f({}), [1, 2]

test '#4406 Destructured parameter default evaluation order with generator function', ->
  current = 0
  next = -> ++current
  foo = ({ a = next() }, b = next()) -> [a, b]
  arrayEq foo({}), [1, 2]

test 'Destructured parameter with default value, that itself has a default value', ->
  # Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment
  draw = ({ size = 'big', coords = { x: 0, y: 0 }, radius = 25 } = {}) ->
    "#{size}-#{coords.x}-#{coords.y}-#{radius}"
  output = draw(
    coords:
      x: 18
      y: 30
    radius: 30
  )
  eq output, 'big-18-30-30'

test '#4566: destructuring with nested default values', ->
  f = ({ a: { b = 1 } }) ->
    b
  eq 2, f a: b: 2

test '#1043: comma after function glyph', ->
  x = (a = ->, b = 2) ->
    a()
  eq x(), undefined

  f = (a) -> a()
  g = f (->), 2
  eq g, undefined
  h = f (=>), 2
  eq h, undefined

test '#3845/#3446: chain after function glyph', ->
  angular = module: -> controller: -> controller: ->

  eq(
    undefined
    angular
      .module 'foo'
      .controller 'EmailLoginCtrl', ->
      .controller 'EmailSignupCtrl', ->
  )

  beforeEach = (f) -> f()
  getPromise = -> then: -> catch: ->

  eq(
    undefined
    beforeEach ->
      getPromise()
        .then (@result) =>
        .catch (@error) =>
  )

  doThing = -> then: -> catch: (f) -> f()
  handleError = -> 3
  eq(
    3
    doThing()
      .then (@result) =>
      .catch handleError
  )

test '#4413: expressions in function parameters that create generated variables have those variables declared correctly', ->
  'use strict'
  # We’re in strict mode because we want an error to be thrown if the generated
  # variable (\`ref\`) is assigned before being declared.
  foo = -> null
  bar = -> 33
  f = (a = foo() ? bar()) -> a
  g = (a = foo() ? bar()) -> a + 1
  eq f(), 33
  eq g(), 34

test '#4657: destructured array param declarations', ->
  a = 1
  b = 2
  f = ([a..., b]) ->
  f [3, 4, 5]
  eq a, 1
  eq b, 2

test '#4657: destructured array parameters', ->
  f = ([a..., b]) -> { a, b }
  result = f [1, 2, 3, 4]
  arrayEq result.a, [1, 2, 3]
  eq result.b, 4

# TODO: add tests for newly supported shouldCache() params with default eg ([..., last] = 1) ->, (..., [..., last] = 1) ->

`;

exports[`generators.coffee 1`] = `
# Generators
# -----------------
#
# * Generator Definition

test "most basic generator support", ->
  ok -> yield

test "empty generator", ->
  x = do -> yield return

  y = x.next()
  ok y.value is undefined and y.done is true

test "generator iteration", ->
  x = do ->
    yield 0
    yield
    yield 2
    3

  y = x.next()
  ok y.value is 0 and y.done is false

  y = x.next()
  ok y.value is undefined and y.done is false

  y = x.next()
  ok y.value is 2 and y.done is false

  y = x.next()
  ok y.value is 3 and y.done is true

test "last line yields are returned", ->
  x = do ->
    yield 3
  y = x.next()
  ok y.value is 3 and y.done is false

  y = x.next 42
  ok y.value is 42 and y.done is true

test "yield return can be used anywhere in the function body", ->
  x = do ->
    if 2 is yield 1
      yield return 42
    throw new Error "this code shouldn't be reachable"

  y = x.next()
  ok y.value is 1 and y.done is false

  y = x.next 2
  ok y.value is 42 and y.done is true

test "\`yield from\` support", ->
  x = do ->
    yield from do ->
      yield i for i in [3..4]

  y = x.next()
  ok y.value is 3 and y.done is false

  y = x.next 1
  ok y.value is 4 and y.done is false

  y = x.next 2
  arrayEq y.value, [1, 2]
  ok y.done is true

test "error if \`yield from\` occurs outside of a function", ->
  throws -> CoffeeScript.compile 'yield from 1'

test "\`yield from\` at the end of a function errors", ->
  throws -> CoffeeScript.compile 'x = -> x = 1; yield from'

test "yield in if statements", ->
  x = do -> if 1 is yield 2 then 3 else 4

  y = x.next()
  ok y.value is 2 and y.done is false

  y = x.next 1
  ok y.value is 3 and y.done is true

test "yielding if statements", ->
  x = do -> yield if true then 3 else 4

  y = x.next()
  ok y.value is 3 and y.done is false

  y = x.next 42
  ok y.value is 42 and y.done is true

test "yield in for loop expressions", ->
  x = do ->
    y = for i in [1..3]
      yield i * 2

  z = x.next()
  ok z.value is 2 and z.done is false

  z = x.next 10
  ok z.value is 4 and z.done is false

  z = x.next 20
  ok z.value is 6 and z.done is false

  z = x.next 30
  arrayEq z.value, [10, 20, 30]
  ok z.done is true

test "yield in switch expressions", ->
  x = do ->
    y = switch yield 1
      when 2 then yield 1337
      else 1336

  z = x.next()
  ok z.value is 1 and z.done is false

  z = x.next 2
  ok z.value is 1337 and z.done is false

  z = x.next 3
  ok z.value is 3 and z.done is true

test "yielding switch expressions", ->
  x = do ->
    yield switch 1337
      when 1337 then 1338
      else 1336

  y = x.next()
  ok y.value is 1338 and y.done is false

  y = x.next 42
  ok y.value is 42 and y.done is true

test "yield in try expressions", ->
  x = do ->
    try yield 1 catch

  y = x.next()
  ok y.value is 1 and y.done is false

  y = x.next 42
  ok y.value is 42 and y.done is true

test "yielding try expressions", ->
  x = do ->
    yield try 1

  y = x.next()
  ok y.value is 1 and y.done is false

  y = x.next 42
  ok y.value is 42 and y.done is true

test "\`yield\` can be thrown", ->
  x = do ->
    throw yield null
  x.next()
  throws -> x.next new Error "boom"

test "\`throw\` can be yielded", ->
  x = do ->
    yield throw new Error "boom"
  throws -> x.next()

test "symbolic operators has precedence over the \`yield\`", ->
  symbolic   = '+ - * / << >> & | || && ^ // or and'.split ' '
  compound   = ("#{op}=" for op in symbolic)
  relations  = '< > == != <= >= is isnt'.split ' '

  operators  = [symbolic..., '=', compound..., relations...]

  collect = (gen) -> ref.value until (ref = gen.next()).done

  values = [0, 1, 2, 3]
  for op in operators
    expression = "i #{op} 2"

    yielded = CoffeeScript.eval "(arr) ->  yield #{expression} for i in arr"
    mapped  = CoffeeScript.eval "(arr) ->       (#{expression} for i in arr)"

    arrayEq mapped(values), collect yielded values

test "yield handles 'this' correctly", ->
  x = ->
    yield switch
      when true then yield => this
    array = for item in [1]
      yield => this
    yield array
    yield if true then yield => this
    yield try throw yield => this
    throw yield => this

  y = x.call [1, 2, 3]

  z = y.next()
  arrayEq z.value(), [1, 2, 3]
  ok z.done is false

  z = y.next 123
  ok z.value is 123 and z.done is false

  z = y.next()
  arrayEq z.value(), [1, 2, 3]
  ok z.done is false

  z = y.next 42
  arrayEq z.value, [42]
  ok z.done is false

  z = y.next()
  arrayEq z.value(), [1, 2, 3]
  ok z.done is false

  z = y.next 456
  ok z.value is 456 and z.done is false

  z = y.next()
  arrayEq z.value(), [1, 2, 3]
  ok z.done is false

  z = y.next new Error "ignore me"
  ok z.value is undefined and z.done is false

  z = y.next()
  arrayEq z.value(), [1, 2, 3]
  ok z.done is false

  throws -> y.next new Error "boom"

test "for-from loops over generators", ->
  array1 = [50, 30, 70, 20]
  gen = -> yield from array1

  array2 = []
  array3 = []
  array4 = []

  iterator = gen()
  for x from iterator
    array2.push(x)
    break if x is 30

  for x from iterator
    array3.push(x)

  for x from iterator
    array4.push(x)

  arrayEq array2, [50, 30]
  # Different JS engines have different opinions on the value of array3:
  # https://github.com/jashkenas/coffeescript/pull/4306#issuecomment-257066877
  # As a temporary measure, either result is accepted.
  ok array3.length is 0 or array3.join(',') is '70,20'
  arrayEq array4, []

test "for-from comprehensions over generators", ->
  gen = ->
    yield from [30, 41, 51, 60]

  iterator = gen()
  array1 = (x for x from iterator when x %% 2 is 1)
  array2 = (x for x from iterator)

  ok array1.join(' ') is '41 51'
  ok array2.length is 0

test "from as an iterable variable name in a for loop declaration", ->
  from = [1, 2, 3]
  out = []
  for i from from
    out.push i
  arrayEq from, out

test "from as an iterator variable name in a for loop declaration", ->
  a = [1, 2, 3]
  b = []
  for from from a
    b.push from
  arrayEq a, b

test "from as a destructured object variable name in a for loop declaration", ->
  a = [
      from: 1
      to: 2
    ,
      from: 3
      to: 4
  ]
  b = []
  for {from, to} in a
    b.push from
  arrayEq b, [1, 3]

  c = []
  for {to, from} in a
    c.push from
  arrayEq c, [1, 3]

test "from as a destructured, aliased object variable name in a for loop declaration", ->
  a = [
      b: 1
      c: 2
    ,
      b: 3
      c: 4
  ]
  out = []

  for {b: from} in a
    out.push from
  arrayEq out, [1, 3]

test "from as a destructured array variable name in a for loop declaration", ->
  a = [
    [1, 2]
    [3, 4]
  ]
  b = []
  for [from, to] from a
    b.push from
  arrayEq b, [1, 3]

test "generator methods in classes", ->
  class Base
    @static: ->
      yield 1
    method: ->
      yield 2

  arrayEq [1], Array.from Base.static()
  arrayEq [2], Array.from new Base().method()

  class Child extends Base
    @static: -> super()
    method: -> super()

  arrayEq [1], Array.from Child.static()
  arrayEq [2], Array.from new Child().method()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Generators
# -----------------
#
# * Generator Definition

test 'most basic generator support', ->
  ok -> yield

test 'empty generator', ->
  x = do -> yield return

  y = x.next()
  ok y.value is undefined and y.done is true

test 'generator iteration', ->
  x = do ->
    yield 0
    yield
    yield 2
    3

  y = x.next()
  ok y.value is 0 and y.done is false

  y = x.next()
  ok y.value is undefined and y.done is false

  y = x.next()
  ok y.value is 2 and y.done is false

  y = x.next()
  ok y.value is 3 and y.done is true

test 'last line yields are returned', ->
  x = do ->
    yield 3
  y = x.next()
  ok y.value is 3 and y.done is false

  y = x.next 42
  ok y.value is 42 and y.done is true

test 'yield return can be used anywhere in the function body', ->
  x = do ->
    if 2 is (yield 1)
      yield return 42
    throw new Error "this code shouldn't be reachable"

  y = x.next()
  ok y.value is 1 and y.done is false

  y = x.next 2
  ok y.value is 42 and y.done is true

test '\`yield from\` support', ->
  x = do ->
    yield from do ->
      yield i for i in [3..4]

  y = x.next()
  ok y.value is 3 and y.done is false

  y = x.next 1
  ok y.value is 4 and y.done is false

  y = x.next 2
  arrayEq y.value, [1, 2]
  ok y.done is true

test 'error if \`yield from\` occurs outside of a function', ->
  throws -> CoffeeScript.compile 'yield from 1'

test '\`yield from\` at the end of a function errors', ->
  throws -> CoffeeScript.compile 'x = -> x = 1; yield from'

test 'yield in if statements', ->
  x = do -> if 1 is (yield 2) then 3 else 4

  y = x.next()
  ok y.value is 2 and y.done is false

  y = x.next 1
  ok y.value is 3 and y.done is true

test 'yielding if statements', ->
  x = do -> yield if true then 3 else 4

  y = x.next()
  ok y.value is 3 and y.done is false

  y = x.next 42
  ok y.value is 42 and y.done is true

test 'yield in for loop expressions', ->
  x = do ->
    y = for i in [1..3]
      yield i * 2

  z = x.next()
  ok z.value is 2 and z.done is false

  z = x.next 10
  ok z.value is 4 and z.done is false

  z = x.next 20
  ok z.value is 6 and z.done is false

  z = x.next 30
  arrayEq z.value, [10, 20, 30]
  ok z.done is true

test 'yield in switch expressions', ->
  x = do ->
    y = switch yield 1
      when 2 then yield 1337
      else 1336

  z = x.next()
  ok z.value is 1 and z.done is false

  z = x.next 2
  ok z.value is 1337 and z.done is false

  z = x.next 3
  ok z.value is 3 and z.done is true

test 'yielding switch expressions', ->
  x = do ->
    yield switch 1337
      when 1337 then 1338
      else 1336

  y = x.next()
  ok y.value is 1338 and y.done is false

  y = x.next 42
  ok y.value is 42 and y.done is true

test 'yield in try expressions', ->
  x = do ->
    try yield 1 catch

  y = x.next()
  ok y.value is 1 and y.done is false

  y = x.next 42
  ok y.value is 42 and y.done is true

test 'yielding try expressions', ->
  x = do ->
    yield try 1

  y = x.next()
  ok y.value is 1 and y.done is false

  y = x.next 42
  ok y.value is 42 and y.done is true

test '\`yield\` can be thrown', ->
  x = do ->
    throw yield null
  x.next()
  throws -> x.next new Error 'boom'

test '\`throw\` can be yielded', ->
  x = do ->
    yield throw new Error 'boom'
  throws -> x.next()

test 'symbolic operators has precedence over the \`yield\`', ->
  symbolic = '+ - * / << >> & | || && ^ // or and'.split ' '
  compound = ("#{op}=" for op in symbolic)
  relations = '< > == != <= >= is isnt'.split ' '

  operators = [symbolic..., '=', compound..., relations...]

  collect = (gen) -> ref.value until (ref = gen.next()).done

  values = [0, 1, 2, 3]
  for op in operators
    expression = "i #{op} 2"

    yielded = CoffeeScript.eval "(arr) ->  yield #{expression} for i in arr"
    mapped = CoffeeScript.eval "(arr) ->       (#{expression} for i in arr)"

    arrayEq mapped(values), collect yielded values

test "yield handles 'this' correctly", ->
  x = ->
    yield switch
      when true then yield => this
    array = for item in [1]
      yield => this
    yield array
    yield if true then yield => this
    yield try throw yield => this
    throw yield => this

  y = x.call [1, 2, 3]

  z = y.next()
  arrayEq z.value(), [1, 2, 3]
  ok z.done is false

  z = y.next 123
  ok z.value is 123 and z.done is false

  z = y.next()
  arrayEq z.value(), [1, 2, 3]
  ok z.done is false

  z = y.next 42
  arrayEq z.value, [42]
  ok z.done is false

  z = y.next()
  arrayEq z.value(), [1, 2, 3]
  ok z.done is false

  z = y.next 456
  ok z.value is 456 and z.done is false

  z = y.next()
  arrayEq z.value(), [1, 2, 3]
  ok z.done is false

  z = y.next new Error 'ignore me'
  ok z.value is undefined and z.done is false

  z = y.next()
  arrayEq z.value(), [1, 2, 3]
  ok z.done is false

  throws -> y.next new Error 'boom'

test 'for-from loops over generators', ->
  array1 = [50, 30, 70, 20]
  gen = -> yield from array1

  array2 = []
  array3 = []
  array4 = []

  iterator = gen()
  for x from iterator
    array2.push x
    break if x is 30

  for x from iterator
    array3.push x

  for x from iterator
    array4.push x

  arrayEq array2, [50, 30]
  # Different JS engines have different opinions on the value of array3:
  # https://github.com/jashkenas/coffeescript/pull/4306#issuecomment-257066877
  # As a temporary measure, either result is accepted.
  ok array3.length is 0 or array3.join(',') is '70,20'
  arrayEq array4, []

test 'for-from comprehensions over generators', ->
  gen = ->
    yield from [30, 41, 51, 60]

  iterator = gen()
  array1 = (x for x from iterator when x %% 2 is 1)
  array2 = (x for x from iterator)

  ok array1.join(' ') is '41 51'
  ok array2.length is 0

test 'from as an iterable variable name in a for loop declaration', ->
  from = [1, 2, 3]
  out = []
  for i from from
    out.push i
  arrayEq from, out

test 'from as an iterator variable name in a for loop declaration', ->
  a = [1, 2, 3]
  b = []
  for from from a
    b.push from
  arrayEq a, b

test 'from as a destructured object variable name in a for loop declaration', ->
  a = [
    from: 1
    to: 2
  ,
    from: 3
    to: 4
  ]
  b = []
  for { from, to } in a
    b.push from
  arrayEq b, [1, 3]

  c = []
  for { to, from } in a
    c.push from
  arrayEq c, [1, 3]

test 'from as a destructured, aliased object variable name in a for loop declaration', ->
  a = [
    b: 1
    c: 2
  ,
    b: 3
    c: 4
  ]
  out = []

  for { b: from } in a
    out.push from
  arrayEq out, [1, 3]

test 'from as a destructured array variable name in a for loop declaration', ->
  a = [[1, 2], [3, 4]]
  b = []
  for [from, to] from a
    b.push from
  arrayEq b, [1, 3]

test 'generator methods in classes', ->
  class Base
    @static: ->
      yield 1
    method: ->
      yield 2

  arrayEq [1], Array.from Base.static()
  arrayEq [2], Array.from new Base().method()

  class Child extends Base
    @static: -> super()
    method: -> super()

  arrayEq [1], Array.from Child.static()
  arrayEq [2], Array.from new Child().method()

`;

exports[`helpers.coffee 1`] = `
# Helpers
# -------

# pull the helpers from \`CoffeeScript.helpers\` into local variables
{starts, ends, repeat, compact, count, merge, extend, flatten, del, baseFileName} = CoffeeScript.helpers


# \`starts\`

test "the \`starts\` helper tests if a string starts with another string", ->
  ok     starts('01234', '012')
  ok not starts('01234', '123')

test "the \`starts\` helper can take an optional offset", ->
  ok     starts('01234', '34', 3)
  ok not starts('01234', '01', 1)


# \`ends\`

test "the \`ends\` helper tests if a string ends with another string", ->
  ok     ends('01234', '234')
  ok not ends('01234', '012')

test "the \`ends\` helper can take an optional offset", ->
  ok     ends('01234', '012', 2)
  ok not ends('01234', '234', 6)


# \`repeat\`

test "the \`repeat\` helper concatenates a given number of times", ->
  eq 'asdasdasd', repeat('asd', 3)

test "\`repeat\`ing a string 0 times always returns the empty string", ->
  eq '', repeat('whatever', 0)


# \`compact\`

test "the \`compact\` helper removes falsey values from an array, preserves truthy ones", ->
  allValues = [1, 0, false, obj={}, [], '', ' ', -1, null, undefined, true]
  truthyValues = [1, obj, [], ' ', -1, true]
  arrayEq truthyValues, compact(allValues)


# \`count\`

test "the \`count\` helper counts the number of occurrences of a string in another string", ->
  eq 1/0, count('abc', '')
  eq 0, count('abc', 'z')
  eq 1, count('abc', 'a')
  eq 1, count('abc', 'b')
  eq 2, count('abcdc', 'c')
  eq 2, count('abcdabcd','abc')


# \`merge\`

test "the \`merge\` helper makes a new object with all properties of the objects given as its arguments", ->
  ary = [0, 1, 2, 3, 4]
  obj = {}
  merged = merge obj, ary
  ok merged isnt obj
  ok merged isnt ary
  for own key, val of ary
    eq val, merged[key]


# \`extend\`

test "the \`extend\` helper performs a shallow copy", ->
  ary = [0, 1, 2, 3]
  obj = {}
  # should return the object being extended
  eq obj, extend(obj, ary)
  # should copy the other object's properties as well (obviously)
  eq 2, obj[2]


# \`flatten\`

test "the \`flatten\` helper flattens an array", ->
  success = yes
  (success and= typeof n is 'number') for n in flatten [0, [[[1]], 2], 3, [4]]
  ok success


# \`del\`

test "the \`del\` helper deletes a property from an object and returns the deleted value", ->
  obj = [0, 1, 2]
  eq 1, del(obj, 1)
  ok 1 not of obj


# \`baseFileName\`

test "the \`baseFileName\` helper returns the file name to write to", ->
  ext = '.js'
  sourceToCompiled =
    '.coffee': ext
    'a.coffee': 'a' + ext
    'b.coffee': 'b' + ext
    'coffee.coffee': 'coffee' + ext

    '.litcoffee': ext
    'a.litcoffee': 'a' + ext
    'b.litcoffee': 'b' + ext
    'coffee.litcoffee': 'coffee' + ext

    '.lit': ext
    'a.lit': 'a' + ext
    'b.lit': 'b' + ext
    'coffee.lit': 'coffee' + ext

    '.coffee.md': ext
    'a.coffee.md': 'a' + ext
    'b.coffee.md': 'b' + ext
    'coffee.coffee.md': 'coffee' + ext

  for sourceFileName, expectedFileName of sourceToCompiled
    name = baseFileName sourceFileName, yes
    filename = name + ext
    eq filename, expectedFileName
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Helpers
# -------

# pull the helpers from \`CoffeeScript.helpers\` into local variables
{
  starts
  ends
  repeat
  compact
  count
  merge
  extend
  flatten
  del
  baseFileName
} = CoffeeScript.helpers

# \`starts\`

test 'the \`starts\` helper tests if a string starts with another string', ->
  ok starts '01234', '012'
  ok not starts '01234', '123'

test 'the \`starts\` helper can take an optional offset', ->
  ok starts '01234', '34', 3
  ok not starts '01234', '01', 1

# \`ends\`

test 'the \`ends\` helper tests if a string ends with another string', ->
  ok ends '01234', '234'
  ok not ends '01234', '012'

test 'the \`ends\` helper can take an optional offset', ->
  ok ends '01234', '012', 2
  ok not ends '01234', '234', 6

# \`repeat\`

test 'the \`repeat\` helper concatenates a given number of times', ->
  eq 'asdasdasd', repeat 'asd', 3

test '\`repeat\`ing a string 0 times always returns the empty string', ->
  eq '', repeat 'whatever', 0

# \`compact\`

test 'the \`compact\` helper removes falsey values from an array, preserves truthy ones', ->
  allValues = [1, 0, false, (obj = {}), [], '', ' ', -1, null, undefined, true]
  truthyValues = [1, obj, [], ' ', -1, true]
  arrayEq truthyValues, compact allValues

# \`count\`

test 'the \`count\` helper counts the number of occurrences of a string in another string', ->
  eq 1 / 0, count 'abc', ''
  eq 0, count 'abc', 'z'
  eq 1, count 'abc', 'a'
  eq 1, count 'abc', 'b'
  eq 2, count 'abcdc', 'c'
  eq 2, count 'abcdabcd', 'abc'

# \`merge\`

test 'the \`merge\` helper makes a new object with all properties of the objects given as its arguments', ->
  ary = [0, 1, 2, 3, 4]
  obj = {}
  merged = merge obj, ary
  ok merged isnt obj
  ok merged isnt ary
  for own key, val of ary
    eq val, merged[key]

# \`extend\`

test 'the \`extend\` helper performs a shallow copy', ->
  ary = [0, 1, 2, 3]
  obj = {}
  # should return the object being extended
  eq obj, extend obj, ary
  # should copy the other object's properties as well (obviously)
  eq 2, obj[2]

# \`flatten\`

test 'the \`flatten\` helper flattens an array', ->
  success = yes
  (success and= typeof n is 'number') for n in flatten [0, [[[1]], 2], 3, [4]]
  ok success

# \`del\`

test 'the \`del\` helper deletes a property from an object and returns the deleted value', ->
  obj = [0, 1, 2]
  eq 1, del obj, 1
  ok 1 not of obj

# \`baseFileName\`

test 'the \`baseFileName\` helper returns the file name to write to', ->
  ext = '.js'
  sourceToCompiled =
    '.coffee': ext
    'a.coffee': 'a' + ext
    'b.coffee': 'b' + ext
    'coffee.coffee': 'coffee' + ext

    '.litcoffee': ext
    'a.litcoffee': 'a' + ext
    'b.litcoffee': 'b' + ext
    'coffee.litcoffee': 'coffee' + ext

    '.lit': ext
    'a.lit': 'a' + ext
    'b.lit': 'b' + ext
    'coffee.lit': 'coffee' + ext

    '.coffee.md': ext
    'a.coffee.md': 'a' + ext
    'b.coffee.md': 'b' + ext
    'coffee.coffee.md': 'coffee' + ext

  for sourceFileName, expectedFileName of sourceToCompiled
    name = baseFileName sourceFileName, yes
    filename = name + ext
    eq filename, expectedFileName

`;

exports[`interpolation.coffee 1`] = `
# Interpolation
# -------------

# * String Interpolation
# * Regular Expression Interpolation

# String Interpolation

# TODO: refactor string interpolation tests

eq 'multiline nested "interpolations" work', """multiline #{
  "nested #{
    ok true
    "\\"interpolations\\""
  }"
} work"""

# Issue #923: Tricky interpolation.
eq "#{ "{" }", "{"
eq "#{ '#{}}' } }", '#{}} }'
eq "#{"'#{ ({a: "b#{1}"}['a']) }'"}", "'b1'"

# Issue #1150: String interpolation regression
eq "#{'"/'}",                '"/'
eq "#{"/'"}",                "/'"
eq "#{/'"/}",                '/\\'"/'
eq "#{"'/" + '/"' + /"'/}",  '\\'//"/"\\'/'
eq "#{"'/"}#{'/"'}#{/"'/}",  '\\'//"/"\\'/'
eq "#{6 / 2}",               '3'
eq "#{6 / 2}#{6 / 2}",       '33' # parsed as division
eq "#{6 + /2}#{6/ + 2}",     '6/2}#{6/2' # parsed as a regex
eq "#{6/2}
    #{6/2}",                 '3 3' # newline cannot be part of a regex, so it's division
eq "#{/// "'/'"/" ///}",     '/"\\'\\\\/\\'"\\\\/"/' # heregex, stuffed with spicy characters
eq "#{/\\\\'/}",               "/\\\\\\\\'/"

# Issue #2321: Regex/division conflict in interpolation
eq "#{4/2}/", '2/'
curWidth = 4
eq "<i style='left:#{ curWidth/2 }%;'></i>",   "<i style='left:2%;'></i>"
throws -> CoffeeScript.compile '''
   "<i style='left:#{ curWidth /2 }%;'></i>"'''
#                 valid regex--^^^^^^^^^^^ ^--unclosed string
eq "<i style='left:#{ curWidth/2 }%;'></i>",   "<i style='left:2%;'></i>"
eq "<i style='left:#{ curWidth/ 2 }%;'></i>",  "<i style='left:2%;'></i>"
eq "<i style='left:#{ curWidth / 2 }%;'></i>", "<i style='left:2%;'></i>"

hello = 'Hello'
world = 'World'
ok '#{hello} #{world}!' is '#{hello} #{world}!'
ok "#{hello} #{world}!" is 'Hello World!'
ok "[#{hello}#{world}]" is '[HelloWorld]'
ok "#{hello}##{world}" is 'Hello#World'
ok "Hello #{ 1 + 2 } World" is 'Hello 3 World'
ok "#{hello} #{ 1 + 2 } #{world}" is "Hello 3 World"
ok 1 + "#{2}px" is '12px'
ok isNaN "a#{2}" * 2
ok "#{2}" is '2'
ok "#{2}#{2}" is '22'

[s, t, r, i, n, g] = ['s', 't', 'r', 'i', 'n', 'g']
ok "#{s}#{t}#{r}#{i}#{n}#{g}" is 'string'
ok "\\#{s}\\#{t}\\#{r}\\#{i}\\#{n}\\#{g}" is '#{s}#{t}#{r}#{i}#{n}#{g}'
ok "\\#{string}" is '#{string}'

ok "\\#{Escaping} first" is '#{Escaping} first'
ok "Escaping \\#{in} middle" is 'Escaping #{in} middle'
ok "Escaping \\#{last}" is 'Escaping #{last}'

ok "##" is '##'
ok "#{}" is ''
ok "#{}A#{} #{} #{}B#{}" is 'A  B'
ok "\\\\\\#{}" is '\\\\#{}'

ok "I won ##{20} last night." is 'I won #20 last night.'
ok "I won ##{'#20'} last night." is 'I won ##20 last night.'

ok "#{hello + world}" is 'HelloWorld'
ok "#{hello + ' ' + world + '!'}" is 'Hello World!'

list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
ok "values: #{list.join(', ')}, length: #{list.length}." is 'values: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, length: 10.'
ok "values: #{list.join ' '}" is 'values: 0 1 2 3 4 5 6 7 8 9'

obj = {
  name: 'Joe'
  hi: -> "Hello #{@name}."
  cya: -> "Hello #{@name}.".replace('Hello','Goodbye')
}
ok obj.hi() is "Hello Joe."
ok obj.cya() is "Goodbye Joe."

ok "With #{"quotes"}" is 'With quotes'
ok 'With #{"quotes"}' is 'With #{"quotes"}'

ok "Where is #{obj["name"] + '?'}" is 'Where is Joe?'

ok "Where is #{"the nested #{obj["name"]}"}?" is 'Where is the nested Joe?'
ok "Hello #{world ? "#{hello}"}" is 'Hello World'

ok "Hello #{"#{"#{obj["name"]}" + '!'}"}" is 'Hello Joe!'

a = """
    Hello #{ "Joe" }
    """
ok a is "Hello Joe"

a = 1
b = 2
c = 3
ok "#{a}#{b}#{c}" is '123'

result = null
stash = (str) -> result = str
stash "a #{ ('aa').replace /a/g, 'b' } c"
ok result is 'a bb c'

foo = "hello"
ok "#{foo.replace("\\"", "")}" is 'hello'

val = 10
a = """
    basic heredoc #{val}
    on two lines
    """
b = '''
    basic heredoc #{val}
    on two lines
    '''
ok a is "basic heredoc 10\\non two lines"
ok b is "basic heredoc \\#{val}\\non two lines"

eq 'multiline nested "interpolations" work', """multiline #{
  "nested #{(->
    ok yes
    "\\"interpolations\\""
  )()}"
} work"""

eq 'function(){}', "#{->}".replace /\\s/g, ''
ok /^a[\\s\\S]+b$/.test "a#{=>}b"
ok /^a[\\s\\S]+b$/.test "a#{ (x) -> x %% 2 }b"

# Regular Expression Interpolation

# TODO: improve heregex interpolation tests

test "heregex interpolation", ->
  eq /\\\\#{}\\\\"/ + '', ///
   #{
     "#{ '\\\\' }" # normal comment
   }
   # regex comment
   \\#{}
   \\\\ "
  /// + ''
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Interpolation
# -------------

# * String Interpolation
# * Regular Expression Interpolation

# String Interpolation

# TODO: refactor string interpolation tests

eq(
  'multiline nested "interpolations" work'
  """multiline #{"nested #{
    ok true
    '"interpolations"'
  }"} work"""
)

# Issue #923: Tricky interpolation.
eq "#{'{'}", '{'
eq "#{'#{}}'} }", '#{}} }'
eq "#{"'#{{ a: "b#{1}" }['a']}'"}", "'b1'"

# Issue #1150: String interpolation regression
eq "#{'"/'}", '"/'
eq "#{"/'"}", "/'"
eq "#{/'"/}", '/\\'"/'
eq "#{"'/" + '/"' + /"'/}", '\\'//"/"\\'/'
eq "#{"'/"}#{'/"'}#{/"'/}", '\\'//"/"\\'/'
eq "#{6 / 2}", '3'
eq "#{6 / 2}#{6 / 2}", '33' # parsed as division
eq "#{6 + /2}#{6/ + 2}", '6/2}#{6/2' # parsed as a regex
eq(
  "#{6 / 2}
    #{6 / 2}"
  '3 3'
) # newline cannot be part of a regex, so it's division
eq "#{/// "'/'"/" ///}", '/"\\'\\\\/\\'"\\\\/"/' # heregex, stuffed with spicy characters
eq "#{/\\\\'/}", "/\\\\\\\\'/"

# Issue #2321: Regex/division conflict in interpolation
eq "#{4 / 2}/", '2/'
curWidth = 4
eq "<i style='left:#{curWidth / 2}%;'></i>", "<i style='left:2%;'></i>"
throws ->
  CoffeeScript.compile '''
   "<i style='left:#{ curWidth /2 }%;'></i>"'''
#                 valid regex--^^^^^^^^^^^ ^--unclosed string
eq "<i style='left:#{curWidth / 2}%;'></i>", "<i style='left:2%;'></i>"
eq "<i style='left:#{curWidth / 2}%;'></i>", "<i style='left:2%;'></i>"
eq "<i style='left:#{curWidth / 2}%;'></i>", "<i style='left:2%;'></i>"

hello = 'Hello'
world = 'World'
ok '#{hello} #{world}!' is '#{hello} #{world}!'
ok "#{hello} #{world}!" is 'Hello World!'
ok "[#{hello}#{world}]" is '[HelloWorld]'
ok "#{hello}##{world}" is 'Hello#World'
ok "Hello #{1 + 2} World" is 'Hello 3 World'
ok "#{hello} #{1 + 2} #{world}" is 'Hello 3 World'
ok 1 + "#{2}px" is '12px'
ok isNaN "a#{2}" * 2
ok "#{2}" is '2'
ok "#{2}#{2}" is '22'

[s, t, r, i, n, g] = ['s', 't', 'r', 'i', 'n', 'g']
ok "#{s}#{t}#{r}#{i}#{n}#{g}" is 'string'
ok '\\#{s}\\#{t}\\#{r}\\#{i}\\#{n}\\#{g}' is '#{s}#{t}#{r}#{i}#{n}#{g}'
ok '\\#{string}' is '#{string}'

ok '\\#{Escaping} first' is '#{Escaping} first'
ok 'Escaping \\#{in} middle' is 'Escaping #{in} middle'
ok 'Escaping \\#{last}' is 'Escaping #{last}'

ok '##' is '##'
ok "#{}" is ''
ok "#{}A#{} #{} #{}B#{}" is 'A  B'
ok '\\\\\\#{}' is '\\\\#{}'

ok "I won ##{20} last night." is 'I won #20 last night.'
ok "I won ##{'#20'} last night." is 'I won ##20 last night.'

ok "#{hello + world}" is 'HelloWorld'
ok "#{hello + ' ' + world + '!'}" is 'Hello World!'

list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
ok(
  "values: #{list.join ', '}, length: #{list.length}." is
    'values: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, length: 10.'
)
ok "values: #{list.join ' '}" is 'values: 0 1 2 3 4 5 6 7 8 9'

obj =
  name: 'Joe'
  hi: -> "Hello #{@name}."
  cya: -> "Hello #{@name}.".replace 'Hello', 'Goodbye'
ok obj.hi() is 'Hello Joe.'
ok obj.cya() is 'Goodbye Joe.'

ok "With #{'quotes'}" is 'With quotes'
ok 'With #{"quotes"}' is 'With #{"quotes"}'

ok "Where is #{obj['name'] + '?'}" is 'Where is Joe?'

ok "Where is #{"the nested #{obj['name']}"}?" is 'Where is the nested Joe?'
ok "Hello #{world ? "#{hello}"}" is 'Hello World'

ok "Hello #{"#{"#{obj['name']}" + '!'}"}" is 'Hello Joe!'

a = """
    Hello #{'Joe'}
    """
ok a is 'Hello Joe'

a = 1
b = 2
c = 3
ok "#{a}#{b}#{c}" is '123'

result = null
stash = (str) -> result = str
stash "a #{'aa'.replace /a/g, 'b'} c"
ok result is 'a bb c'

foo = 'hello'
ok "#{foo.replace '"', ''}" is 'hello'

val = 10
a = """
    basic heredoc #{val}
    on two lines
    """
b = '''
    basic heredoc #{val}
    on two lines
    '''
ok a is 'basic heredoc 10\\non two lines'
ok b is 'basic heredoc \\#{val}\\non two lines'

eq(
  'multiline nested "interpolations" work'
  """multiline #{"nested #{(->
    ok yes
    '"interpolations"'
  )()}"} work"""
)

eq 'function(){}', "#{->}".replace /\\s/g, ''
ok /^a[\\s\\S]+b$/.test "a#{=>}b"
ok /^a[\\s\\S]+b$/.test "a#{(x) -> x %% 2}b"

# Regular Expression Interpolation

# TODO: improve heregex interpolation tests

test 'heregex interpolation', ->
  eq(
    /\\\\#{}\\\\"/ + ''
    ///
   #{
      "#{'\\\\'}" # normal comment
    }
   # regex comment
   \\#{}
   \\\\ "
  /// + ''
  )

`;

exports[`javascript_literals.coffee 1`] = `
# JavaScript Literals
# -------------------

test "inline JavaScript is evaluated", ->
  eq '\\\\\`', \`
    // Inline JS
    "\\\\\\\\\\\`"
  \`

test "escaped backticks are output correctly", ->
  \`var a = \\\`2 + 2 = \${4}\\\`\`
  eq a, '2 + 2 = 4'

test "backslashes before a newline don’t break JavaScript blocks", ->
  \`var a = \\\`To be, or not\\\\
  to be.\\\`\`
  eq a, '''
  To be, or not\\\\
    to be.'''

test "block inline JavaScript is evaluated", ->
  \`\`\`
  var a = 1;
  var b = 2;
  \`\`\`
  c = 3
  \`\`\`var d = 4;\`\`\`
  eq a + b + c + d, 10

test "block inline JavaScript containing backticks", ->
  \`\`\`
  // This is a comment with \`backticks\`
  var a = 42;
  var b = \`foo \${'bar'}\`;
  var c = 3;
  var d = 'foo\`bar\`';
  \`\`\`
  eq a + c, 45
  eq b, 'foo bar'
  eq d, 'foo\`bar\`'

test "block JavaScript can end with an escaped backtick character", ->
  \`\`\`var a = \\\`hello\\\`\`\`\`
  \`\`\`
  var b = \\\`world\${'!'}\\\`\`\`\`
  eq a, 'hello'
  eq b, 'world!'

test "JavaScript block only escapes backslashes followed by backticks", ->
  eq \`'\\\\\\n'\`, '\\\\\\n'

test "escaped JavaScript blocks speed round", ->
  # The following has escaped backslashes because they’re required in strings, but the intent is this:
  # \`hello\`                                       → hello;
  # \`\\\`hello\\\`\`                                   → \`hello\`;
  # \`\\\`Escaping backticks in JS: \\\\\\\`hello\\\\\\\`\\\`\` → \`Escaping backticks in JS: \\\`hello\\\`\`;
  # \`Single backslash: \\ \`                        → Single backslash: \\ ;
  # \`Double backslash: \\\\ \`                       → Double backslash: \\\\ ;
  # \`Single backslash at EOS: \\\\\`                 → Single backslash at EOS: \\;
  # \`Double backslash at EOS: \\\\\\\\\`               → Double backslash at EOS: \\\\;
  for [input, output] in [
    ['\`hello\`',                                               'hello;']
    ['\`\\\\\`hello\\\\\`\`',                                         '\`hello\`;']
    ['\`\\\\\`Escaping backticks in JS: \\\\\\\\\\\\\`hello\\\\\\\\\\\\\`\\\\\`\`', '\`Escaping backticks in JS: \\\\\`hello\\\\\`\`;']
    ['\`"Single backslash: \\\\ "\`',                             '"Single backslash: \\\\ ";']
    ['\`"Double backslash: \\\\\\\\ "\`',                           '"Double backslash: \\\\\\\\ ";']
    # ['\`Single backslash at EOS: \\\\\\\\\`',                       'Single backslash at EOS: \\\\;']
    # ['\`Double backslash at EOS: \\\\\\\\\\\\\\\\\`',                   'Double backslash at EOS: \\\\\\\\;']
  ]
    eqJS input, output
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# JavaScript Literals
# -------------------

test 'inline JavaScript is evaluated', ->
  eq '\\\\\`', \`
    // Inline JS
    "\\\\\\\\\\\`"
  \`

test 'escaped backticks are output correctly', ->
  \`var a = \\\`2 + 2 = \${4}\\\`\`
  eq a, '2 + 2 = 4'

test 'backslashes before a newline don’t break JavaScript blocks', ->
  \`var a = \\\`To be, or not\\\\
  to be.\\\`\`
  eq a, '''
  To be, or not\\\\
    to be.'''

test 'block inline JavaScript is evaluated', ->
  \`\`\`
  var a = 1;
  var b = 2;
  \`\`\`
  c = 3
  \`\`\`var d = 4;\`\`\`
  eq a + b + c + d, 10

test 'block inline JavaScript containing backticks', ->
  \`\`\`
  // This is a comment with \`backticks\`
  var a = 42;
  var b = \`foo \${'bar'}\`;
  var c = 3;
  var d = 'foo\`bar\`';
  \`\`\`
  eq a + c, 45
  eq b, 'foo bar'
  eq d, 'foo\`bar\`'

test 'block JavaScript can end with an escaped backtick character', ->
  \`\`\`var a = \\\`hello\\\`\`\`\`
  \`\`\`
  var b = \\\`world\${'!'}\\\`\`\`\`
  eq a, 'hello'
  eq b, 'world!'

test 'JavaScript block only escapes backslashes followed by backticks', ->
  eq \`'\\\\\\n'\`, '\\\\\\n'

test 'escaped JavaScript blocks speed round', ->
  # The following has escaped backslashes because they’re required in strings, but the intent is this:
  # \`hello\`                                       → hello;
  # \`\\\`hello\\\`\`                                   → \`hello\`;
  # \`\\\`Escaping backticks in JS: \\\\\\\`hello\\\\\\\`\\\`\` → \`Escaping backticks in JS: \\\`hello\\\`\`;
  # \`Single backslash: \\ \`                        → Single backslash: \\ ;
  # \`Double backslash: \\\\ \`                       → Double backslash: \\\\ ;
  # \`Single backslash at EOS: \\\\\`                 → Single backslash at EOS: \\;
  # \`Double backslash at EOS: \\\\\\\\\`               → Double backslash at EOS: \\\\;
  for [input, output] in [
    ['\`hello\`', 'hello;']
    ['\`\\\\\`hello\\\\\`\`', '\`hello\`;']
    [
      '\`\\\\\`Escaping backticks in JS: \\\\\\\\\\\\\`hello\\\\\\\\\\\\\`\\\\\`\`'
      '\`Escaping backticks in JS: \\\\\`hello\\\\\`\`;'
    ]
    ['\`"Single backslash: \\\\ "\`', '"Single backslash: \\\\ ";']
    ['\`"Double backslash: \\\\\\\\ "\`', '"Double backslash: \\\\\\\\ ";']
    # ['\`Single backslash at EOS: \\\\\\\\\`',                       'Single backslash at EOS: \\\\;']
    # ['\`Double backslash at EOS: \\\\\\\\\\\\\\\\\`',                   'Double backslash at EOS: \\\\\\\\;']
  ]
    eqJS input, output

`;

exports[`numbers.coffee 1`] = `
# Number Literals
# ---------------

# * Decimal Integer Literals
# * Octal Integer Literals
# * Hexadecimal Integer Literals
# * Scientific Notation Integer Literals
# * Scientific Notation Non-Integer Literals
# * Non-Integer Literals
# * Binary Integer Literals


# Binary Integer Literals
# Binary notation is understood as would be decimal notation.

test "Parser recognises binary numbers", ->
  eq 4, 0b100

# Decimal Integer Literals

test "call methods directly on numbers", ->
  eq 4, 4.valueOf()
  eq '11', 4.toString 3

eq -1, 3 -4

#764: Numbers should be indexable
eq Number::toString, 42['toString']

eq Number::toString, 42.toString

eq Number::toString, 2e308['toString'] # Infinity


# Non-Integer Literals

# Decimal number literals.
value = .25 + .75
ok value is 1
value = 0.0 + -.25 - -.75 + 0.0
ok value is 0.5

#764: Numbers should be indexable
eq Number::toString,   4['toString']
eq Number::toString, 4.2['toString']
eq Number::toString, .42['toString']
eq Number::toString, (4)['toString']

eq Number::toString,   4.toString
eq Number::toString, 4.2.toString
eq Number::toString, .42.toString
eq Number::toString, (4).toString

test '#1168: leading floating point suppresses newline', ->
  eq 1, do ->
    1
    .5 + 0.5

test "Python-style octal literal notation '0o777'", ->
  eq 511, 0o777
  eq 1, 0o1
  eq 1, 0o00001
  eq parseInt('0777', 8), 0o777
  eq '777', 0o777.toString 8
  eq 4, 0o4.valueOf()
  eq Number::toString, 0o777['toString']
  eq Number::toString, 0o777.toString

test "#2060: Disallow uppercase radix prefixes and exponential notation", ->
  for char in ['b', 'o', 'x', 'e']
    program = "0#{char}0"
    doesNotThrow -> CoffeeScript.compile program, bare: yes
    throws -> CoffeeScript.compile program.toUpperCase(), bare: yes

test "#2224: hex literals with 0b or B or E", ->
  eq 176, 0x0b0
  eq 177, 0x0B1
  eq 225, 0xE1

test "Infinity", ->
  eq Infinity, CoffeeScript.eval "0b#{Array(1024 + 1).join('1')}"
  eq Infinity, CoffeeScript.eval "0o#{Array(342 + 1).join('7')}"
  eq Infinity, CoffeeScript.eval "0x#{Array(256 + 1).join('f')}"
  eq Infinity, CoffeeScript.eval Array(500 + 1).join('9')
  eq Infinity, 2e308

test "NaN", ->
  ok isNaN 1/NaN
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Number Literals
# ---------------

# * Decimal Integer Literals
# * Octal Integer Literals
# * Hexadecimal Integer Literals
# * Scientific Notation Integer Literals
# * Scientific Notation Non-Integer Literals
# * Non-Integer Literals
# * Binary Integer Literals

# Binary Integer Literals
# Binary notation is understood as would be decimal notation.

test 'Parser recognises binary numbers', ->
  eq 4, 0b100

# Decimal Integer Literals

test 'call methods directly on numbers', ->
  eq 4, 4.valueOf()
  eq '11', 4.toString 3

eq -1, 3 - 4

#764: Numbers should be indexable
eq Number::toString, 42['toString']

eq Number::toString, 42.toString

eq Number::toString, 2e308['toString'] # Infinity

# Non-Integer Literals

# Decimal number literals.
value = 0.25 + 0.75
ok value is 1
value = 0.0 + -0.25 - -0.75 + 0.0
ok value is 0.5

#764: Numbers should be indexable
eq Number::toString, 4['toString']
eq Number::toString, 4.2['toString']
eq Number::toString, 0.42['toString']
eq Number::toString, 4['toString']

eq Number::toString, 4.toString
eq Number::toString, 4.2.toString
eq Number::toString, 0.42.toString
eq Number::toString, 4.toString

test '#1168: leading floating point suppresses newline', ->
  eq 1, do ->
    1
    0.5 + 0.5

test "Python-style octal literal notation '0o777'", ->
  eq 511, 0o777
  eq 1, 0o1
  eq 1, 0o00001
  eq parseInt('0777', 8), 0o777
  eq '777', 0o777.toString 8
  eq 4, 0o4.valueOf()
  eq Number::toString, 0o777['toString']
  eq Number::toString, 0o777.toString

test '#2060: Disallow uppercase radix prefixes and exponential notation', ->
  for char in ['b', 'o', 'x', 'e']
    program = "0#{char}0"
    doesNotThrow -> CoffeeScript.compile program, bare: yes
    throws -> CoffeeScript.compile program.toUpperCase(), bare: yes

test '#2224: hex literals with 0b or B or E', ->
  eq 176, 0x0b0
  eq 177, 0x0b1
  eq 225, 0xe1

test 'Infinity', ->
  eq Infinity, CoffeeScript.eval "0b#{Array(1024 + 1).join '1'}"
  eq Infinity, CoffeeScript.eval "0o#{Array(342 + 1).join '7'}"
  eq Infinity, CoffeeScript.eval "0x#{Array(256 + 1).join 'f'}"
  eq Infinity, CoffeeScript.eval Array(500 + 1).join '9'
  eq Infinity, 2e308

test 'NaN', ->
  ok isNaN 1 / NaN

`;

exports[`object_rest_spread.coffee 1`] = `
test "#4798 destructuring of objects with splat within arrays", ->
  arr = [1, {a:1, b:2}]
  [...,{a, r...}] = arr
  eq a, 1
  deepEqual r, {b:2}
  [b, {q...}] = arr
  eq b, 1
  deepEqual q, arr[1]
  eq q.b, r.b
  eq q.a, a

  arr2 = [arr[1]]
  [{a2...}] = arr2
  eq a2.a, arr2[0].a

test "destructuring assignment with objects and splats: ES2015", ->
  obj = {a: 1, b: 2, c: 3, d: 4, e: 5}
  throws (-> CoffeeScript.compile "{a, r..., s...} = x"), null, "multiple rest elements are disallowed"
  throws (-> CoffeeScript.compile "{a, r..., s..., b} = x"), null, "multiple rest elements are disallowed"
  prop = "b"
  {a, b, r...} = obj
  eq a, 1
  eq b, 2
  eq r.e, obj.e
  eq r.a, undefined
  {d, c: x, r...} = obj
  eq x, 3
  eq d, 4
  eq r.c, undefined
  eq r.b, 2
  {a, 'b': z, g = 9, r...} = obj
  eq g, 9
  eq z, 2
  eq r.b, undefined

test "destructuring assignment with splats and default values", ->
  obj = {}
  c = {b: 1}
  { a: {b} = c, d...} = obj

  eq b, 1
  deepEqual d, {}

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  {
    a: {b} = c
    d ...
  } = obj

  eq b, 1
  deepEqual d, {}

test "destructuring assignment with splat with default value", ->
  obj = {}
  c = {val: 1}
  { a: {b...} = c } = obj

  deepEqual b, val: 1

test "destructuring assignment with multiple splats in different objects", ->
  obj = { a: {val: 1}, b: {val: 2} }
  { a: {a...}, b: {b...} } = obj
  deepEqual a, val: 1
  deepEqual b, val: 2

  o = {
    props: {
      p: {
        n: 1
        m: 5
      }
      s: 6
    }
  }
  {p: {m, q..., t = {obj...}}, r...} = o.props
  eq m, o.props.p.m
  deepEqual r, s: 6
  deepEqual q, n: 1
  deepEqual t, obj

  @props = o.props
  {p: {m}, r...} = @props
  eq m, @props.p.m
  deepEqual r, s: 6

  {p: {m}, r...} = {o.props..., p:{m:9}}
  eq m, 9

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  {
    a: {
      a ...
    }
    b: {
      b ...
    }
  } = obj
  deepEqual a, val: 1
  deepEqual b, val: 2

test "destructuring assignment with dynamic keys and splats", ->
  i = 0
  foo = -> ++i

  obj = {1: 'a', 2: 'b'}
  { "#{foo()}": a, b... } = obj

  eq a, 'a'
  eq i, 1
  deepEqual b, 2: 'b'

# Tests from https://babeljs.io/docs/plugins/transform-object-rest-spread/.
test "destructuring assignment with objects and splats: Babel tests", ->
  # What Babel calls “rest properties:”
  { x, y, z... } = { x: 1, y: 2, a: 3, b: 4 }
  eq x, 1
  eq y, 2
  deepEqual z, { a: 3, b: 4 }

  # What Babel calls “spread properties:”
  n = { x, y, z... }
  deepEqual n, { x: 1, y: 2, a: 3, b: 4 }

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  { x, y, z ... } = { x: 1, y: 2, a: 3, b: 4 }
  eq x, 1
  eq y, 2
  deepEqual z, { a: 3, b: 4 }

  n = { x, y, z ... }
  deepEqual n, { x: 1, y: 2, a: 3, b: 4 }

test "deep destructuring assignment with objects: ES2015", ->
  a1={}; b1={}; c1={}; d1={}
  obj = {
    a: a1
    b: {
      'c': {
        d: {
          b1
          e: c1
          f: d1
        }
      }
    }
    b2: {b1, c1}
  }
  {a: w, b: {c: {d: {b1: bb, r1...}}}, r2...} = obj
  eq r1.e, c1
  eq r2.b, undefined
  eq bb, b1
  eq r2.b2, obj.b2

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  {a: w, b: {c: {d: {b1: bb, r1 ...}}}, r2 ...} = obj
  eq r1.e, c1
  eq r2.b, undefined
  eq bb, b1
  eq r2.b2, obj.b2

test "deep destructuring assignment with defaults: ES2015", ->
  obj =
    b: { c: 1, baz: 'qux' }
    foo: 'bar'
  j =
    f: 'world'
  i =
    some: 'prop'
  {
    a...
    b: { c, d... }
    e: {
      f: hello
      g: { h... } = i
    } = j
  } = obj

  deepEqual a, foo: 'bar'
  eq c, 1
  deepEqual d, baz: 'qux'
  eq hello, 'world'
  deepEqual h, some: 'prop'

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  {
    a ...
    b: {
      c,
      d ...
    }
    e: {
      f: hello
      g: {
        h ...
      } = i
    } = j
  } = obj

  deepEqual a, foo: 'bar'
  eq c, 1
  deepEqual d, baz: 'qux'
  eq hello, 'world'
  deepEqual h, some: 'prop'

test "object spread properties: ES2015", ->
  obj = {a: 1, b: 2, c: 3, d: 4, e: 5}
  obj2 = {obj..., c:9}
  eq obj2.c, 9
  eq obj.a, obj2.a

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  obj2 = {
    obj ...
    c:9
  }
  eq obj2.c, 9
  eq obj.a, obj2.a

  obj2 = {obj..., a: 8, c: 9, obj...}
  eq obj2.c, 3
  eq obj.a, obj2.a

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  obj2 = {
    obj ...
    a: 8
    c: 9
    obj ...
  }
  eq obj2.c, 3
  eq obj.a, obj2.a

  obj3 = {obj..., b: 7, g: {obj2..., c: 1}}
  eq obj3.g.c, 1
  eq obj3.b, 7
  deepEqual obj3.g, {obj..., c: 1}

  (({a, b, r...}) ->
    eq 1, a
    deepEqual r, {c: 3, d: 44, e: 55}
  ) {obj2..., d: 44, e: 55}

  obj = {a: 1, b: 2, c: {d: 3, e: 4, f: {g: 5}}}
  obj4 = {a: 10, obj.c...}
  eq obj4.a, 10
  eq obj4.d, 3
  eq obj4.f.g, 5
  deepEqual obj4.f, obj.c.f

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  (({
    a
    b
    r ...
    }) ->
    eq 1, a
    deepEqual r, {c: 3, d: 44, e: 55}
  ) {
    obj2 ...
    d: 44
    e: 55
  }

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  obj4 = {
    a: 10
    obj.c ...
  }
  eq obj4.a, 10
  eq obj4.d, 3
  eq obj4.f.g, 5
  deepEqual obj4.f, obj.c.f

  obj5 = {obj..., ((k) -> {b: k})(99)...}
  eq obj5.b, 99
  deepEqual obj5.c, obj.c

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  obj5 = {
    obj ...
    ((k) -> {b: k})(99) ...
  }
  eq obj5.b, 99
  deepEqual obj5.c, obj.c

  fn = -> {c: {d: 33, e: 44, f: {g: 55}}}
  obj6 = {obj..., fn()...}
  eq obj6.c.d, 33
  deepEqual obj6.c, {d: 33, e: 44, f: {g: 55}}

  obj7 = {obj..., fn()..., {c: {d: 55, e: 66, f: {77}}}...}
  eq obj7.c.d, 55
  deepEqual obj6.c, {d: 33, e: 44, f: {g: 55}}

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  obj7 = {
    obj ...
    fn() ...
    {c: {d: 55, e: 66, f: {77}}} ...
  }
  eq obj7.c.d, 55
  deepEqual obj6.c, {d: 33, e: 44, f: {g: 55}}

  obj =
    a:
      b:
        c:
          d:
            e: {}
  obj9 = {a:1, obj.a.b.c..., g:3}
  deepEqual obj9.d, {e: {}}

  a = "a"
  c = "c"
  obj9 = {a:1, obj[a].b[c]..., g:3}
  deepEqual obj9.d, {e: {}}

  obj9 = {a:1, obj.a["b"].c["d"]..., g:3}
  deepEqual obj9["e"], {}

test "#4673: complex destructured object spread variables", ->
  b = c: 1
  {{a...}...} = b
  eq a.c, 1

  d = {}
  {d.e...} = f: 1
  eq d.e.f, 1

  {{g}...} = g: 1
  eq g, 1

test "rest element destructuring in function definition", ->
  obj = {a: 1, b: 2, c: 3, d: 4, e: 5}

  (({a, b, r...}) ->
    eq 1, a
    eq 2, b,
    deepEqual r, {c: 3, d: 4, e: 5}
  ) obj

  (({a: p, b, r...}, q) ->
    eq p, 1
    eq q, 9
    deepEqual r, {c: 3, d: 4, e: 5}
  ) {a:1, b:2, c:3, d:4, e:5}, 9

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  (({
      a: p
      b
      r ...
    }, q) ->
    eq p, 1
    eq q, 9
    deepEqual r, {c: 3, d: 4, e: 5}
  ) {a:1, b:2, c:3, d:4, e:5}, 9

  a1={}; b1={}; c1={}; d1={}
  obj1 = {
    a: a1
    b: {
      'c': {
        d: {
          b1
          e: c1
          f: d1
        }
      }
    }
    b2: {b1, c1}
  }

  (({a: w, b: {c: {d: {b1: bb, r1...}}}, r2...}) ->
    eq a1, w
    eq bb, b1
    eq r2.b, undefined
    deepEqual r1, {e: c1, f: d1}
    deepEqual r2.b2, {b1, c1}
  ) obj1

  b = 3
  f = ({a, b...}) ->
  f {}
  eq 3, b

  (({a, r...} = {}) ->
    eq a, undefined
    deepEqual r, {}
  )()

  (({a, r...} = {}) ->
    eq a, 1
    deepEqual r, {b: 2, c: 3}
  ) {a: 1, b: 2, c: 3}

  f = ({a, r...} = {}) -> [a, r]
  deepEqual [undefined, {}], f()
  deepEqual [1, {b: 2}], f {a: 1, b: 2}
  deepEqual [1, {}], f {a: 1}

  f = ({a, r...} = {a: 1, b: 2}) -> [a, r]
  deepEqual [1, {b:2}], f()
  deepEqual [2, {}], f {a:2}
  deepEqual [3, {c:5}], f {a:3, c:5}

  f = ({ a: aa = 0, b: bb = 0 }) -> [aa, bb]
  deepEqual [0, 0], f {}
  deepEqual [0, 42], f {b:42}
  deepEqual [42, 0], f {a:42}
  deepEqual [42, 43], f {a:42, b:43}

test "#4673: complex destructured object spread variables", ->
  f = ({{a...}...}) ->
    a
  eq f(c: 1).c, 1

  g = ({@y...}) ->
    eq @y.b, 1
  g b: 1
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
test '#4798 destructuring of objects with splat within arrays', ->
  arr = [1, { a: 1, b: 2 }]
  [..., { a, r... }] = arr
  eq a, 1
  deepEqual r, { b: 2 }
  [b, { q... }] = arr
  eq b, 1
  deepEqual q, arr[1]
  eq q.b, r.b
  eq q.a, a

  arr2 = [arr[1]]
  [{ a2... }] = arr2
  eq a2.a, arr2[0].a

test 'destructuring assignment with objects and splats: ES2015', ->
  obj = a: 1, b: 2, c: 3, d: 4, e: 5
  throws(
    -> CoffeeScript.compile '{a, r..., s...} = x'
    null
    'multiple rest elements are disallowed'
  )
  throws(
    -> CoffeeScript.compile '{a, r..., s..., b} = x'
    null
    'multiple rest elements are disallowed'
  )
  prop = 'b'
  { a, b, r... } = obj
  eq a, 1
  eq b, 2
  eq r.e, obj.e
  eq r.a, undefined
  { d, c: x, r... } = obj
  eq x, 3
  eq d, 4
  eq r.c, undefined
  eq r.b, 2
  { a, b: z, g = 9, r... } = obj
  eq g, 9
  eq z, 2
  eq r.b, undefined

test 'destructuring assignment with splats and default values', ->
  obj = {}
  c = b: 1
  { a: { b } = c, d... } = obj

  eq b, 1
  deepEqual d, {}

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  { a: { b } = c, d... } = obj

  eq b, 1
  deepEqual d, {}

test 'destructuring assignment with splat with default value', ->
  obj = {}
  c = val: 1
  { a: { b... } = c } = obj

  deepEqual b, { val: 1 }

test 'destructuring assignment with multiple splats in different objects', ->
  obj = a: { val: 1 }, b: val: 2
  { a: { a... }, b: { b... } } = obj
  deepEqual a, { val: 1 }
  deepEqual b, { val: 2 }

  o =
    props:
      p:
        n: 1
        m: 5
      s: 6
  { p: { m, q..., t = { obj... } }, r... } = o.props
  eq m, o.props.p.m
  deepEqual r, { s: 6 }
  deepEqual q, { n: 1 }
  deepEqual t, obj

  @props = o.props
  { p: { m }, r... } = @props
  eq m, @props.p.m
  deepEqual r, { s: 6 }

  { p: { m }, r... } = { o.props..., p: m: 9 }
  eq m, 9

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  { a: { a... }, b: { b... } } = obj
  deepEqual a, { val: 1 }
  deepEqual b, { val: 2 }

test 'destructuring assignment with dynamic keys and splats', ->
  i = 0
  foo = -> ++i

  obj = 1: 'a', 2: 'b'
  { "#{foo()}": a, b... } = obj

  eq a, 'a'
  eq i, 1
  deepEqual b, { 2: 'b' }

# Tests from https://babeljs.io/docs/plugins/transform-object-rest-spread/.
test 'destructuring assignment with objects and splats: Babel tests', ->
  # What Babel calls “rest properties:”
  { x, y, z... } = x: 1, y: 2, a: 3, b: 4
  eq x, 1
  eq y, 2
  deepEqual z, { a: 3, b: 4 }

  # What Babel calls “spread properties:”
  n = { x, y, z... }
  deepEqual n, { x: 1, y: 2, a: 3, b: 4 }

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  { x, y, z... } = x: 1, y: 2, a: 3, b: 4
  eq x, 1
  eq y, 2
  deepEqual z, { a: 3, b: 4 }

  n = { x, y, z... }
  deepEqual n, { x: 1, y: 2, a: 3, b: 4 }

test 'deep destructuring assignment with objects: ES2015', ->
  a1 = {}
  b1 = {}
  c1 = {}
  d1 = {}
  obj =
    a: a1
    b:
      c:
        d: {
          b1
          e: c1
          f: d1
        }
    b2: { b1, c1 }
  { a: w, b: { c: { d: { b1: bb, r1... } } }, r2... } = obj
  eq r1.e, c1
  eq r2.b, undefined
  eq bb, b1
  eq r2.b2, obj.b2

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  { a: w, b: { c: { d: { b1: bb, r1... } } }, r2... } = obj
  eq r1.e, c1
  eq r2.b, undefined
  eq bb, b1
  eq r2.b2, obj.b2

test 'deep destructuring assignment with defaults: ES2015', ->
  obj =
    b: c: 1, baz: 'qux'
    foo: 'bar'
  j = f: 'world'
  i = some: 'prop'
  { a..., b: { c, d... }, e: { f: hello, g: { h... } = i } = j } = obj

  deepEqual a, { foo: 'bar' }
  eq c, 1
  deepEqual d, { baz: 'qux' }
  eq hello, 'world'
  deepEqual h, { some: 'prop' }

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  { a..., b: { c, d... }, e: { f: hello, g: { h... } = i } = j } = obj

  deepEqual a, { foo: 'bar' }
  eq c, 1
  deepEqual d, { baz: 'qux' }
  eq hello, 'world'
  deepEqual h, { some: 'prop' }

test 'object spread properties: ES2015', ->
  obj = a: 1, b: 2, c: 3, d: 4, e: 5
  obj2 = { obj..., c: 9 }
  eq obj2.c, 9
  eq obj.a, obj2.a

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  obj2 = {
    obj...
    c: 9
  }
  eq obj2.c, 9
  eq obj.a, obj2.a

  obj2 = { obj..., a: 8, c: 9, obj... }
  eq obj2.c, 3
  eq obj.a, obj2.a

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  obj2 = {
    obj...
    a: 8
    c: 9
    obj...
  }
  eq obj2.c, 3
  eq obj.a, obj2.a

  obj3 = { obj..., b: 7, g: { obj2..., c: 1 } }
  eq obj3.g.c, 1
  eq obj3.b, 7
  deepEqual obj3.g, { obj..., c: 1 }

  (({ a, b, r... }) ->
    eq 1, a
    deepEqual r, { c: 3, d: 44, e: 55 }
  ) { obj2..., d: 44, e: 55 }

  obj = a: 1, b: 2, c: d: 3, e: 4, f: g: 5
  obj4 = { a: 10, obj.c... }
  eq obj4.a, 10
  eq obj4.d, 3
  eq obj4.f.g, 5
  deepEqual obj4.f, obj.c.f

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  (({ a, b, r... }) ->
    eq 1, a
    deepEqual r, { c: 3, d: 44, e: 55 }
  ) {
    obj2...
    d: 44
    e: 55
  }

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  obj4 = {
    a: 10
    obj.c...
  }
  eq obj4.a, 10
  eq obj4.d, 3
  eq obj4.f.g, 5
  deepEqual obj4.f, obj.c.f

  obj5 = { obj..., ((k) -> b: k)(99)... }
  eq obj5.b, 99
  deepEqual obj5.c, obj.c

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  obj5 = {
    obj...
    ((k) -> b: k)(99)...
  }
  eq obj5.b, 99
  deepEqual obj5.c, obj.c

  fn = -> c: d: 33, e: 44, f: g: 55
  obj6 = { obj..., fn()... }
  eq obj6.c.d, 33
  deepEqual obj6.c, { d: 33, e: 44, f: g: 55 }

  obj7 = { obj..., fn()..., { c: d: 55, e: 66, f: { 77 } }... }
  eq obj7.c.d, 55
  deepEqual obj6.c, { d: 33, e: 44, f: g: 55 }

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  obj7 = {
    obj...
    fn()...
    { c: d: 55, e: 66, f: { 77 } }...
  }
  eq obj7.c.d, 55
  deepEqual obj6.c, { d: 33, e: 44, f: g: 55 }

  obj =
    a:
      b:
        c:
          d:
            e: {}
  obj9 = { a: 1, obj.a.b.c..., g: 3 }
  deepEqual obj9.d, { e: {} }

  a = 'a'
  c = 'c'
  obj9 = { a: 1, obj[a].b[c]..., g: 3 }
  deepEqual obj9.d, { e: {} }

  obj9 = { a: 1, obj.a['b'].c['d']..., g: 3 }
  deepEqual obj9['e'], {}

test '#4673: complex destructured object spread variables', ->
  b = c: 1
  { { a... }... } = b
  eq a.c, 1

  d = {}
  { d.e... } = f: 1
  eq d.e.f, 1

  { { g }... } = g: 1
  eq g, 1

test 'rest element destructuring in function definition', ->
  obj = a: 1, b: 2, c: 3, d: 4, e: 5

  (({ a, b, r... }) ->
    eq 1, a
    eq 2, b, deepEqual r, { c: 3, d: 4, e: 5 }
  ) obj

  (({ a: p, b, r... }, q) ->
    eq p, 1
    eq q, 9
    deepEqual r, { c: 3, d: 4, e: 5 }
  ) { a: 1, b: 2, c: 3, d: 4, e: 5 }, 9

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  (({ a: p, b, r... }, q) ->
    eq p, 1
    eq q, 9
    deepEqual r, { c: 3, d: 4, e: 5 }
  ) { a: 1, b: 2, c: 3, d: 4, e: 5 }, 9

  a1 = {}
  b1 = {}
  c1 = {}
  d1 = {}
  obj1 =
    a: a1
    b:
      c:
        d: {
          b1
          e: c1
          f: d1
        }
    b2: { b1, c1 }

  (({ a: w, b: { c: { d: { b1: bb, r1... } } }, r2... }) ->
    eq a1, w
    eq bb, b1
    eq r2.b, undefined
    deepEqual r1, { e: c1, f: d1 }
    deepEqual r2.b2, { b1, c1 }
  ) obj1

  b = 3
  f = ({ a, b... }) ->
  f {}
  eq 3, b

  (({ a, r... } = {}) ->
    eq a, undefined
    deepEqual r, {}
  )()

  (({ a, r... } = {}) ->
    eq a, 1
    deepEqual r, { b: 2, c: 3 }
  ) a: 1, b: 2, c: 3

  f = ({ a, r... } = {}) -> [a, r]
  deepEqual [undefined, {}], f()
  deepEqual [1, { b: 2 }], f a: 1, b: 2
  deepEqual [1, {}], f a: 1

  f = ({ a, r... } = { a: 1, b: 2 }) -> [a, r]
  deepEqual [1, { b: 2 }], f()
  deepEqual [2, {}], f a: 2
  deepEqual [3, { c: 5 }], f a: 3, c: 5

  f = ({ a: aa = 0, b: bb = 0 }) -> [aa, bb]
  deepEqual [0, 0], f {}
  deepEqual [0, 42], f b: 42
  deepEqual [42, 0], f a: 42
  deepEqual [42, 43], f a: 42, b: 43

test '#4673: complex destructured object spread variables', ->
  f = ({ { a... }... }) ->
    a
  eq f(c: 1).c, 1

  g = ({ @y... }) ->
    eq @y.b, 1
  g b: 1

`;

exports[`objects.coffee 1`] = `
# Object Literals
# ---------------

# TODO: refactor object literal tests
# TODO: add indexing and method invocation tests: {a}['a'] is a, {a}.a()

trailingComma = {k1: "v1", k2: 4, k3: (-> true),}
ok trailingComma.k3() and (trailingComma.k2 is 4) and (trailingComma.k1 is "v1")

ok {a: (num) -> num is 10 }.a 10

moe = {
  name:  'Moe'
  greet: (salutation) ->
    salutation + " " + @name
  hello: ->
    @['greet'] "Hello"
  10: 'number'
}
ok moe.hello() is "Hello Moe"
ok moe[10] is 'number'
moe.hello = ->
  this['greet'] "Hello"
ok moe.hello() is 'Hello Moe'

obj = {
  is:     -> yes,
  'not':  -> no,
}
ok obj.is()
ok not obj.not()

### Top-level object literal... ###
obj: 1
### ...doesn't break things. ###

# Object literals should be able to include keywords.
obj = {class: 'höt'}
obj.function = 'dog'
ok obj.class + obj.function is 'hötdog'

# Implicit objects as part of chained calls.
pluck = (x) -> x.a
eq 100, pluck pluck pluck a: a: a: 100


test "YAML-style object literals", ->
  obj =
    a: 1
    b: 2
  eq 1, obj.a
  eq 2, obj.b

  config =
    development:
      server: 'localhost'
      timeout: 10

    production:
      server: 'dreamboat'
      timeout: 1000

  ok config.development.server  is 'localhost'
  ok config.production.server   is 'dreamboat'
  ok config.development.timeout is 10
  ok config.production.timeout  is 1000

obj =
  a: 1,
  b: 2,
ok obj.a is 1
ok obj.b is 2

# Implicit objects nesting.
obj =
  options:
    value: yes
  fn: ->
    {}
    null
ok obj.options.value is yes
ok obj.fn() is null

# Implicit objects with wacky indentation:
obj =
  'reverse': (obj) ->
    Array.prototype.reverse.call obj
  abc: ->
    @reverse(
      @reverse @reverse ['a', 'b', 'c'].reverse()
    )
  one: [1, 2,
    a: 'b'
  3, 4]
  red:
    orange:
          yellow:
                  green: 'blue'
    indigo: 'violet'
  misdent: [[],
  [],
                  [],
      []]
ok obj.abc().join(' ') is 'a b c'
ok obj.one.length is 5
ok obj.one[4] is 4
ok obj.one[2].a is 'b'
ok (key for key of obj.red).length is 2
ok obj.red.orange.yellow.green is 'blue'
ok obj.red.indigo is 'violet'
ok obj.misdent.toString() is ',,,'

#542: Objects leading expression statement should be parenthesized.
{f: -> ok yes }.f() + 1

# String-keyed objects shouldn't suppress newlines.
one =
  '>!': 3
six: -> 10
ok not one.six

# Shorthand objects with property references.
obj =
  ### comment one ###
  ### comment two ###
  one: 1
  two: 2
  object: -> {@one, @two}
  list:   -> [@one, @two]
result = obj.object()
eq result.one, 1
eq result.two, 2
eq result.two, obj.list()[1]

third = (a, b, c) -> c
obj =
  one: 'one'
  two: third 'one', 'two', 'three'
ok obj.one is 'one'
ok obj.two is 'three'

test "invoking functions with implicit object literals", ->
  generateGetter = (prop) -> (obj) -> obj[prop]
  getA = generateGetter 'a'
  getArgs = -> arguments
  a = b = 30

  result = getA
    a: 10
  eq 10, result

  result = getA
    "a": 20
  eq 20, result

  result = getA a,
    b:1
  eq undefined, result

  result = getA b:1,
  a:43
  eq 43, result

  result = getA b:1,
    a:62
  eq undefined, result

  result = getA
    b:1
    a
  eq undefined, result

  result = getA
    a:
      b:2
    b:1
  eq 2, result.b

  result = getArgs
    a:1
    b
    c:1
  ok result.length is 3
  ok result[2].c is 1

  result = getA b: 13, a: 42, 2
  eq 42, result

  result = getArgs a:1, (1 + 1)
  ok result[1] is 2

  result = getArgs a:1, b
  ok result.length is 2
  ok result[1] is 30

  result = getArgs a:1, b, b:1, a
  ok result.length is 4
  ok result[2].b is 1

  throws -> CoffeeScript.compile "a = b:1, c"

test "some weird indentation in YAML-style object literals", ->
  two = (a, b) -> b
  obj = then two 1,
    1: 1
    a:
      b: ->
        fn c,
          d: e
    f: 1
  eq 1, obj[1]

test "#1274: \`{} = a()\` compiles to \`false\` instead of \`a()\`", ->
  a = false
  fn = -> a = true
  {} = fn()
  ok a

test "#1436: \`for\` etc. work as normal property names", ->
  obj = {}
  eq no, obj.hasOwnProperty 'for'
  obj.for = 'foo' of obj
  eq yes, obj.hasOwnProperty 'for'

test "#2706, Un-bracketed object as argument causes inconsistent behavior", ->
  foo = (x, y) -> y
  bar = baz: yes

  eq yes, foo x: 1, bar.baz

test "#2608, Allow inline objects in arguments to be followed by more arguments", ->
  foo = (x, y) -> y

  eq yes, foo x: 1, y: 2, yes

test "#2308, a: b = c:1", ->
  foo = a: b = c: yes
  eq b.c, yes
  eq foo.a.c, yes

test "#2317, a: b c: 1", ->
  foo = (x) -> x
  bar = a: foo c: yes
  eq bar.a.c, yes

test "#1896, a: func b, {c: d}", ->
  first = (x) -> x
  second = (x, y) -> y
  third = (x, y, z) -> z

  one = 1
  two = 2
  three = 3
  four = 4

  foo = a: second one, {c: two}
  eq foo.a.c, two

  bar = a: second one, c: two
  eq bar.a.c, two

  baz = a: second one, {c: two}, e: first first h: three
  eq baz.a.c, two

  qux = a: third one, {c: two}, e: first first h: three
  eq qux.a.e.h, three

  quux = a: third one, {c: two}, e: first(three), h: four
  eq quux.a.e, three
  eq quux.a.h, four

  corge = a: third one, {c: two}, e: second three, h: four
  eq corge.a.e.h, four

test "Implicit objects, functions and arrays", ->
  first  = (x) -> x
  second = (x, y) -> y

  foo = [
    1
    one: 1
    two: 2
    three: 3
    more:
      four: 4
      five: 5, six: 6
    2, 3, 4
    5]
  eq foo[2], 2
  eq foo[1].more.six, 6

  bar = [
    1
    first first first second 1,
      one: 1, twoandthree: twoandthree: two: 2, three: 3
      2,
    2
    one: 1
    two: 2
    three: first second ->
      no
    , ->
      3
    3
    4]
  eq bar[2], 2
  eq bar[1].twoandthree.twoandthree.two, 2
  eq bar[3].three(), 3
  eq bar[4], 3

test "#2549, Brace-less Object Literal as a Second Operand on a New Line", ->
  foo = no or
    one: 1
    two: 2
    three: 3
  eq foo.one, 1

  bar = yes and one: 1
  eq bar.one, 1

  baz = null ?
    one: 1
    two: 2
  eq baz.two, 2

test "#2757, Nested", ->
  foo =
    bar:
      one: 1,
  eq foo.bar.one, 1

  baz =
    qux:
      one: 1,
    corge:
      two: 2,
      three: three: three: 3,
    xyzzy:
      thud:
        four:
          four: 4,
      five: 5,

  eq baz.qux.one, 1
  eq baz.corge.three.three.three, 3
  eq baz.xyzzy.thud.four.four, 4
  eq baz.xyzzy.five, 5

test "#1865, syntax regression 1.1.3", ->
  foo = (x, y) -> y

  bar = a: foo (->),
    c: yes
  eq bar.a.c, yes

  baz = a: foo (->), c: yes
  eq baz.a.c, yes


test "#1322: implicit call against implicit object with block comments", ->
  ((obj, arg) ->
    eq obj.x * obj.y, 6
    ok not arg
  )
    ###
    x
    ###
    x: 2
    ### y ###
    y: 3

test "#1513: Top level bare objs need to be wrapped in parens for unary and existence ops", ->
  doesNotThrow -> CoffeeScript.run "{}?", bare: true
  doesNotThrow -> CoffeeScript.run "{}.a++", bare: true

test "#1871: Special case for IMPLICIT_END in the middle of an implicit object", ->
  result = 'result'
  ident = (x) -> x

  result = ident one: 1 if false

  eq result, 'result'

  result = ident
    one: 1
    two: 2 for i in [1..3]

  eq result.two.join(' '), '2 2 2'

test "#1871: implicit object closed by IMPLICIT_END in implicit returns", ->
  ob = do ->
    a: 1 if no
  eq ob, undefined

  # instead these return an object
  func = ->
    key:
      i for i in [1, 2, 3]

  eq func().key.join(' '), '1 2 3'

  func = ->
    key: (i for i in [1, 2, 3])

  eq func().key.join(' '), '1 2 3'

test "#1961, #1974, regression with compound assigning to an implicit object", ->

  obj = null

  obj ?=
    one: 1
    two: 2

  eq obj.two, 2

  obj = null

  obj or=
    three: 3
    four: 4

  eq obj.four, 4

test "#2207: Immediate implicit closes don't close implicit objects", ->
  func = ->
    key: for i in [1, 2, 3] then i

  eq func().key.join(' '), '1 2 3'

test "#3216: For loop declaration as a value of an implicit object", ->
  test = [0..2]
  ob =
    a: for v, i in test then i
    b: for v, i in test then i
    c: for v in test by 1 then v
    d: for v in test when true then v
  arrayEq ob.a, test
  arrayEq ob.b, test
  arrayEq ob.c, test
  arrayEq ob.d, test
  byFirstKey =
    a: for v in test by 1 then v
  arrayEq byFirstKey.a, test
  whenFirstKey =
    a: for v in test when true then v
  arrayEq whenFirstKey.a, test

test 'inline implicit object literals within multiline implicit object literals', ->
  x =
    a: aa: 0
    b: 0
  eq 0, x.b
  eq 0, x.a.aa

test "object keys with interpolations: simple cases", ->
  a = 'a'
  obj = "#{a}": yes
  eq obj.a, yes
  obj = {"#{a}": yes}
  eq obj.a, yes
  obj = {"#{a}"}
  eq obj.a, 'a'
  obj = {"#{5}"}
  eq obj[5], '5' # Note that the value is a string, just like the key.

test "object keys with interpolations: commas in implicit object", ->
  obj = "#{'a'}": 1, b: 2
  deepEqual obj, {a: 1, b: 2}
  obj = a: 1, "#{'b'}": 2
  deepEqual obj, {a: 1, b: 2}
  obj = "#{'a'}": 1, "#{'b'}": 2
  deepEqual obj, {a: 1, b: 2}

test "object keys with interpolations: commas in explicit object", ->
  obj = {"#{'a'}": 1, b: 2}
  deepEqual obj, {a: 1, b: 2}
  obj = {a: 1, "#{'b'}": 2}
  deepEqual obj, {a: 1, b: 2}
  obj = {"#{'a'}": 1, "#{'b'}": 2}
  deepEqual obj, {a: 1, b: 2}

test "object keys with interpolations: commas after key with interpolation", ->
  obj = {"#{'a'}": yes,}
  eq obj.a, yes
  obj = {
    "#{'a'}": 1,
    "#{'b'}": 2,
    ### herecomment ###
    "#{'c'}": 3,
  }
  deepEqual obj, {a: 1, b: 2, c: 3}
  obj =
    "#{'a'}": 1,
    "#{'b'}": 2,
    ### herecomment ###
    "#{'c'}": 3,
  deepEqual obj, {a: 1, b: 2, c: 3}
  obj =
    "#{'a'}": 1,
    "#{'b'}": 2,
    ### herecomment ###
    "#{'c'}": 3, "#{'d'}": 4,
  deepEqual obj, {a: 1, b: 2, c: 3, d: 4}

test "object keys with interpolations: key with interpolation mixed with \`@prop\`", ->
  deepEqual (-> {@a, "#{'b'}": 2}).call(a: 1), {a: 1, b: 2}

test "object keys with interpolations: evaluate only once", ->
  count = 0
  a = -> count++; 'a'
  obj = {"#{a()}"}
  eq obj.a, 'a'
  eq count, 1

test "object keys with interpolations: evaluation order", ->
  arr = []
  obj =
    a: arr.push 1
    b: arr.push 2
    "#{'c'}": arr.push 3
    "#{'d'}": arr.push 4
    e: arr.push 5
    "#{'f'}": arr.push 6
    g: arr.push 7
  arrayEq arr, [1..7]
  deepEqual obj, {a: 1, b: 2, c: 3, d: 4, e: 5, f: 6, g: 7}

test "object keys with interpolations: object starting with dynamic key", ->
  obj =
    "#{'a'}": 1
    b: 2
  deepEqual obj, {a: 1, b: 2}

test "object keys with interpolations: comments in implicit object", ->
  obj =
    ### leading comment ###
    "#{'a'}": 1

    ### middle ###

    "#{'b'}": 2
    # regular comment
    'c': 3
    ### foo ###
    d: 4
    "#{'e'}": 5
  deepEqual obj, {a: 1, b: 2, c: 3, d: 4, e: 5}

  # Comments in explicit object.
  obj = {
    ### leading comment ###
    "#{'a'}": 1

    ### middle ###

    "#{'b'}": 2
    # regular comment
    'c': 3
    ### foo ###
    d: 4
    "#{'e'}": 5
  }
  deepEqual obj, {a: 1, b: 2, c: 3, d: 4, e: 5}

test "object keys with interpolations: more complicated case", ->
  obj = {
    "#{'interpolated'}":
      """
        #{ '''nested''' }
      """: 123: 456
  }
  deepEqual obj,
    interpolated:
      nested:
        123: 456

test "#4324: Shorthand after interpolated key", ->
  a = 2
  obj = {"#{1}": 1, a}
  eq 1, obj[1]
  eq 2, obj.a

test "computed property keys: simple cases", ->
  a = 'a'
  obj = [a]: yes
  eq obj.a, yes
  obj = {[a]: yes}
  eq obj.a, yes
  obj = {[a]}
  eq obj.a, 'a'
  obj = {[5]}
  eq obj[5], 5
  obj = {['5']}
  eq obj['5'], '5'

test "computed property keys: commas in implicit object", ->
  obj = ['a']: 1, b: 2
  deepEqual obj, {a: 1, b: 2}
  obj = a: 1, ['b']: 2
  deepEqual obj, {a: 1, b: 2}
  obj = ['a']: 1, ['b']: 2
  deepEqual obj, {a: 1, b: 2}

test "computed property keys: commas in explicit object", ->
  obj = {['a']: 1, b: 2}
  deepEqual obj, {a: 1, b: 2}
  obj = {a: 1, ['b']: 2}
  deepEqual obj, {a: 1, b: 2}
  obj = {['a']: 1, ['b']: 2}
  deepEqual obj, {a: 1, b: 2}

test "computed property keys: commas after key with interpolation", ->
  obj = {['a']: yes,}
  eq obj.a, yes
  obj = {
    ['a']: 1,
    ['b']: 2,
    ### herecomment ###
    ['c']: 3,
  }
  deepEqual obj, {a: 1, b: 2, c: 3}
  obj =
    ['a']: 1,
    ['b']: 2,
    ### herecomment ###
    ['c']: 3,
  deepEqual obj, {a: 1, b: 2, c: 3}
  obj =
    ['a']: 1,
    ['b']: 2,
    ### herecomment ###
    ['c']: 3, ['d']: 4,
  deepEqual obj, {a: 1, b: 2, c: 3, d: 4}

test "computed property keys: key with interpolation mixed with \`@prop\`", ->
  deepEqual (-> {@a, ['b']: 2}).call(a: 1), {a: 1, b: 2}

test "computed property keys: evaluate only once", ->
  count = 0
  a = -> count++; 'a'
  obj = {[a()]}
  eq obj.a, 'a'
  eq count, 1

test "computed property keys: evaluation order", ->
  arr = []
  obj =
    a: arr.push 1
    b: arr.push 2
    ['c']: arr.push 3
    ['d']: arr.push 4
    e: arr.push 5
    ['f']: arr.push 6
    g: arr.push 7
  arrayEq arr, [1..7]
  deepEqual obj, {a: 1, b: 2, c: 3, d: 4, e: 5, f: 6, g: 7}

test "computed property keys: object starting with dynamic key", ->
  obj =
    ['a']: 1
    b: 2
  deepEqual obj, {a: 1, b: 2}

test "computed property keys: comments in implicit object", ->
  obj =
    ### leading comment ###
    ['a']: 1

    ### middle ###

    ['b']: 2
    # regular comment
    'c': 3
    ### foo ###
    d: 4
    ['e']: 5
  deepEqual obj, {a: 1, b: 2, c: 3, d: 4, e: 5}

  obj = {
    ### leading comment ###
    ['a']: 1

    ### middle ###

    ['b']: 2
    # regular comment
    'c': 3
    ### foo ###
    d: 4
    ['e']: 5
  }
  deepEqual obj, {a: 1, b: 2, c: 3, d: 4, e: 5}

test "computed property keys: more complicated case", ->
  obj = {
    ['interpolated']:
       ['nested']:
         123: 456
  }
  deepEqual obj,
    interpolated:
      nested:
        123: 456

test "computed property keys: empty array as key", ->
  o1 = { [[]] }
  deepEqual o1, { [[]]: [] }
  arrayEq o1[[]], []
  o2 = { [[]]: 1 }
  deepEqual o2, { [[]]: 1 }
  eq o2[[]], 1
  o3 = [[]]: 1
  deepEqual o3, { [[]]: 1 }
  eq o3[[]], 1
  o4 = a: 1, [[]]: 2
  deepEqual o4, { a: 1, [[]]: 2 }
  eq o4.a, 1
  eq o4[[]], 2
  o5 = { a: 1, [[]]: 2 }
  deepEqual o5, { a: 1, [[]]: 2 }
  eq o5.a, 1
  eq o5[[]], 2

test "computed property keys: shorthand after computed property key", ->
  a = 2
  obj = {[1]: 1, a}
  eq 1, obj[1]
  eq 2, obj.a

test "computed property keys: shorthand computed property key", ->
  a = 'b'
  o = {[a]}
  p = {a}
  r = {['a']}
  eq o.b, 'b'
  eq p.a, o.b
  eq r.a, 'a'

  foo = -> "a"
  obj = { [foo()] }
  eq obj.a, 'a'

test "computed property keys: arrays", ->
  b = 'b'
  f = (c) -> "#{c}1"
  obj =
    ['a']: [1, 2, 3]
    [b]: [4, 5, 6]
    [f(b)]: [7, 8, 9]
  arrayEq obj.a, [1, 2, 3]
  arrayEq obj.b, [4, 5, 6]
  arrayEq obj.b1, [7, 8, 9]

test "computed property keys: examples from developer.mozilla.org (Object initializer)", ->
  i = 0
  obj =
    ['foo' + ++i]: i
    ['foo' + ++i]: i
    ['foo' + ++i]: i
  eq obj.foo1, 1
  eq obj.foo2, 2
  eq obj.foo3, 3

  param = 'size'
  config =
    [param]: 12,
    ['mobile' + param.charAt(0).toUpperCase() + param.slice(1)]: 4
  deepEqual config, {size: 12,  mobileSize: 4}

test "computed property keys: [Symbol.iterator]", ->
  obj =
    [Symbol.iterator]: ->
      yield "hello"
      yield "world"
  arrayEq [obj...], ['hello', 'world']

test "computed property keys: Class property", ->
  increment_method = "increment"
  decrement_method = "decrement"
  class Obs
    constructor: (@count) ->
    [increment_method]: -> @count += 1
    [decrement_method]: -> @count -= 1
  ob = new Obs 2
  eq ob.increment(), 3
  eq ob.decrement(), 2

test "#1263: Braceless object return", ->
  fn = ->
    return
      a: 1
      b: 2
      c: -> 3

  obj = fn()
  eq 1, obj.a
  eq 2, obj.b
  eq 3, obj.c()

test "#4564: indent should close implicit object", ->
  f = (x) -> x

  arrayEq ['a'],
    for key of f a: 1
      key

  g = null
  if f a: 1
    g = 3
  eq g, 3

  h = null
  if a: (i for i in [1, 2, 3])
    h = 4
  eq h, 4

test "#4544: Postfix conditionals in first line of implicit object literals", ->
  two =
    foo:
      bar: 42 if yes
      baz: 1337
  eq 42, two.foo.bar
  eq 1337, two.foo.baz

  f = (x) -> x

  three =
    foo: f
      bar: 42 if yes
      baz: 1337
  eq 42, three.foo.bar
  eq 1337, three.foo.baz

  four =
    f
      foo:
        bar: 42 if yes
      baz: 1337
  eq 42, four.foo.bar
  eq 1337, four.baz

  x = bar: 42 if no
  baz: 1337
  ok not x?

  # Example from #2051
  a = null
  _alert = (arg) -> a = arg
  _alert
    val3: "works" if true
    val: "hello"
    val2: "all good"
  eq a.val2, "all good"

test "#4579: Postfix for/while/until in first line of implicit object literals", ->
  two =
    foo:
      bar1: x for x in [1, 2, 3]
      bar2: x + y for x, y in [1, 2, 3]
      baz: 1337
  arrayEq [1, 2, 3], two.foo.bar1
  arrayEq [1, 3, 5], two.foo.bar2
  eq 1337, two.foo.baz

  f = (x) -> x

  three =
    foo: f
      bar1: x + y for x, y of a: 'b', c: 'd'
      bar2: x + 'c' for x of a: 1, b: 2
      baz: 1337
  arrayEq ['ab', 'cd'], three.foo.bar1
  arrayEq ['ac', 'bc'], three.foo.bar2
  eq 1337, three.foo.baz

  four =
    f
      foo:
        "bar_#{x}": x for x of a: 1, b: 2
      baz: 1337
  eq 'a', four.foo[0].bar_a
  eq 'b', four.foo[1].bar_b
  eq 1337, four.baz

  x = bar: 42 for y in [1]
  baz: 1337
  eq x.bar, 42

  i = 5
  five =
    foo:
      bar: i while i-- > 0
      baz: 1337
  arrayEq [4, 3, 2, 1, 0], five.foo.bar
  eq 1337, five.foo.baz

  i = 5
  six =
    foo:
      bar: i until i-- <= 0
      baz: 1337
  arrayEq [4, 3, 2, 1, 0], six.foo.bar
  eq 1337, six.foo.baz
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Object Literals
# ---------------

# TODO: refactor object literal tests
# TODO: add indexing and method invocation tests: {a}['a'] is a, {a}.a()

trailingComma = k1: 'v1', k2: 4, k3: -> true
ok trailingComma.k3() and trailingComma.k2 is 4 and trailingComma.k1 is 'v1'

ok { a: (num) -> num is 10 }.a 10

moe =
  name: 'Moe'
  greet: (salutation) ->
    salutation + ' ' + @name
  hello: ->
    @['greet'] 'Hello'
  10: 'number'
ok moe.hello() is 'Hello Moe'
ok moe[10] is 'number'
moe.hello = ->
  this['greet'] 'Hello'
ok moe.hello() is 'Hello Moe'

obj =
  is: -> yes
  not: -> no
ok obj.is()
ok not obj.not()

### Top-level object literal... ###
obj: 1
### ...doesn't break things. ###

# Object literals should be able to include keywords.
obj = class: 'höt'
obj.function = 'dog'
ok obj.class + obj.function is 'hötdog'

# Implicit objects as part of chained calls.
pluck = (x) -> x.a
eq 100, pluck pluck pluck a: a: a: 100

test 'YAML-style object literals', ->
  obj =
    a: 1
    b: 2
  eq 1, obj.a
  eq 2, obj.b

  config =
    development:
      server: 'localhost'
      timeout: 10

    production:
      server: 'dreamboat'
      timeout: 1000

  ok config.development.server is 'localhost'
  ok config.production.server is 'dreamboat'
  ok config.development.timeout is 10
  ok config.production.timeout is 1000

obj =
  a: 1
  b: 2
ok obj.a is 1
ok obj.b is 2

# Implicit objects nesting.
obj =
  options:
    value: yes
  fn: ->
    {}
    null
ok obj.options.value is yes
ok obj.fn() is null

# Implicit objects with wacky indentation:
obj =
  reverse: (obj) ->
    Array.prototype.reverse.call obj
  abc: ->
    @reverse @reverse @reverse ['a', 'b', 'c'].reverse()
  one: [1, 2, { a: 'b' }, 3, 4]
  red:
    orange:
      yellow:
        green: 'blue'
    indigo: 'violet'
  misdent: [[], [], [], []]
ok obj.abc().join(' ') is 'a b c'
ok obj.one.length is 5
ok obj.one[4] is 4
ok obj.one[2].a is 'b'
ok (key for key of obj.red).length is 2
ok obj.red.orange.yellow.green is 'blue'
ok obj.red.indigo is 'violet'
ok obj.misdent.toString() is ',,,'

#542: Objects leading expression statement should be parenthesized.
{ f: -> ok yes }.f() + 1

# String-keyed objects shouldn't suppress newlines.
one = '>!': 3
six: -> 10
ok not one.six

# Shorthand objects with property references.
obj =
  ### comment one ###
  ### comment two ###
  one: 1
  two: 2
  object: -> { @one, @two }
  list: -> [@one, @two]
result = obj.object()
eq result.one, 1
eq result.two, 2
eq result.two, obj.list()[1]

third = (a, b, c) -> c
obj =
  one: 'one'
  two: third 'one', 'two', 'three'
ok obj.one is 'one'
ok obj.two is 'three'

test 'invoking functions with implicit object literals', ->
  generateGetter = (prop) -> (obj) -> obj[prop]
  getA = generateGetter 'a'
  getArgs = -> arguments
  a = b = 30

  result = getA a: 10
  eq 10, result

  result = getA a: 20
  eq 20, result

  result = getA a, b: 1
  eq undefined, result

  result = getA(
    b: 1
    a: 43
  )
  eq 43, result

  result = getA { b: 1 }, a: 62
  eq undefined, result

  result = getA { b: 1 }, a
  eq undefined, result

  result = getA(
    a:
      b: 2
    b: 1
  )
  eq 2, result.b

  result = getArgs { a: 1 }, b, c: 1
  ok result.length is 3
  ok result[2].c is 1

  result = getA { b: 13, a: 42 }, 2
  eq 42, result

  result = getArgs { a: 1 }, 1 + 1
  ok result[1] is 2

  result = getArgs { a: 1 }, b
  ok result.length is 2
  ok result[1] is 30

  result = getArgs { a: 1 }, b, { b: 1 }, a
  ok result.length is 4
  ok result[2].b is 1

  throws -> CoffeeScript.compile 'a = b:1, c'

test 'some weird indentation in YAML-style object literals', ->
  two = (a, b) -> b
  obj = two 1,
    1: 1
    a:
      b: ->
        fn c, d: e
    f: 1
  eq 1, obj[1]

test '#1274: \`{} = a()\` compiles to \`false\` instead of \`a()\`', ->
  a = false
  fn = -> a = true
  {} = fn()
  ok a

test '#1436: \`for\` etc. work as normal property names', ->
  obj = {}
  eq no, obj.hasOwnProperty 'for'
  obj.for = 'foo' of obj
  eq yes, obj.hasOwnProperty 'for'

test '#2706, Un-bracketed object as argument causes inconsistent behavior', ->
  foo = (x, y) -> y
  bar = baz: yes

  eq yes, foo { x: 1 }, bar.baz

test '#2608, Allow inline objects in arguments to be followed by more arguments', ->
  foo = (x, y) -> y

  eq yes, foo { x: 1, y: 2 }, yes

test '#2308, a: b = c:1', ->
  foo = a: (b = c: yes)
  eq b.c, yes
  eq foo.a.c, yes

test '#2317, a: b c: 1', ->
  foo = (x) -> x
  bar = a: foo c: yes
  eq bar.a.c, yes

test '#1896, a: func b, {c: d}', ->
  first = (x) -> x
  second = (x, y) -> y
  third = (x, y, z) -> z

  one = 1
  two = 2
  three = 3
  four = 4

  foo = a: second one, c: two
  eq foo.a.c, two

  bar = a: second one, c: two
  eq bar.a.c, two

  baz = a: second one, { c: two }, e: first first h: three
  eq baz.a.c, two

  qux = a: third one, { c: two }, e: first first h: three
  eq qux.a.e.h, three

  quux = a: third one, { c: two }, e: first(three), h: four
  eq quux.a.e, three
  eq quux.a.h, four

  corge = a: third one, { c: two }, e: second three, h: four
  eq corge.a.e.h, four

test 'Implicit objects, functions and arrays', ->
  first = (x) -> x
  second = (x, y) -> y

  foo = [
    1
  ,
    one: 1
    two: 2
    three: 3
    more:
      four: 4
      five: 5
      six: 6
  ,
    2
    3
    4
    5
  ]
  eq foo[2], 2
  eq foo[1].more.six, 6

  bar = [
    1
    first(
      first(
        first(
          second 1, { one: 1, twoandthree: twoandthree: two: 2, three: 3 }, 2
        )
      )
    )
    2
  ,
    one: 1
    two: 2
    three: first(
      second(
        ->
          no
      ,
        ->
          3
      )
    )
  ,
    3
    4
  ]
  eq bar[2], 2
  eq bar[1].twoandthree.twoandthree.two, 2
  eq bar[3].three(), 3
  eq bar[4], 3

test '#2549, Brace-less Object Literal as a Second Operand on a New Line', ->
  foo = no or
    one: 1
    two: 2
    three: 3
  eq foo.one, 1

  bar = yes and one: 1
  eq bar.one, 1

  baz = null ?
    one: 1
    two: 2
  eq baz.two, 2

test '#2757, Nested', ->
  foo =
    bar:
      one: 1
  eq foo.bar.one, 1

  baz =
    qux:
      one: 1
    corge:
      two: 2
      three: three: three: 3
    xyzzy:
      thud:
        four:
          four: 4
      five: 5

  eq baz.qux.one, 1
  eq baz.corge.three.three.three, 3
  eq baz.xyzzy.thud.four.four, 4
  eq baz.xyzzy.five, 5

test '#1865, syntax regression 1.1.3', ->
  foo = (x, y) -> y

  bar =
    a: foo (->), c: yes
  eq bar.a.c, yes

  baz = a: foo (->), c: yes
  eq baz.a.c, yes

test '#1322: implicit call against implicit object with block comments', ->
  ((obj, arg) ->
    eq obj.x * obj.y, 6
    ok not arg
  )
    ###
    x
    ###
    x: 2
    ### y ###
    y: 3

test '#1513: Top level bare objs need to be wrapped in parens for unary and existence ops', ->
  doesNotThrow -> CoffeeScript.run '{}?', bare: true
  doesNotThrow -> CoffeeScript.run '{}.a++', bare: true

test '#1871: Special case for IMPLICIT_END in the middle of an implicit object', ->
  result = 'result'
  ident = (x) -> x

  result = ident one: 1 if false

  eq result, 'result'

  result = ident(
    one: 1
    two: 2 for i in [1..3]
  )

  eq result.two.join(' '), '2 2 2'

test '#1871: implicit object closed by IMPLICIT_END in implicit returns', ->
  ob = do ->
    { a: 1 } if no
  eq ob, undefined

  # instead these return an object
  func = ->
    key:
      i for i in [1, 2, 3]

  eq func().key.join(' '), '1 2 3'

  func = ->
    key: (i for i in [1, 2, 3])

  eq func().key.join(' '), '1 2 3'

test '#1961, #1974, regression with compound assigning to an implicit object', ->
  obj = null

  obj ?=
    one: 1
    two: 2

  eq obj.two, 2

  obj = null

  obj or=
    three: 3
    four: 4

  eq obj.four, 4

test "#2207: Immediate implicit closes don't close implicit objects", ->
  func = ->
    key: for i in [1, 2, 3] then i

  eq func().key.join(' '), '1 2 3'

test '#3216: For loop declaration as a value of an implicit object', ->
  test = [0..2]
  ob =
    a: for v, i in test then i
    b: for v, i in test then i
    c: for v in test by 1 then v
    d: for v in test when true then v
  arrayEq ob.a, test
  arrayEq ob.b, test
  arrayEq ob.c, test
  arrayEq ob.d, test
  byFirstKey = a: for v in test by 1 then v
  arrayEq byFirstKey.a, test
  whenFirstKey = a: for v in test when true then v
  arrayEq whenFirstKey.a, test

test 'inline implicit object literals within multiline implicit object literals', ->
  x =
    a: aa: 0
    b: 0
  eq 0, x.b
  eq 0, x.a.aa

test 'object keys with interpolations: simple cases', ->
  a = 'a'
  obj = "#{a}": yes
  eq obj.a, yes
  obj = "#{a}": yes
  eq obj.a, yes
  obj = { "#{a}" }
  eq obj.a, 'a'
  obj = { "#{5}" }
  eq obj[5], '5' # Note that the value is a string, just like the key.

test 'object keys with interpolations: commas in implicit object', ->
  obj = "#{'a'}": 1, b: 2
  deepEqual obj, { a: 1, b: 2 }
  obj = a: 1, "#{'b'}": 2
  deepEqual obj, { a: 1, b: 2 }
  obj = "#{'a'}": 1, "#{'b'}": 2
  deepEqual obj, { a: 1, b: 2 }

test 'object keys with interpolations: commas in explicit object', ->
  obj = "#{'a'}": 1, b: 2
  deepEqual obj, { a: 1, b: 2 }
  obj = a: 1, "#{'b'}": 2
  deepEqual obj, { a: 1, b: 2 }
  obj = "#{'a'}": 1, "#{'b'}": 2
  deepEqual obj, { a: 1, b: 2 }

test 'object keys with interpolations: commas after key with interpolation', ->
  obj = "#{'a'}": yes
  eq obj.a, yes
  obj =
    "#{'a'}": 1
    "#{'b'}": 2
    ### herecomment ###
    "#{'c'}": 3
  deepEqual obj, { a: 1, b: 2, c: 3 }
  obj =
    "#{'a'}": 1
    "#{'b'}": 2
    ### herecomment ###
    "#{'c'}": 3
  deepEqual obj, { a: 1, b: 2, c: 3 }
  obj =
    "#{'a'}": 1
    "#{'b'}": 2
    ### herecomment ###
    "#{'c'}": 3
    "#{'d'}": 4
  deepEqual obj, { a: 1, b: 2, c: 3, d: 4 }

test 'object keys with interpolations: key with interpolation mixed with \`@prop\`', ->
  deepEqual (-> { @a, "#{'b'}": 2 }).call(a: 1), { a: 1, b: 2 }

test 'object keys with interpolations: evaluate only once', ->
  count = 0
  a = ->
    count++
    'a'
  obj = { "#{a()}" }
  eq obj.a, 'a'
  eq count, 1

test 'object keys with interpolations: evaluation order', ->
  arr = []
  obj =
    a: arr.push 1
    b: arr.push 2
    "#{'c'}": arr.push 3
    "#{'d'}": arr.push 4
    e: arr.push 5
    "#{'f'}": arr.push 6
    g: arr.push 7
  arrayEq arr, [1..7]
  deepEqual obj, { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6, g: 7 }

test 'object keys with interpolations: object starting with dynamic key', ->
  obj =
    "#{'a'}": 1
    b: 2
  deepEqual obj, { a: 1, b: 2 }

test 'object keys with interpolations: comments in implicit object', ->
  obj =
    ### leading comment ###
    "#{'a'}": 1

    ### middle ###

    "#{'b'}": 2
    # regular comment
    c: 3
    ### foo ###
    d: 4
    "#{'e'}": 5
  deepEqual obj, { a: 1, b: 2, c: 3, d: 4, e: 5 }

  # Comments in explicit object.
  obj =
    ### leading comment ###
    "#{'a'}": 1

    ### middle ###

    "#{'b'}": 2
    # regular comment
    c: 3
    ### foo ###
    d: 4
    "#{'e'}": 5
  deepEqual obj, { a: 1, b: 2, c: 3, d: 4, e: 5 }

test 'object keys with interpolations: more complicated case', ->
  obj =
    "#{'interpolated'}":
      """
        #{'''nested'''}
      """:
        123: 456
  deepEqual obj,
    interpolated:
      nested:
        123: 456

test '#4324: Shorthand after interpolated key', ->
  a = 2
  obj = { "#{1}": 1, a }
  eq 1, obj[1]
  eq 2, obj.a

test 'computed property keys: simple cases', ->
  a = 'a'
  obj = [a]: yes
  eq obj.a, yes
  obj = [a]: yes
  eq obj.a, yes
  obj = { [a] }
  eq obj.a, 'a'
  obj = { [5] }
  eq obj[5], 5
  obj = { ['5'] }
  eq obj['5'], '5'

test 'computed property keys: commas in implicit object', ->
  obj = ['a']: 1, b: 2
  deepEqual obj, { a: 1, b: 2 }
  obj = a: 1, ['b']: 2
  deepEqual obj, { a: 1, b: 2 }
  obj = ['a']: 1, ['b']: 2
  deepEqual obj, { a: 1, b: 2 }

test 'computed property keys: commas in explicit object', ->
  obj = ['a']: 1, b: 2
  deepEqual obj, { a: 1, b: 2 }
  obj = a: 1, ['b']: 2
  deepEqual obj, { a: 1, b: 2 }
  obj = ['a']: 1, ['b']: 2
  deepEqual obj, { a: 1, b: 2 }

test 'computed property keys: commas after key with interpolation', ->
  obj = ['a']: yes
  eq obj.a, yes
  obj =
    ['a']: 1
    ['b']: 2
    ### herecomment ###
    ['c']: 3
  deepEqual obj, { a: 1, b: 2, c: 3 }
  obj =
    ['a']: 1
    ['b']: 2
    ### herecomment ###
    ['c']: 3
  deepEqual obj, { a: 1, b: 2, c: 3 }
  obj =
    ['a']: 1
    ['b']: 2
    ### herecomment ###
    ['c']: 3
    ['d']: 4
  deepEqual obj, { a: 1, b: 2, c: 3, d: 4 }

test 'computed property keys: key with interpolation mixed with \`@prop\`', ->
  deepEqual (-> { @a, ['b']: 2 }).call(a: 1), { a: 1, b: 2 }

test 'computed property keys: evaluate only once', ->
  count = 0
  a = ->
    count++
    'a'
  obj = { [a()] }
  eq obj.a, 'a'
  eq count, 1

test 'computed property keys: evaluation order', ->
  arr = []
  obj =
    a: arr.push 1
    b: arr.push 2
    ['c']: arr.push 3
    ['d']: arr.push 4
    e: arr.push 5
    ['f']: arr.push 6
    g: arr.push 7
  arrayEq arr, [1..7]
  deepEqual obj, { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6, g: 7 }

test 'computed property keys: object starting with dynamic key', ->
  obj =
    ['a']: 1
    b: 2
  deepEqual obj, { a: 1, b: 2 }

test 'computed property keys: comments in implicit object', ->
  obj =
    ### leading comment ###
    ['a']: 1

    ### middle ###

    ['b']: 2
    # regular comment
    c: 3
    ### foo ###
    d: 4
    ['e']: 5
  deepEqual obj, { a: 1, b: 2, c: 3, d: 4, e: 5 }

  obj =
    ### leading comment ###
    ['a']: 1

    ### middle ###

    ['b']: 2
    # regular comment
    c: 3
    ### foo ###
    d: 4
    ['e']: 5
  deepEqual obj, { a: 1, b: 2, c: 3, d: 4, e: 5 }

test 'computed property keys: more complicated case', ->
  obj =
    ['interpolated']:
      ['nested']:
        123: 456
  deepEqual obj,
    interpolated:
      nested:
        123: 456

test 'computed property keys: empty array as key', ->
  o1 = { [[]] }
  deepEqual o1, { [[]]: [] }
  arrayEq o1[[]], []
  o2 = [[]]: 1
  deepEqual o2, { [[]]: 1 }
  eq o2[[]], 1
  o3 = [[]]: 1
  deepEqual o3, { [[]]: 1 }
  eq o3[[]], 1
  o4 = a: 1, [[]]: 2
  deepEqual o4, { a: 1, [[]]: 2 }
  eq o4.a, 1
  eq o4[[]], 2
  o5 = a: 1, [[]]: 2
  deepEqual o5, { a: 1, [[]]: 2 }
  eq o5.a, 1
  eq o5[[]], 2

test 'computed property keys: shorthand after computed property key', ->
  a = 2
  obj = { [1]: 1, a }
  eq 1, obj[1]
  eq 2, obj.a

test 'computed property keys: shorthand computed property key', ->
  a = 'b'
  o = { [a] }
  p = { a }
  r = { ['a'] }
  eq o.b, 'b'
  eq p.a, o.b
  eq r.a, 'a'

  foo = -> 'a'
  obj = { [foo()] }
  eq obj.a, 'a'

test 'computed property keys: arrays', ->
  b = 'b'
  f = (c) -> "#{c}1"
  obj =
    ['a']: [1, 2, 3]
    [b]: [4, 5, 6]
    [f(b)]: [7, 8, 9]
  arrayEq obj.a, [1, 2, 3]
  arrayEq obj.b, [4, 5, 6]
  arrayEq obj.b1, [7, 8, 9]

test 'computed property keys: examples from developer.mozilla.org (Object initializer)', ->
  i = 0
  obj =
    ['foo' + ++i]: i
    ['foo' + ++i]: i
    ['foo' + ++i]: i
  eq obj.foo1, 1
  eq obj.foo2, 2
  eq obj.foo3, 3

  param = 'size'
  config =
    [param]: 12
    ['mobile' + param.charAt(0).toUpperCase() + param.slice(1)]: 4
  deepEqual config, { size: 12, mobileSize: 4 }

test 'computed property keys: [Symbol.iterator]', ->
  obj =
    [Symbol.iterator]: ->
      yield 'hello'
      yield 'world'
  arrayEq [obj...], ['hello', 'world']

test 'computed property keys: Class property', ->
  increment_method = 'increment'
  decrement_method = 'decrement'
  class Obs
    constructor: (@count) ->
    [increment_method]: -> @count += 1
    [decrement_method]: -> @count -= 1
  ob = new Obs 2
  eq ob.increment(), 3
  eq ob.decrement(), 2

test '#1263: Braceless object return', ->
  fn = ->
    return
      a: 1
      b: 2
      c: -> 3

  obj = fn()
  eq 1, obj.a
  eq 2, obj.b
  eq 3, obj.c()

test '#4564: indent should close implicit object', ->
  f = (x) -> x

  arrayEq(
    ['a']
    for key of f a: 1
      key
  )

  g = null
  if f a: 1
    g = 3
  eq g, 3

  h = null
  if a: (i for i in [1, 2, 3])
    h = 4
  eq h, 4

test '#4544: Postfix conditionals in first line of implicit object literals', ->
  two =
    foo:
      bar: 42 if yes
      baz: 1337
  eq 42, two.foo.bar
  eq 1337, two.foo.baz

  f = (x) -> x

  three =
    foo: f(
      bar: 42 if yes
      baz: 1337
    )
  eq 42, three.foo.bar
  eq 1337, three.foo.baz

  four = f(
    foo:
      { bar: 42 } if yes
    baz: 1337
  )
  eq 42, four.foo.bar
  eq 1337, four.baz

  x = bar: 42 if no
  baz: 1337
  ok not x?

  # Example from #2051
  a = null
  _alert = (arg) -> a = arg
  _alert
    val3: 'works' if true
    val: 'hello'
    val2: 'all good'
  eq a.val2, 'all good'

test '#4579: Postfix for/while/until in first line of implicit object literals', ->
  two =
    foo:
      bar1: x for x in [1, 2, 3]
      bar2: x + y for x, y in [1, 2, 3]
      baz: 1337
  arrayEq [1, 2, 3], two.foo.bar1
  arrayEq [1, 3, 5], two.foo.bar2
  eq 1337, two.foo.baz

  f = (x) -> x

  three =
    foo: f(
      bar1: x + y for x, y of a: 'b', c: 'd'
      bar2: x + 'c' for x of a: 1, b: 2
      baz: 1337
    )
  arrayEq ['ab', 'cd'], three.foo.bar1
  arrayEq ['ac', 'bc'], three.foo.bar2
  eq 1337, three.foo.baz

  four = f(
    foo:
      { "bar_#{x}": x } for x of a: 1, b: 2
    baz: 1337
  )
  eq 'a', four.foo[0].bar_a
  eq 'b', four.foo[1].bar_b
  eq 1337, four.baz

  (x = bar: 42) for y in [1]
  baz: 1337
  eq x.bar, 42

  i = 5
  five =
    foo:
      bar: i while i-- > 0
      baz: 1337
  arrayEq [4, 3, 2, 1, 0], five.foo.bar
  eq 1337, five.foo.baz

  i = 5
  six =
    foo:
      bar: i until i-- <= 0
      baz: 1337
  arrayEq [4, 3, 2, 1, 0], six.foo.bar
  eq 1337, six.foo.baz

`;

exports[`operators.coffee 1`] = `
# Operators
# ---------

# * Operators
# * Existential Operator (Binary)
# * Existential Operator (Unary)
# * Aliased Operators
# * [not] in/of
# * Chained Comparison

test "binary (2-ary) math operators do not require spaces", ->
  a = 1
  b = -1
  eq +1, a*-b
  eq -1, a*+b
  eq +1, a/-b
  eq -1, a/+b

test "operators should respect new lines as spaced", ->
  a = 123 +
  456
  eq 579, a

  b = "1#{2}3" +
  "456"
  eq '123456', b

test "multiple operators should space themselves", ->
  eq (+ +1), (- -1)

test "compound operators on successive lines", ->
  a = 1
  a +=
  1
  eq a, 2

test "bitwise operators", ->
  eq  2, (10 &   3)
  eq 11, (10 |   3)
  eq  9, (10 ^   3)
  eq 80, (10 <<  3)
  eq  1, (10 >>  3)
  eq  1, (10 >>> 3)
  num = 10; eq  2, (num &=   3)
  num = 10; eq 11, (num |=   3)
  num = 10; eq  9, (num ^=   3)
  num = 10; eq 80, (num <<=  3)
  num = 10; eq  1, (num >>=  3)
  num = 10; eq  1, (num >>>= 3)

test "\`instanceof\`", ->
  ok new String instanceof String
  ok new Boolean instanceof Boolean
  # \`instanceof\` supports negation by prefixing the operator with \`not\`
  ok new Number not instanceof String
  ok new Array not instanceof Boolean

test "use \`::\` operator on keywords \`this\` and \`@\`", ->
  nonce = {}
  obj =
    withAt:   -> @::prop
    withThis: -> this::prop
  obj.prototype = prop: nonce
  eq nonce, obj.withAt()
  eq nonce, obj.withThis()


# Existential Operator (Binary)

test "binary existential operator", ->
  nonce = {}

  b = a ? nonce
  eq nonce, b

  a = null
  b = undefined
  b = a ? nonce
  eq nonce, b

  a = false
  b = a ? nonce
  eq false, b

  a = 0
  b = a ? nonce
  eq 0, b

test "binary existential operator conditionally evaluates second operand", ->
  i = 1
  func = -> i -= 1
  result = func() ? func()
  eq result, 0

test "binary existential operator with negative number", ->
  a = null ? - 1
  eq -1, a


# Existential Operator (Unary)

test "postfix existential operator", ->
  ok (if nonexistent? then false else true)
  defined = true
  ok defined?
  defined = false
  ok defined?

test "postfix existential operator only evaluates its operand once", ->
  semaphore = 0
  fn = ->
    ok false if semaphore
    ++semaphore
  ok(if fn()? then true else false)

test "negated postfix existential operator", ->
  ok !nothing?.value

test "postfix existential operator on expressions", ->
  eq true, (1 or 0)?, true


# \`is\`,\`isnt\`,\`==\`,\`!=\`

test "\`==\` and \`is\` should be interchangeable", ->
  a = b = 1
  ok a is 1 and b == 1
  ok a == b
  ok a is b

test "\`!=\` and \`isnt\` should be interchangeable", ->
  a = 0
  b = 1
  ok a isnt 1 and b != 0
  ok a != b
  ok a isnt b


# [not] in/of

# - \`in\` should check if an array contains a value using \`indexOf\`
# - \`of\` should check if a property is defined on an object using \`in\`
test "in, of", ->
  arr = [1]
  ok 0 of arr
  ok 1 in arr
  # prefixing \`not\` to \`in and \`of\` should negate them
  ok 1 not of arr
  ok 0 not in arr

test "\`in\` should be able to operate on an array literal", ->
  ok 2 in [0, 1, 2, 3]
  ok 4 not in [0, 1, 2, 3]
  arr = [0, 1, 2, 3]
  ok 2 in arr
  ok 4 not in arr
  # should cache the value used to test the array
  arr = [0]
  val = 0
  ok val++ in arr
  ok val++ not in arr
  val = 0
  ok val++ of arr
  ok val++ not of arr

test "\`of\` and \`in\` should be able to operate on instance variables", ->
  obj = {
    list: [2,3]
    in_list: (value) -> value in @list
    not_in_list: (value) -> value not in @list
    of_list: (value) -> value of @list
    not_of_list: (value) -> value not of @list
  }
  ok obj.in_list 3
  ok obj.not_in_list 1
  ok obj.of_list 0
  ok obj.not_of_list 2

test "#???: \`in\` with cache and \`__indexOf\` should work in argument lists", ->
  eq 1, [Object() in Array()].length

test "#737: \`in\` should have higher precedence than logical operators", ->
  eq 1, 1 in [1] and 1

test "#768: \`in\` should preserve evaluation order", ->
  share = 0
  a = -> share++ if share is 0
  b = -> share++ if share is 1
  c = -> share++ if share is 2
  ok a() not in [b(),c()]
  eq 3, share

test "#1099: empty array after \`in\` should compile to \`false\`", ->
  eq 1, [5 in []].length
  eq false, do -> return 0 in []

test "#1354: optimized \`in\` checks should not happen when splats are present", ->
  a = [6, 9]
  eq 9 in [3, a...], true

test "#1100: precedence in or-test compilation of \`in\`", ->
  ok 0 in [1 and 0]
  ok 0 in [1, 1 and 0]
  ok not (0 in [1, 0 or 1])

test "#1630: \`in\` should check \`hasOwnProperty\`", ->
  ok undefined not in length: 1

test "#1714: lexer bug with raw range \`for\` followed by \`in\`", ->
  0 for [1..2]
  ok not ('a' in ['b'])

  0 for [1..2]; ok not ('a' in ['b'])

  0 for [1..10] # comment ending
  ok not ('a' in ['b'])

  # lexer state (specifically @seenFor) should be reset before each compilation
  CoffeeScript.compile "0 for [1..2]"
  CoffeeScript.compile "'a' in ['b']"

test "#1099: statically determined \`not in []\` reporting incorrect result", ->
  ok 0 not in []

test "#1099: make sure expression tested gets evaluted when array is empty", ->
  a = 0
  (do -> a = 1) in []
  eq a, 1

# Chained Comparison

test "chainable operators", ->
  ok 100 > 10 > 1 > 0 > -1
  ok -1 < 0 < 1 < 10 < 100

test "\`is\` and \`isnt\` may be chained", ->
  ok true is not false is true is not false
  ok 0 is 0 isnt 1 is 1

test "different comparison operators (\`>\`,\`<\`,\`is\`,etc.) may be combined", ->
  ok 1 < 2 > 1
  ok 10 < 20 > 2+3 is 5

test "some chainable operators can be negated by \`unless\`", ->
  ok (true unless 0==10!=100)

test "operator precedence: \`|\` lower than \`<\`", ->
  eq 1, 1 | 2 < 3 < 4

test "preserve references", ->
  a = b = c = 1
  # \`a == b <= c\` should become \`a === b && b <= c\`
  # (this test does not seem to test for this)
  ok a == b <= c

test "chained operations should evaluate each value only once", ->
  a = 0
  ok 1 > a++ < 1

test "#891: incorrect inversion of chained comparisons", ->
  ok (true unless 0 > 1 > 2)
  ok (true unless (this.NaN = 0/0) < 0/0 < this.NaN)

test "#1234: Applying a splat to :: applies the splat to the wrong object", ->
  nonce = {}
  class C
    method: -> @nonce
    nonce: nonce

  arr = []
  eq nonce, C::method arr... # should be applied to \`C::\`

test "#1102: String literal prevents line continuation", ->
  eq "': '", '' +
     "': '"

test "#1703, ---x is invalid JS", ->
  x = 2
  eq (- --x), -1

test "Regression with implicit calls against an indented assignment", ->
  eq 1, a =
    1

  eq a, 1

test "#2155 ... conditional assignment to a closure", ->
  x = null
  func = -> x ?= (-> if true then 'hi')
  func()
  eq x(), 'hi'

test "#2197: Existential existential double trouble", ->
  counter = 0
  func = -> counter++
  func()? ? 100
  eq counter, 1

test "#2567: Optimization of negated existential produces correct result", ->
  a = 1
  ok !(!a?)
  ok !b?

test "#2508: Existential access of the prototype", ->
  eq NonExistent?::nothing, undefined
  ok Object?::toString

test "floor division operator", ->
  eq 2, 7 // 3
  eq -3, -7 // 3
  eq NaN, 0 // 0

test "floor division operator compound assignment", ->
  a = 7
  a //= 1 + 1
  eq 3, a

test "modulo operator", ->
  check = (a, b, expected) ->
    eq expected, a %% b, "expected #{a} %%%% #{b} to be #{expected}"
  check 0, 1, 0
  check 0, -1, -0
  check 1, 0, NaN
  check 1, 2, 1
  check 1, -2, -1
  check 1, 3, 1
  check 2, 3, 2
  check 3, 3, 0
  check 4, 3, 1
  check -1, 3, 2
  check -2, 3, 1
  check -3, 3, 0
  check -4, 3, 2
  check 5.5, 2.5, 0.5
  check -5.5, 2.5, 2.0

test "modulo operator compound assignment", ->
  a = -2
  a %%= 5
  eq 3, a

test "modulo operator converts arguments to numbers", ->
  eq 1, 1 %% '42'
  eq 1, '1' %% 42
  eq 1, '1' %% '42'

test "#3361: Modulo operator coerces right operand once", ->
  count = 0
  res = 42 %% valueOf: -> count += 1
  eq 1, count
  eq 0, res

test "#3363: Modulo operator coercing order", ->
  count = 2
  a = valueOf: -> count *= 2
  b = valueOf: -> count += 1
  eq 4, a %% b
  eq 5, count

test "#3598: Unary + and - coerce the operand once when it is an identifier", ->
  # Unary + and - do not generate \`_ref\`s when the operand is a number, for
  # readability. To make sure that they do when the operand is an identifier,
  # test that they are consistent with another unary operator as well as another
  # complex expression.
  # Tip: Making one of the tests temporarily fail lets you easily inspect the
  # compiled JavaScript.

  assertOneCoercion = (fn) ->
    count = 0
    value = valueOf: -> count++; 1
    fn value
    eq 1, count

  eq 1, 1 ? 0
  eq 1, +1 ? 0
  eq -1, -1 ? 0
  assertOneCoercion (a) ->
    eq 1, +a ? 0
  assertOneCoercion (a) ->
    eq -1, -a ? 0
  assertOneCoercion (a) ->
    eq -2, ~a ? 0
  assertOneCoercion (a) ->
    eq 0.5, a / 2 ? 0

  ok -2 <= 1 < 2
  ok -2 <= +1 < 2
  ok -2 <= -1 < 2
  assertOneCoercion (a) ->
    ok -2 <= +a < 2
  assertOneCoercion (a) ->
    ok -2 <= -a < 2
  assertOneCoercion (a) ->
    ok -2 <= ~a < 2
  assertOneCoercion (a) ->
    ok -2 <= a / 2 < 2

  arrayEq [0], (n for n in [0] by 1)
  arrayEq [0], (n for n in [0] by +1)
  arrayEq [0], (n for n in [0] by -1)
  assertOneCoercion (a) ->
    arrayEq [0], (n for n in [0] by +a)
  assertOneCoercion (a) ->
    arrayEq [0], (n for n in [0] by -a)
  assertOneCoercion (a) ->
    arrayEq [0], (n for n in [0] by ~a)
  assertOneCoercion (a) ->
    arrayEq [0], (n for n in [0] by a * 2 / 2)

  ok 1 in [0, 1]
  ok +1 in [0, 1]
  ok -1 in [0, -1]
  assertOneCoercion (a) ->
    ok +a in [0, 1]
  assertOneCoercion (a) ->
    ok -a in [0, -1]
  assertOneCoercion (a) ->
    ok ~a in [0, -2]
  assertOneCoercion (a) ->
    ok a / 2 in [0, 0.5]

test "'new' target", ->
  nonce = {}
  ctor  = -> nonce

  eq (new ctor), nonce
  eq (new ctor()), nonce

  ok new class

  ctor  = class
  ok (new ctor) instanceof ctor
  ok (new ctor()) instanceof ctor

  # Force an executable class body
  ctor  = class then a = 1
  ok (new ctor) instanceof ctor

  get   = -> ctor
  ok (new get()) not instanceof ctor
  ok (new (get())()) instanceof ctor

  # classes must be called with \`new\`. In this case \`new\` applies to \`get\` only
  throws -> new get()()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Operators
# ---------

# * Operators
# * Existential Operator (Binary)
# * Existential Operator (Unary)
# * Aliased Operators
# * [not] in/of
# * Chained Comparison

test 'binary (2-ary) math operators do not require spaces', ->
  a = 1
  b = -1
  eq +1, a * -b
  eq -1, a * +b
  eq +1, a / -b
  eq -1, a / +b

test 'operators should respect new lines as spaced', ->
  a = 123 + 456
  eq 579, a

  b = "1#{2}3" + '456'
  eq '123456', b

test 'multiple operators should space themselves', ->
  eq +(+1), -(-1)

test 'compound operators on successive lines', ->
  a = 1
  a += 1
  eq a, 2

test 'bitwise operators', ->
  eq 2, 10 & 3
  eq 11, 10 | 3
  eq 9, 10 ^ 3
  eq 80, 10 << 3
  eq 1, 10 >> 3
  eq 1, 10 >>> 3
  num = 10
  eq 2, num &= 3
  num = 10
  eq 11, num |= 3
  num = 10
  eq 9, num ^= 3
  num = 10
  eq 80, num <<= 3
  num = 10
  eq 1, num >>= 3
  num = 10
  eq 1, num >>>= 3

test '\`instanceof\`', ->
  ok new String() instanceof String
  ok new Boolean() instanceof Boolean
  # \`instanceof\` supports negation by prefixing the operator with \`not\`
  ok new Number() not instanceof String
  ok new Array() not instanceof Boolean

test 'use \`::\` operator on keywords \`this\` and \`@\`', ->
  nonce = {}
  obj =
    withAt: -> @::prop
    withThis: -> this::prop
  obj.prototype = prop: nonce
  eq nonce, obj.withAt()
  eq nonce, obj.withThis()

# Existential Operator (Binary)

test 'binary existential operator', ->
  nonce = {}

  b = a ? nonce
  eq nonce, b

  a = null
  b = undefined
  b = a ? nonce
  eq nonce, b

  a = false
  b = a ? nonce
  eq false, b

  a = 0
  b = a ? nonce
  eq 0, b

test 'binary existential operator conditionally evaluates second operand', ->
  i = 1
  func = -> i -= 1
  result = func() ? func()
  eq result, 0

test 'binary existential operator with negative number', ->
  a = null ? -1
  eq -1, a

# Existential Operator (Unary)

test 'postfix existential operator', ->
  ok if nonexistent? then false else true
  defined = true
  ok defined?
  defined = false
  ok defined?

test 'postfix existential operator only evaluates its operand once', ->
  semaphore = 0
  fn = ->
    ok false if semaphore
    ++semaphore
  ok if fn()? then true else false

test 'negated postfix existential operator', ->
  ok !nothing?.value

test 'postfix existential operator on expressions', ->
  eq true, (1 or 0)?, true

# \`is\`,\`isnt\`,\`==\`,\`!=\`

test '\`==\` and \`is\` should be interchangeable', ->
  a = b = 1
  ok a is 1 and b == 1
  ok a == b
  ok a is b

test '\`!=\` and \`isnt\` should be interchangeable', ->
  a = 0
  b = 1
  ok a isnt 1 and b != 0
  ok a != b
  ok a isnt b

# [not] in/of

# - \`in\` should check if an array contains a value using \`indexOf\`
# - \`of\` should check if a property is defined on an object using \`in\`
test 'in, of', ->
  arr = [1]
  ok 0 of arr
  ok 1 in arr
  # prefixing \`not\` to \`in and \`of\` should negate them
  ok 1 not of arr
  ok 0 not in arr

test '\`in\` should be able to operate on an array literal', ->
  ok 2 in [0, 1, 2, 3]
  ok 4 not in [0, 1, 2, 3]
  arr = [0, 1, 2, 3]
  ok 2 in arr
  ok 4 not in arr
  # should cache the value used to test the array
  arr = [0]
  val = 0
  ok val++ in arr
  ok val++ not in arr
  val = 0
  ok val++ of arr
  ok val++ not of arr

test '\`of\` and \`in\` should be able to operate on instance variables', ->
  obj =
    list: [2, 3]
    in_list: (value) -> value in @list
    not_in_list: (value) -> value not in @list
    of_list: (value) -> value of @list
    not_of_list: (value) -> value not of @list
  ok obj.in_list 3
  ok obj.not_in_list 1
  ok obj.of_list 0
  ok obj.not_of_list 2

test '#???: \`in\` with cache and \`__indexOf\` should work in argument lists', ->
  eq 1, [Object() in Array()].length

test '#737: \`in\` should have higher precedence than logical operators', ->
  eq 1, 1 in [1] and 1

test '#768: \`in\` should preserve evaluation order', ->
  share = 0
  a = ->
    share++ if share is 0
  b = ->
    share++ if share is 1
  c = ->
    share++ if share is 2
  ok a() not in [b(), c()]
  eq 3, share

test '#1099: empty array after \`in\` should compile to \`false\`', ->
  eq 1, [5 in []].length
  eq false, do -> return 0 in []

test '#1354: optimized \`in\` checks should not happen when splats are present', ->
  a = [6, 9]
  eq 9 in [3, a...], true

test '#1100: precedence in or-test compilation of \`in\`', ->
  ok 0 in [1 and 0]
  ok 0 in [1, 1 and 0]
  ok not (0 in [1, 0 or 1])

test '#1630: \`in\` should check \`hasOwnProperty\`', ->
  ok undefined not in length: 1

test '#1714: lexer bug with raw range \`for\` followed by \`in\`', ->
  0 for [1..2]
  ok not ('a' in ['b'])

  0 for [1..2]
  ok not ('a' in ['b'])

  0 for [1..10] # comment ending
  ok not ('a' in ['b'])

  # lexer state (specifically @seenFor) should be reset before each compilation
  CoffeeScript.compile '0 for [1..2]'
  CoffeeScript.compile "'a' in ['b']"

test '#1099: statically determined \`not in []\` reporting incorrect result', ->
  ok 0 not in []

test '#1099: make sure expression tested gets evaluted when array is empty', ->
  a = 0
  (do -> a = 1) in []
  eq a, 1

# Chained Comparison

test 'chainable operators', ->
  ok 100 > 10 > 1 > 0 > -1
  ok -1 < 0 < 1 < 10 < 100

test '\`is\` and \`isnt\` may be chained', ->
  ok true is not false is true is not false
  ok 0 is 0 isnt 1 is 1

test 'different comparison operators (\`>\`,\`<\`,\`is\`,etc.) may be combined', ->
  ok 1 < 2 > 1
  ok 10 < 20 > 2 + 3 is 5

test 'some chainable operators can be negated by \`unless\`', ->
  ok(true unless 0 == 10 != 100)

test 'operator precedence: \`|\` lower than \`<\`', ->
  eq 1, 1 | (2 < 3 < 4)

test 'preserve references', ->
  a = b = c = 1
  # \`a == b <= c\` should become \`a === b && b <= c\`
  # (this test does not seem to test for this)
  ok a == b <= c

test 'chained operations should evaluate each value only once', ->
  a = 0
  ok 1 > a++ < 1

test '#891: incorrect inversion of chained comparisons', ->
  ok(true unless 0 > 1 > 2)
  ok(true unless (this.NaN = 0 / 0) < 0 / 0 < this.NaN)

test '#1234: Applying a splat to :: applies the splat to the wrong object', ->
  nonce = {}
  class C
    method: -> @nonce
    nonce: nonce

  arr = []
  eq nonce, C::method arr... # should be applied to \`C::\`

test '#1102: String literal prevents line continuation', ->
  eq "': '", '' + "': '"

test '#1703, ---x is invalid JS', ->
  x = 2
  eq -(--x), -1

test 'Regression with implicit calls against an indented assignment', ->
  eq 1, (a = 1)

  eq a, 1

test '#2155 ... conditional assignment to a closure', ->
  x = null
  func = -> x ?= -> if true then 'hi'
  func()
  eq x(), 'hi'

test '#2197: Existential existential double trouble', ->
  counter = 0
  func = -> counter++
  func()? ? 100
  eq counter, 1

test '#2567: Optimization of negated existential produces correct result', ->
  a = 1
  ok !!a?
  ok !b?

test '#2508: Existential access of the prototype', ->
  eq NonExistent?::nothing, undefined
  ok Object?::toString

test 'floor division operator', ->
  eq 2, 7 // 3
  eq -3, -7 // 3
  eq NaN, 0 // 0

test 'floor division operator compound assignment', ->
  a = 7
  a //= 1 + 1
  eq 3, a

test 'modulo operator', ->
  check = (a, b, expected) ->
    eq expected, a %% b, "expected #{a} %%%% #{b} to be #{expected}"
  check 0, 1, 0
  check 0, -1, -0
  check 1, 0, NaN
  check 1, 2, 1
  check 1, -2, -1
  check 1, 3, 1
  check 2, 3, 2
  check 3, 3, 0
  check 4, 3, 1
  check -1, 3, 2
  check -2, 3, 1
  check -3, 3, 0
  check -4, 3, 2
  check 5.5, 2.5, 0.5
  check -5.5, 2.5, 2.0

test 'modulo operator compound assignment', ->
  a = -2
  a %%= 5
  eq 3, a

test 'modulo operator converts arguments to numbers', ->
  eq 1, 1 %% '42'
  eq 1, '1' %% 42
  eq 1, '1' %% '42'

test '#3361: Modulo operator coerces right operand once', ->
  count = 0
  res = 42 %% valueOf: -> count += 1
  eq 1, count
  eq 0, res

test '#3363: Modulo operator coercing order', ->
  count = 2
  a = valueOf: -> count *= 2
  b = valueOf: -> count += 1
  eq 4, a %% b
  eq 5, count

test '#3598: Unary + and - coerce the operand once when it is an identifier', ->
  # Unary + and - do not generate \`_ref\`s when the operand is a number, for
  # readability. To make sure that they do when the operand is an identifier,
  # test that they are consistent with another unary operator as well as another
  # complex expression.
  # Tip: Making one of the tests temporarily fail lets you easily inspect the
  # compiled JavaScript.

  assertOneCoercion = (fn) ->
    count = 0
    value =
      valueOf: ->
        count++
        1
    fn value
    eq 1, count

  eq 1, 1 ? 0
  eq 1, +1 ? 0
  eq -1, -1 ? 0
  assertOneCoercion (a) ->
    eq 1, +a ? 0
  assertOneCoercion (a) ->
    eq -1, -a ? 0
  assertOneCoercion (a) ->
    eq -2, ~a ? 0
  assertOneCoercion (a) ->
    eq 0.5, a / 2 ? 0

  ok -2 <= 1 < 2
  ok -2 <= +1 < 2
  ok -2 <= -1 < 2
  assertOneCoercion (a) ->
    ok -2 <= +a < 2
  assertOneCoercion (a) ->
    ok -2 <= -a < 2
  assertOneCoercion (a) ->
    ok -2 <= ~a < 2
  assertOneCoercion (a) ->
    ok -2 <= a / 2 < 2

  arrayEq [0], (n for n in [0] by 1)
  arrayEq [0], (n for n in [0] by +1)
  arrayEq [0], (n for n in [0] by -1)
  assertOneCoercion (a) ->
    arrayEq [0], (n for n in [0] by +a)
  assertOneCoercion (a) ->
    arrayEq [0], (n for n in [0] by -a)
  assertOneCoercion (a) ->
    arrayEq [0], (n for n in [0] by ~a)
  assertOneCoercion (a) ->
    arrayEq [0], (n for n in [0] by (a * 2) / 2)

  ok 1 in [0, 1]
  ok +1 in [0, 1]
  ok -1 in [0, -1]
  assertOneCoercion (a) ->
    ok +a in [0, 1]
  assertOneCoercion (a) ->
    ok -a in [0, -1]
  assertOneCoercion (a) ->
    ok ~a in [0, -2]
  assertOneCoercion (a) ->
    ok a / 2 in [0, 0.5]

test "'new' target", ->
  nonce = {}
  ctor = -> nonce

  eq new ctor(), nonce
  eq new ctor(), nonce

  ok new (class)()

  ctor = class
  ok new ctor() instanceof ctor
  ok new ctor() instanceof ctor

  # Force an executable class body
  ctor = class
    a = 1
  ok new ctor() instanceof ctor

  get = -> ctor
  ok new get() not instanceof ctor
  ok new (get())() instanceof ctor

  # classes must be called with \`new\`. In this case \`new\` applies to \`get\` only
  throws -> new get()()

`;

exports[`ranges.coffee 1`] = `
# Range Literals
# --------------

# TODO: add indexing and method invocation tests: [1..4][0] is 1, [0...3].toString()

# shared array
shared = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

test "basic inclusive ranges", ->
  arrayEq [1, 2, 3] , [1..3]
  arrayEq [0, 1, 2] , [0..2]
  arrayEq [0, 1]    , [0..1]
  arrayEq [0]       , [0..0]
  arrayEq [-1]      , [-1..-1]
  arrayEq [-1, 0]   , [-1..0]
  arrayEq [-1, 0, 1], [-1..1]

test "basic exclusive ranges", ->
  arrayEq [1, 2, 3] , [1...4]
  arrayEq [0, 1, 2] , [0...3]
  arrayEq [0, 1]    , [0...2]
  arrayEq [0]       , [0...1]
  arrayEq [-1]      , [-1...0]
  arrayEq [-1, 0]   , [-1...1]
  arrayEq [-1, 0, 1], [-1...2]

  arrayEq [], [1...1]
  arrayEq [], [0...0]
  arrayEq [], [-1...-1]

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  arrayEq [1, 2, 3] , [1 ... 4]
  arrayEq [0, 1, 2] , [0 ... 3]
  arrayEq [0, 1]    , [0 ... 2]
  arrayEq [0]       , [0 ... 1]
  arrayEq [-1]      , [-1 ... 0]
  arrayEq [-1, 0]   , [-1 ... 1]
  arrayEq [-1, 0, 1], [-1 ... 2]

  arrayEq [], [1 ... 1]
  arrayEq [], [0 ... 0]
  arrayEq [], [-1 ... -1]

test "downward ranges", ->
  arrayEq shared, [9..0].reverse()
  arrayEq [5, 4, 3, 2] , [5..2]
  arrayEq [2, 1, 0, -1], [2..-1]

  arrayEq [3, 2, 1]  , [3..1]
  arrayEq [2, 1, 0]  , [2..0]
  arrayEq [1, 0]     , [1..0]
  arrayEq [0]        , [0..0]
  arrayEq [-1]       , [-1..-1]
  arrayEq [0, -1]    , [0..-1]
  arrayEq [1, 0, -1] , [1..-1]
  arrayEq [0, -1, -2], [0..-2]

  arrayEq [4, 3, 2], [4...1]
  arrayEq [3, 2, 1], [3...0]
  arrayEq [2, 1]   , [2...0]
  arrayEq [1]      , [1...0]
  arrayEq []       , [0...0]
  arrayEq []       , [-1...-1]
  arrayEq [0]      , [0...-1]
  arrayEq [0, -1]  , [0...-2]
  arrayEq [1, 0]   , [1...-1]
  arrayEq [2, 1, 0], [2...-1]

test "ranges with variables as enpoints", ->
  [a, b] = [1, 3]
  arrayEq [1, 2, 3], [a..b]
  arrayEq [1, 2]   , [a...b]
  b = -2
  arrayEq [1, 0, -1, -2], [a..b]
  arrayEq [1, 0, -1]    , [a...b]

test "ranges with expressions as endpoints", ->
  [a, b] = [1, 3]
  arrayEq [2, 3, 4, 5, 6], [(a+1)..2*b]
  arrayEq [2, 3, 4, 5]   , [(a+1)...2*b]

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  arrayEq [2, 3, 4, 5]   , [(a+1) ... 2*b]

test "large ranges are generated with looping constructs", ->
  down = [99..0]
  eq 100, (len = down.length)
  eq   0, down[len - 1]

  up = [0...100]
  eq 100, (len = up.length)
  eq  99, up[len - 1]

test "for-from loops over ranges", ->
  array1 = []
  for x from [20..30]
    array1.push(x)
    break if x is 25
  arrayEq array1, [20, 21, 22, 23, 24, 25]

test "for-from comprehensions over ranges", ->
  array1 = (x + 10 for x from [20..25])
  ok array1.join(' ') is '30 31 32 33 34 35'

  array2 = (x for x from [20..30] when x %% 2 == 0)
  ok array2.join(' ') is '20 22 24 26 28 30'

test "#1012 slices with arguments object", ->
  expected = [0..9]
  argsAtStart = (-> [arguments[0]..9]) 0
  arrayEq expected, argsAtStart
  argsAtEnd = (-> [0..arguments[0]]) 9
  arrayEq expected, argsAtEnd
  argsAtBoth = (-> [arguments[0]..arguments[1]]) 0, 9
  arrayEq expected, argsAtBoth

test "#1409: creating large ranges outside of a function body", ->
  CoffeeScript.eval '[0..100]'

test "#2047: Infinite loop possible when \`for\` loop with \`range\` uses variables", ->
  up = 1
  down = -1
  a = 1
  b = 5

  testRange = (arg) ->
    [from, to, step, expectedResult] = arg
    r = (x for x in [from..to] by step)
    arrayEq r, expectedResult

  testData = [
    [1, 5, 1, [1..5]]
    [1, 5, -1, []]
    [1, 5, up, [1..5]]
    [1, 5, down, []]

    [a, 5, 1, [1..5]]
    [a, 5, -1, []]
    [a, 5, up, [1..5]]
    [a, 5, down, []]

    [1, b, 1, [1..5]]
    [1, b, -1, []]
    [1, b, up, [1..5]]
    [1, b, down, []]

    [a, b, 1, [1..5]]
    [a, b, -1, []]
    [a, b, up, [1..5]]
    [a, b, down, []]

    [5, 1, 1, []]
    [5, 1, -1, [5..1]]
    [5, 1, up, []]
    [5, 1, down,  [5..1]]

    [5, a, 1, []]
    [5, a, -1, [5..1]]
    [5, a, up, []]
    [5, a, down, [5..1]]

    [b, 1, 1, []]
    [b, 1, -1, [5..1]]
    [b, 1, up, []]
    [b, 1, down, [5..1]]

    [b, a, 1, []]
    [b, a, -1, [5..1]]
    [b, a, up, []]
    [b, a, down, [5..1]]
  ]

  testRange d for d in testData

test "#2047: from, to and step as variables", ->
  up = 1
  down = -1
  a = 1
  b = 5

  r = (x for x in [a..b] by up)
  arrayEq r, [1..5]

  r = (x for x in [a..b] by down)
  arrayEq r, []

  r = (x for x in [b..a] by up)
  arrayEq r, []

  r = (x for x in [b..a] by down)
  arrayEq r, [5..1]

  a = 1
  b = -1
  step = 0
  r = (x for x in [b..a] by step)
  arrayEq r, []

test "#4884: Range not declaring var for the 'i'", ->
  'use strict'
  [0..21].forEach (idx) ->
    idx + 1

  eq global.i, undefined

test "#4889: \`for\` loop unexpected behavior", ->
  n = 1
  result = []
  for i in [0..n]
    result.push i
    for j in [(i+1)..n]
      result.push j

  arrayEq result, [0,1,1,2,1]

test "#4889: \`for\` loop unexpected behavior with \`by 1\` on second loop", ->
  n = 1
  result = []
  for i in [0..n]
    result.push i
    for j in [(i+1)..n] by 1
      result.push j

  arrayEq result, [0,1,1]

test "countdown example from docs", ->
  countdown = (num for num in [10..1])
  arrayEq countdown, [10,9,8,7,6,5,4,3,2,1]

test "counting up when the range goes down returns an empty array", ->
  countdown = (num for num in [10..1] by 1)
  arrayEq countdown, []

test "counting down when the range goes up returns an empty array", ->
  countup = (num for num in [1..10] by -1)
  arrayEq countup, []

test "counting down by too much returns just the first value", ->
  countdown = (num for num in [10..1] by -100)
  arrayEq countdown, [10]

test "counting up by too much returns just the first value", ->
  countup = (num for num in [1..10] by 100)
  arrayEq countup, [1]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Range Literals
# --------------

# TODO: add indexing and method invocation tests: [1..4][0] is 1, [0...3].toString()

# shared array
shared = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

test 'basic inclusive ranges', ->
  arrayEq [1, 2, 3], [1..3]
  arrayEq [0, 1, 2], [0..2]
  arrayEq [0, 1], [0..1]
  arrayEq [0], [0..0]
  arrayEq [-1], [-1..-1]
  arrayEq [-1, 0], [-1..0]
  arrayEq [-1, 0, 1], [-1..1]

test 'basic exclusive ranges', ->
  arrayEq [1, 2, 3], [1...4]
  arrayEq [0, 1, 2], [0...3]
  arrayEq [0, 1], [0...2]
  arrayEq [0], [0...1]
  arrayEq [-1], [-1...0]
  arrayEq [-1, 0], [-1...1]
  arrayEq [-1, 0, 1], [-1...2]

  arrayEq [], [1...1]
  arrayEq [], [0...0]
  arrayEq [], [-1...-1]

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  arrayEq [1, 2, 3], [1...4]
  arrayEq [0, 1, 2], [0...3]
  arrayEq [0, 1], [0...2]
  arrayEq [0], [0...1]
  arrayEq [-1], [-1...0]
  arrayEq [-1, 0], [-1...1]
  arrayEq [-1, 0, 1], [-1...2]

  arrayEq [], [1...1]
  arrayEq [], [0...0]
  arrayEq [], [-1...-1]

test 'downward ranges', ->
  arrayEq shared, [9..0].reverse()
  arrayEq [5, 4, 3, 2], [5..2]
  arrayEq [2, 1, 0, -1], [2..-1]

  arrayEq [3, 2, 1], [3..1]
  arrayEq [2, 1, 0], [2..0]
  arrayEq [1, 0], [1..0]
  arrayEq [0], [0..0]
  arrayEq [-1], [-1..-1]
  arrayEq [0, -1], [0..-1]
  arrayEq [1, 0, -1], [1..-1]
  arrayEq [0, -1, -2], [0..-2]

  arrayEq [4, 3, 2], [4...1]
  arrayEq [3, 2, 1], [3...0]
  arrayEq [2, 1], [2...0]
  arrayEq [1], [1...0]
  arrayEq [], [0...0]
  arrayEq [], [-1...-1]
  arrayEq [0], [0...-1]
  arrayEq [0, -1], [0...-2]
  arrayEq [1, 0], [1...-1]
  arrayEq [2, 1, 0], [2...-1]

test 'ranges with variables as enpoints', ->
  [a, b] = [1, 3]
  arrayEq [1, 2, 3], [a..b]
  arrayEq [1, 2], [a...b]
  b = -2
  arrayEq [1, 0, -1, -2], [a..b]
  arrayEq [1, 0, -1], [a...b]

test 'ranges with expressions as endpoints', ->
  [a, b] = [1, 3]
  arrayEq [2, 3, 4, 5, 6], [(a + 1)..(2 * b)]
  arrayEq [2, 3, 4, 5], [(a + 1)...(2 * b)]

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  arrayEq [2, 3, 4, 5], [(a + 1)...(2 * b)]

test 'large ranges are generated with looping constructs', ->
  down = [99..0]
  eq 100, (len = down.length)
  eq 0, down[len - 1]

  up = [0...100]
  eq 100, (len = up.length)
  eq 99, up[len - 1]

test 'for-from loops over ranges', ->
  array1 = []
  for x from [20..30]
    array1.push x
    break if x is 25
  arrayEq array1, [20, 21, 22, 23, 24, 25]

test 'for-from comprehensions over ranges', ->
  array1 = (x + 10 for x from [20..25])
  ok array1.join(' ') is '30 31 32 33 34 35'

  array2 = (x for x from [20..30] when x %% 2 == 0)
  ok array2.join(' ') is '20 22 24 26 28 30'

test '#1012 slices with arguments object', ->
  expected = [0..9]
  argsAtStart = (-> [arguments[0]..9]) 0
  arrayEq expected, argsAtStart
  argsAtEnd = (-> [0..arguments[0]]) 9
  arrayEq expected, argsAtEnd
  argsAtBoth = (-> [arguments[0]..arguments[1]]) 0, 9
  arrayEq expected, argsAtBoth

test '#1409: creating large ranges outside of a function body', ->
  CoffeeScript.eval '[0..100]'

test '#2047: Infinite loop possible when \`for\` loop with \`range\` uses variables', ->
  up = 1
  down = -1
  a = 1
  b = 5

  testRange = (arg) ->
    [from, to, step, expectedResult] = arg
    r = (x for x in [from..to] by step)
    arrayEq r, expectedResult

  testData = [
    [1, 5, 1, [1..5]]
    [1, 5, -1, []]
    [1, 5, up, [1..5]]
    [1, 5, down, []]

    [a, 5, 1, [1..5]]
    [a, 5, -1, []]
    [a, 5, up, [1..5]]
    [a, 5, down, []]

    [1, b, 1, [1..5]]
    [1, b, -1, []]
    [1, b, up, [1..5]]
    [1, b, down, []]

    [a, b, 1, [1..5]]
    [a, b, -1, []]
    [a, b, up, [1..5]]
    [a, b, down, []]

    [5, 1, 1, []]
    [5, 1, -1, [5..1]]
    [5, 1, up, []]
    [5, 1, down, [5..1]]

    [5, a, 1, []]
    [5, a, -1, [5..1]]
    [5, a, up, []]
    [5, a, down, [5..1]]

    [b, 1, 1, []]
    [b, 1, -1, [5..1]]
    [b, 1, up, []]
    [b, 1, down, [5..1]]

    [b, a, 1, []]
    [b, a, -1, [5..1]]
    [b, a, up, []]
    [b, a, down, [5..1]]
  ]

  testRange d for d in testData

test '#2047: from, to and step as variables', ->
  up = 1
  down = -1
  a = 1
  b = 5

  r = (x for x in [a..b] by up)
  arrayEq r, [1..5]

  r = (x for x in [a..b] by down)
  arrayEq r, []

  r = (x for x in [b..a] by up)
  arrayEq r, []

  r = (x for x in [b..a] by down)
  arrayEq r, [5..1]

  a = 1
  b = -1
  step = 0
  r = (x for x in [b..a] by step)
  arrayEq r, []

test "#4884: Range not declaring var for the 'i'", ->
  'use strict'
  [0..21].forEach (idx) ->
    idx + 1

  eq global.i, undefined

test '#4889: \`for\` loop unexpected behavior', ->
  n = 1
  result = []
  for i in [0..n]
    result.push i
    for j in [(i + 1)..n]
      result.push j

  arrayEq result, [0, 1, 1, 2, 1]

test '#4889: \`for\` loop unexpected behavior with \`by 1\` on second loop', ->
  n = 1
  result = []
  for i in [0..n]
    result.push i
    for j in [(i + 1)..n] by 1
      result.push j

  arrayEq result, [0, 1, 1]

test 'countdown example from docs', ->
  countdown = (num for num in [10..1])
  arrayEq countdown, [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

test 'counting up when the range goes down returns an empty array', ->
  countdown = (num for num in [10..1] by 1)
  arrayEq countdown, []

test 'counting down when the range goes up returns an empty array', ->
  countup = (num for num in [1..10] by -1)
  arrayEq countup, []

test 'counting down by too much returns just the first value', ->
  countdown = (num for num in [10..1] by -100)
  arrayEq countdown, [10]

test 'counting up by too much returns just the first value', ->
  countup = (num for num in [1..10] by 100)
  arrayEq countup, [1]

`;

exports[`regex.coffee 1`] = `
# Regular Expression Literals
# ---------------------------

# TODO: add method invocation tests: /regex/.toString()

# * Regexen
# * Heregexen

test "basic regular expression literals", ->
  ok 'a'.match(/a/)
  ok 'a'.match /a/
  ok 'a'.match(/a/g)
  ok 'a'.match /a/g

test "division is not confused for a regular expression", ->
  # Any spacing around the slash is allowed when it cannot be a regex.
  eq 2, 4 / 2 / 1
  eq 2, 4/2/1
  eq 2, 4/ 2 / 1
  eq 2, 4 /2 / 1
  eq 2, 4 / 2/ 1
  eq 2, 4 / 2 /1
  eq 2, 4 /2/ 1

  a = (regex) -> regex.test 'a b c'
  a.valueOf = -> 4
  b = 2
  g = 1

  eq 2, a / b/g
  eq 2, a/ b/g
  eq 2, a / b/ g
  eq 2, a	/	b/g # Tabs.
  eq 2, a / b/g # Non-breaking spaces.
  eq true, a /b/g
  # Use parentheses to disambiguate.
  eq true, a(/ b/g)
  eq true, a(/ b/)
  eq true, a (/ b/)
  # Escape to disambiguate.
  eq true, a /\\ b/g
  eq false, a	/\\	b/g
  eq true, a /\\ b/

  obj = method: -> 2
  two = 2
  eq 2, (obj.method()/two + obj.method()/two)

  i = 1
  eq 2, (4)/2/i
  eq 1, i/i/i

  a = ''
  a += ' ' until /   /.test a
  eq a, '   '

  a = if /=/.test '=' then yes else no
  eq a, yes

  a = if !/=/.test '=' then yes else no
  eq a, no

  #3182:
  match = 'foo=bar'.match /=/
  eq match[0], '='

  #3410:
  ok ' '.match(/ /)[0] is ' '


test "division vs regex after a callable token", ->
  b = 2
  g = 1
  r = (r) -> r.test 'b'

  a = 4
  eq 2, a / b/g
  eq 2, a/b/g
  eq 2, a/ b/g
  eq true, r /b/g
  eq 2, (1 + 3) / b/g
  eq 2, (1 + 3)/b/g
  eq 2, (1 + 3)/ b/g
  eq true, (r) /b/g
  eq 2, [4][0] / b/g
  eq 2, [4][0]/b/g
  eq 2, [4][0]/ b/g
  eq true, [r][0] /b/g
  eq 0.5, 4? / b/g
  eq 0.5, 4?/b/g
  eq 0.5, 4?/ b/g
  eq true, r? /b/g
  (->
    eq 2, @ / b/g
    eq 2, @/b/g
    eq 2, @/ b/g
  ).call 4
  (->
    eq true, @ /b/g
  ).call r
  (->
    eq 2, this / b/g
    eq 2, this/b/g
    eq 2, this/ b/g
  ).call 4
  (->
    eq true, this /b/g
  ).call r
  class A
    p: (regex) -> if regex then r regex else 4
  class B extends A
    p: ->
      eq 2, super() / b/g
      eq 2, super()/b/g
      eq 2, super()/ b/g
      eq true, super /b/g
  new B().p()

test "always division and never regex after some tokens", ->
  b = 2
  g = 1

  eq 2, 4 / b/g
  eq 2, 4/b/g
  eq 2, 4/ b/g
  eq 2, 4 /b/g
  eq 2, "4" / b/g
  eq 2, "4"/b/g
  eq 2, "4"/ b/g
  eq 2, "4" /b/g
  eq 20, "4#{0}" / b/g
  eq 20, "4#{0}"/b/g
  eq 20, "4#{0}"/ b/g
  eq 20, "4#{0}" /b/g
  ok isNaN /a/ / b/g
  ok isNaN /a/i / b/g
  ok isNaN /a//b/g
  ok isNaN /a/i/b/g
  ok isNaN /a// b/g
  ok isNaN /a/i/ b/g
  ok isNaN /a/ /b/g
  ok isNaN /a/i /b/g
  eq 0.5, true / b/g
  eq 0.5, true/b/g
  eq 0.5, true/ b/g
  eq 0.5, true /b/g
  eq 0, false / b/g
  eq 0, false/b/g
  eq 0, false/ b/g
  eq 0, false /b/g
  eq 0, null / b/g
  eq 0, null/b/g
  eq 0, null/ b/g
  eq 0, null /b/g
  ok isNaN undefined / b/g
  ok isNaN undefined/b/g
  ok isNaN undefined/ b/g
  ok isNaN undefined /b/g
  ok isNaN {a: 4} / b/g
  ok isNaN {a: 4}/b/g
  ok isNaN {a: 4}/ b/g
  ok isNaN {a: 4} /b/g
  o = prototype: 4
  eq 2, o:: / b/g
  eq 2, o::/b/g
  eq 2, o::/ b/g
  eq 2, o:: /b/g
  i = 4
  eq 2.0, i++ / b/g
  eq 2.5, i++/b/g
  eq 3.0, i++/ b/g
  eq 3.5, i++ /b/g
  eq 4.0, i-- / b/g
  eq 3.5, i--/b/g
  eq 3.0, i--/ b/g
  eq 2.5, i-- /b/g

test "compound division vs regex", ->
  c = 4
  i = 2

  a = 10
  b = a /= c / i
  eq a, 5

  a = 10
  b = a /= c /i
  eq a, 5

  a = 10
  b = a	/=	c /i # Tabs.
  eq a, 5

  a = 10
  b = a /= c /i # Non-breaking spaces.
  eq a, 5

  a = 10
  b = a/= c /i
  eq a, 5

  a = 10
  b = a/=c/i
  eq a, 5

  a = (regex) -> regex.test '=C '
  b = a /=c /i
  eq b, true

  a = (regex) -> regex.test '= C '
  # Use parentheses to disambiguate.
  b = a(/= c /i)
  eq b, true
  b = a(/= c /)
  eq b, false
  b = a (/= c /)
  eq b, false
  # Escape to disambiguate.
  b = a /\\= c /i
  eq b, true
  b = a /\\= c /
  eq b, false

test "#764: regular expressions should be indexable", ->
  eq /0/['source'], ///#{0}///['source']

test "#584: slashes are allowed unescaped in character classes", ->
  ok /^a\\/[/]b$/.test 'a//b'

test "does not allow to escape newlines", ->
  throws -> CoffeeScript.compile '/a\\\\\\nb/'


# Heregexe(n|s)

test "a heregex will ignore whitespace and comments", ->
  eq /^I'm\\x20+[a]\\s+Heregex?\\/\\/\\//gim + '', ///
    ^ I'm \\x20+ [a] \\s+
    Heregex? / // # or not
  ///gim + ''

test "an empty heregex will compile to an empty, non-capturing group", ->
  eq /(?:)/ + '', ///  /// + ''
  eq /(?:)/ + '', ////// + ''

test "heregex starting with slashes", ->
  ok /////a/\\////.test ' //a// '

test '#2388: \`///\` in heregex interpolations', ->
  ok ///a#{///b///}c///.test ' /a/b/c/ '
  ws = ' \\t'
  scan = (regex) -> regex.exec('\\t  foo')[0]
  eq '/\\t  /', /// #{scan /// [#{ws}]* ///} /// + ''

test "regexes are not callable", ->
  throws -> CoffeeScript.compile '/a/()'
  throws -> CoffeeScript.compile '///a#{b}///()'
  throws -> CoffeeScript.compile '/a/ 1'
  throws -> CoffeeScript.compile '///a#{b}/// 1'
  throws -> CoffeeScript.compile '''
    /a/
       k: v
  '''
  throws -> CoffeeScript.compile '''
    ///a#{b}///
       k: v
  '''

test "backreferences", ->
  ok /(a)(b)\\2\\1/.test 'abba'

test "#3795: Escape otherwise invalid characters", ->
  ok (/ /).test '\\u2028'
  ok (/ /).test '\\u2029'
  ok ///\\ ///.test '\\u2028'
  ok ///\\ ///.test '\\u2029'
  ok ///a b///.test 'ab' # The space is U+2028.
  ok ///a b///.test 'ab' # The space is U+2029.
  ok ///\\0
      1///.test '\\x001'

  a = 'a'
  ok ///#{a} b///.test 'ab' # The space is U+2028.
  ok ///#{a} b///.test 'ab' # The space is U+2029.
  ok ///#{a}\\ ///.test 'a\\u2028'
  ok ///#{a}\\ ///.test 'a\\u2029'
  ok ///#{a}\\0
      1///.test 'a\\x001'

test "#4248: Unicode code point escapes", ->
  ok /a\\u{1ab}c/u.test 'a\\u01abc'
  ok ///#{ 'a' }\\u{000001ab}c///u.test 'a\\u{1ab}c'
  ok ///a\\u{000001ab}c///u.test 'a\\u{1ab}c'
  ok /a\\u{12345}c/u.test 'a\\ud808\\udf45c'

  # and now without u flag
  ok /a\\u{1ab}c/.test 'a\\u01abc'
  ok ///#{ 'a' }\\u{000001ab}c///.test 'a\\u{1ab}c'
  ok ///a\\u{000001ab}c///.test 'a\\u{1ab}c'
  ok /a\\u{12345}c/.test 'a\\ud808\\udf45c'

  # rewrite code point escapes unless u flag is set
  eqJS """
    /\\\\u{bcdef}\\\\u{abc}/u
  """,
  """
    /\\\\u{bcdef}\\\\u{abc}/u;
  """

  eqJS """
    ///#{ 'a' }\\\\u{bcdef}///
  """,
  """
    /a\\\\udab3\\\\uddef/;
  """

test "#4811, heregex comments with ///", ->
  eqJS """
    ///
      a | # comment with ///
      b   # /// 'heregex' in comment will be consumed
    ///
  """,
  """
   /a|b/; // comment with ///
   // /// 'heregex' in comment will be consumed
  """
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Regular Expression Literals
# ---------------------------

# TODO: add method invocation tests: /regex/.toString()

# * Regexen
# * Heregexen

test 'basic regular expression literals', ->
  ok 'a'.match /a/
  ok 'a'.match /a/
  ok 'a'.match /a/g
  ok 'a'.match /a/g

test 'division is not confused for a regular expression', ->
  # Any spacing around the slash is allowed when it cannot be a regex.
  eq 2, 4 / 2 / 1
  eq 2, 4 / 2 / 1
  eq 2, 4 / 2 / 1
  eq 2, 4 / 2 / 1
  eq 2, 4 / 2 / 1
  eq 2, 4 / 2 / 1
  eq 2, 4 / 2 / 1

  a = (regex) -> regex.test 'a b c'
  a.valueOf = -> 4
  b = 2
  g = 1

  eq 2, a / b / g
  eq 2, a / b / g
  eq 2, a / b / g
  eq 2, a / b / g # Tabs.
  eq 2, a / b / g # Non-breaking spaces.
  eq true, a /b/g
  # Use parentheses to disambiguate.
  eq true, a(/ b/g)
  eq true, a(/ b/)
  eq true, a(/ b/)
  # Escape to disambiguate.
  eq true, a /\\ b/g
  eq false, a /\\	b/g
  eq true, a /\\ b/

  obj = method: -> 2
  two = 2
  eq 2, obj.method() / two + obj.method() / two

  i = 1
  eq 2, 4 / 2 / i
  eq 1, i / i / i

  a = ''
  a += ' ' until (/   /).test a
  eq a, '   '

  a = if /=/.test '=' then yes else no
  eq a, yes

  a = if !/=/.test '=' then yes else no
  eq a, no

  #3182:
  match = 'foo=bar'.match /=/
  eq match[0], '='

  #3410:
  ok ' '.match(/ /)[0] is ' '

test 'division vs regex after a callable token', ->
  b = 2
  g = 1
  r = (r) -> r.test 'b'

  a = 4
  eq 2, a / b / g
  eq 2, a / b / g
  eq 2, a / b / g
  eq true, r /b/g
  eq 2, (1 + 3) / b / g
  eq 2, (1 + 3) / b / g
  eq 2, (1 + 3) / b / g
  eq true, r /b/g
  eq 2, [4][0] / b / g
  eq 2, [4][0] / b / g
  eq 2, [4][0] / b / g
  eq true, [r][0] /b/g
  eq 0.5, 4? / b / g
  eq 0.5, 4? / b / g
  eq 0.5, 4? / b / g
  eq true, r? /b/g
  (->
    eq 2, @ / b / g
    eq 2, @ / b / g
    eq 2, @ / b / g
  ).call 4
  (->
    eq true, @ /b/g
  ).call r
  (->
    eq 2, this / b / g
    eq 2, this / b / g
    eq 2, this / b / g
  ).call 4
  (->
    eq true, this /b/g
  ).call r
  class A
    p: (regex) -> if regex then r regex else 4
  class B extends A
    p: ->
      eq 2, super() / b / g
      eq 2, super() / b / g
      eq 2, super() / b / g
      eq true, super /b/g
  new B().p()

test 'always division and never regex after some tokens', ->
  b = 2
  g = 1

  eq 2, 4 / b / g
  eq 2, 4 / b / g
  eq 2, 4 / b / g
  eq 2, 4 / b / g
  eq 2, '4' / b / g
  eq 2, '4' / b / g
  eq 2, '4' / b / g
  eq 2, '4' / b / g
  eq 20, "4#{0}" / b / g
  eq 20, "4#{0}" / b / g
  eq 20, "4#{0}" / b / g
  eq 20, "4#{0}" / b / g
  ok isNaN /a/ / b / g
  ok isNaN /a/i / b / g
  ok isNaN /a/ / b / g
  ok isNaN /a/i / b / g
  ok isNaN /a/ / b / g
  ok isNaN /a/i / b / g
  ok isNaN /a/ / b / g
  ok isNaN /a/i / b / g
  eq 0.5, true / b / g
  eq 0.5, true / b / g
  eq 0.5, true / b / g
  eq 0.5, true / b / g
  eq 0, false / b / g
  eq 0, false / b / g
  eq 0, false / b / g
  eq 0, false / b / g
  eq 0, null / b / g
  eq 0, null / b / g
  eq 0, null / b / g
  eq 0, null / b / g
  ok isNaN undefined / b / g
  ok isNaN undefined / b / g
  ok isNaN undefined / b / g
  ok isNaN undefined / b / g
  ok isNaN { a: 4 } / b / g
  ok isNaN { a: 4 } / b / g
  ok isNaN { a: 4 } / b / g
  ok isNaN { a: 4 } / b / g
  o = prototype: 4
  eq 2, o:: / b / g
  eq 2, o:: / b / g
  eq 2, o:: / b / g
  eq 2, o:: / b / g
  i = 4
  eq 2.0, i++ / b / g
  eq 2.5, i++ / b / g
  eq 3.0, i++ / b / g
  eq 3.5, i++ / b / g
  eq 4.0, i-- / b / g
  eq 3.5, i-- / b / g
  eq 3.0, i-- / b / g
  eq 2.5, i-- / b / g

test 'compound division vs regex', ->
  c = 4
  i = 2

  a = 10
  b = a /= c / i
  eq a, 5

  a = 10
  b = a /= c / i
  eq a, 5

  a = 10
  b = a /= c / i # Tabs.
  eq a, 5

  a = 10
  b = a /= c / i # Non-breaking spaces.
  eq a, 5

  a = 10
  b = a /= c / i
  eq a, 5

  a = 10
  b = a /= c / i
  eq a, 5

  a = (regex) -> regex.test '=C '
  b = a /=c /i
  eq b, true

  a = (regex) -> regex.test '= C '
  # Use parentheses to disambiguate.
  b = a(/= c /i)
  eq b, true
  b = a(/= c /)
  eq b, false
  b = a(/= c /)
  eq b, false
  # Escape to disambiguate.
  b = a /\\= c /i
  eq b, true
  b = a /\\= c /
  eq b, false

test '#764: regular expressions should be indexable', ->
  eq /0/['source'], ///#{0}///['source']

test '#584: slashes are allowed unescaped in character classes', ->
  ok /^a\\/[/]b$/.test 'a//b'

test 'does not allow to escape newlines', ->
  throws -> CoffeeScript.compile '/a\\\\\\nb/'

# Heregexe(n|s)

test 'a heregex will ignore whitespace and comments', ->
  eq(
    /^I'm\\x20+[a]\\s+Heregex?\\/\\/\\//gim + ''
    ///
    ^ I'm \\x20+ [a] \\s+
    Heregex? / // # or not
  ///gim + ''
  )

test 'an empty heregex will compile to an empty, non-capturing group', ->
  eq /(?:)/ + '', ///  /// + ''
  eq /(?:)/ + '', ////// + ''

test 'heregex starting with slashes', ->
  ok /////a/\\////.test ' //a// '

test '#2388: \`///\` in heregex interpolations', ->
  ok ///a#{///b///}c///.test ' /a/b/c/ '
  ws = ' \\t'
  scan = (regex) -> regex.exec('\\t  foo')[0]
  eq '/\\t  /', /// #{scan /// [#{ws}]* ///} /// + ''

test 'regexes are not callable', ->
  throws -> CoffeeScript.compile '/a/()'
  throws -> CoffeeScript.compile '///a#{b}///()'
  throws -> CoffeeScript.compile '/a/ 1'
  throws -> CoffeeScript.compile '///a#{b}/// 1'
  throws ->
    CoffeeScript.compile '''
    /a/
       k: v
  '''
  throws ->
    CoffeeScript.compile '''
    ///a#{b}///
       k: v
  '''

test 'backreferences', ->
  ok /(a)(b)\\2\\1/.test 'abba'

test '#3795: Escape otherwise invalid characters', ->
  ok (/ /).test '\\u2028'
  ok (/ /).test '\\u2029'
  ok ///\\ ///.test '\\u2028'
  ok ///\\ ///.test '\\u2029'
  ok ///a b///.test 'ab' # The space is U+2028.
  ok ///a b///.test 'ab' # The space is U+2029.
  ok ///\\0
      1///.test '\\x001'

  a = 'a'
  ok ///#{a} b///.test 'ab' # The space is U+2028.
  ok ///#{a} b///.test 'ab' # The space is U+2029.
  ok ///#{a}\\ ///.test 'a\\u2028'
  ok ///#{a}\\ ///.test 'a\\u2029'
  ok(
    ///#{a}\\0
      1///.test 'a\\x001'
  )

test '#4248: Unicode code point escapes', ->
  ok /a\\u{1ab}c/u.test 'a\\u01abc'
  ok ///#{'a'}\\u{000001ab}c///u.test 'a\\u{1ab}c'
  ok ///a\\u{000001ab}c///u.test 'a\\u{1ab}c'
  ok /a\\u{12345}c/u.test 'a\\ud808\\udf45c'

  # and now without u flag
  ok /a\\u{1ab}c/.test 'a\\u01abc'
  ok ///#{'a'}\\u{000001ab}c///.test 'a\\u{1ab}c'
  ok ///a\\u{000001ab}c///.test 'a\\u{1ab}c'
  ok /a\\u{12345}c/.test 'a\\ud808\\udf45c'

  # rewrite code point escapes unless u flag is set
  eqJS(
    '''
    /\\\\u{bcdef}\\\\u{abc}/u
  '''
    '''
    /\\\\u{bcdef}\\\\u{abc}/u;
  '''
  )

  eqJS(
    """
    ///#{'a'}\\\\u{bcdef}///
  """
    '''
    /a\\\\udab3\\\\uddef/;
  '''
  )

test '#4811, heregex comments with ///', ->
  eqJS(
    '''
    ///
      a | # comment with ///
      b   # /// 'heregex' in comment will be consumed
    ///
  '''
    '''
   /a|b/; // comment with ///
   // /// 'heregex' in comment will be consumed
  '''
  )

`;

exports[`regex_dotall.coffee 1`] = `
# Regex “dotall” flag, or \`s\`, is only supported in Node 9+, so put tests for
# the feature in their own file. The feature detection in \`Cakefile\` that
# causes this test to load is adapted from
# https://github.com/tc39/proposal-regexp-dotall-flag#proposed-solution.

test "dotall flag", ->
  doesNotThrow -> /a.b/s.test 'a\\nb'
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Regex “dotall” flag, or \`s\`, is only supported in Node 9+, so put tests for
# the feature in their own file. The feature detection in \`Cakefile\` that
# causes this test to load is adapted from
# https://github.com/tc39/proposal-regexp-dotall-flag#proposed-solution.

test 'dotall flag', ->
  doesNotThrow -> /a.b/s.test 'a\\nb'

`;

exports[`slicing_and_splicing.coffee 1`] = `
# Slicing and Splicing
# --------------------

# * Slicing
# * Splicing

# shared array
shared = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Slicing

test "basic slicing", ->
  arrayEq [7, 8, 9]   , shared[7..9]
  arrayEq [2, 3]      , shared[2...4]
  arrayEq [2, 3, 4, 5], shared[2...6]

test "slicing with variables as endpoints", ->
  [a, b] = [1, 4]
  arrayEq [1, 2, 3, 4], shared[a..b]
  arrayEq [1, 2, 3]   , shared[a...b]

test "slicing with expressions as endpoints", ->
  [a, b] = [1, 3]
  arrayEq [2, 3, 4, 5, 6], shared[(a+1)..2*b]
  arrayEq [2, 3, 4, 5]   , shared[a+1...(2*b)]

test "unbounded slicing", ->
  arrayEq [7, 8, 9]   , shared[7..]
  arrayEq [8, 9]      , shared[-2..]
  arrayEq [9]         , shared[-1...]
  arrayEq [0, 1, 2]   , shared[...3]
  arrayEq [0, 1, 2, 3], shared[..-7]

  arrayEq shared      , shared[..-1]
  arrayEq shared[0..8], shared[...-1]

  for a in [-shared.length..shared.length]
    arrayEq shared[a..] , shared[a...]
  for a in [-shared.length+1...shared.length]
    arrayEq shared[..a][...-1] , shared[...a]

  arrayEq [1, 2, 3], [1, 2, 3][..]

test "#930, #835, #831, #746 #624: inclusive slices to -1 should slice to end", ->
  arrayEq shared, shared[0..-1]
  arrayEq shared, shared[..-1]
  arrayEq shared.slice(1,shared.length), shared[1..-1]

test "string slicing", ->
  str = "abcdefghijklmnopqrstuvwxyz"
  ok str[1...1] is ""
  ok str[1..1] is "b"
  ok str[1...5] is "bcde"
  ok str[0..4] is "abcde"
  ok str[-5..] is "vwxyz"

test "#1722: operator precedence in unbounded slice compilation", ->
  list = [0..9]
  n = 2 # some truthy number in \`list\`
  arrayEq [0..n], list[..n]
  arrayEq [0..n], list[..n or 0]
  arrayEq [0..n], list[..if n then n else 0]

test "#2349: inclusive slicing to numeric strings", ->
  arrayEq [0, 1], [0..10][.."1"]

test "#4631: slicing with space before and/or after the dots", ->
  a = (s) -> s
  b = [4, 5, 6]
  c = [7, 8, 9]
  arrayEq [2, 3, 4], shared[2 ... 5]
  arrayEq [3, 4, 5], shared[3... 6]
  arrayEq [4, 5, 6], shared[4 ...7]
  arrayEq shared[(a b...)...(a c...)]  , shared[(a ...b)...(a ...c)]
  arrayEq shared[(a b...) ... (a c...)], shared[(a ...b) ... (a ...c)]
  arrayEq shared[(a b...)... (a c...)] , shared[(a ...b)... (a ...c)]
  arrayEq shared[(a b...) ...(a c...)] , shared[(a ...b) ...(a ...c)]


# Splicing

test "basic splicing", ->
  ary = [0..9]
  ary[5..9] = [0, 0, 0]
  arrayEq [0, 1, 2, 3, 4, 0, 0, 0], ary

  ary = [0..9]
  ary[2...8] = []
  arrayEq [0, 1, 8, 9], ary

test "unbounded splicing", ->
  ary = [0..9]
  ary[3..] = [9, 8, 7]
  arrayEq [0, 1, 2, 9, 8, 7]. ary

  ary[...3] = [7, 8, 9]
  arrayEq [7, 8, 9, 9, 8, 7], ary

  ary[..] = [1, 2, 3]
  arrayEq [1, 2, 3], ary

test "splicing with variables as endpoints", ->
  [a, b] = [1, 8]

  ary = [0..9]
  ary[a..b] = [2, 3]
  arrayEq [0, 2, 3, 9], ary

  ary = [0..9]
  ary[a...b] = [5]
  arrayEq [0, 5, 8, 9], ary

test "splicing with expressions as endpoints", ->
  [a, b] = [1, 3]

  ary = [0..9]
  ary[ a+1 .. 2*b+1 ] = [4]
  arrayEq [0, 1, 4, 8, 9], ary

  ary = [0..9]
  ary[a+1...2*b+1] = [4]
  arrayEq [0, 1, 4, 7, 8, 9], ary

test "splicing to the end, against a one-time function", ->
  ary = null
  fn = ->
    if ary
      throw 'err'
    else
      ary = [1, 2, 3]

  fn()[0..] = 1

  arrayEq ary, [1]

test "the return value of a splice literal should be the RHS", ->
  ary = [0, 0, 0]
  eq (ary[0..1] = 2), 2

  ary = [0, 0, 0]
  eq (ary[0..] = 3), 3

  arrayEq [ary[0..0] = 0], [0]

test "#1723: operator precedence in unbounded splice compilation", ->
  n = 4 # some truthy number in \`list\`

  list = [0..9]
  list[..n] = n
  arrayEq [n..9], list

  list = [0..9]
  list[..n or 0] = n
  arrayEq [n..9], list

  list = [0..9]
  list[..if n then n else 0] = n
  arrayEq [n..9], list

test "#2953: methods on endpoints in assignment from array splice literal", ->
  list = [0..9]

  Number.prototype.same = -> this
  list[1.same()...9.same()] = 5
  delete Number.prototype.same

  arrayEq [0, 5, 9], list

test "#1726: \`Op\` expression in property access causes unexpected results", ->
  a = [0..2]
  arrayEq a, a[(!1 in a)..]
  arrayEq a, a[!1 in a..]
  arrayEq a[(!1 in a)..], a[(!1 in a)..]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Slicing and Splicing
# --------------------

# * Slicing
# * Splicing

# shared array
shared = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Slicing

test 'basic slicing', ->
  arrayEq [7, 8, 9], shared[7..9]
  arrayEq [2, 3], shared[2...4]
  arrayEq [2, 3, 4, 5], shared[2...6]

test 'slicing with variables as endpoints', ->
  [a, b] = [1, 4]
  arrayEq [1, 2, 3, 4], shared[a..b]
  arrayEq [1, 2, 3], shared[a...b]

test 'slicing with expressions as endpoints', ->
  [a, b] = [1, 3]
  arrayEq [2, 3, 4, 5, 6], shared[(a + 1)..(2 * b)]
  arrayEq [2, 3, 4, 5], shared[(a + 1)...(2 * b)]

test 'unbounded slicing', ->
  arrayEq [7, 8, 9], shared[7..]
  arrayEq [8, 9], shared[-2..]
  arrayEq [9], shared[-1...]
  arrayEq [0, 1, 2], shared[...3]
  arrayEq [0, 1, 2, 3], shared[..-7]

  arrayEq shared, shared[..-1]
  arrayEq shared[0..8], shared[...-1]

  for a in [-shared.length..shared.length]
    arrayEq shared[a..], shared[a...]
  for a in [(-shared.length + 1)...shared.length]
    arrayEq shared[..a][...-1], shared[...a]

  arrayEq [1, 2, 3], [1, 2, 3][..]

test '#930, #835, #831, #746 #624: inclusive slices to -1 should slice to end', ->
  arrayEq shared, shared[0..-1]
  arrayEq shared, shared[..-1]
  arrayEq shared.slice(1, shared.length), shared[1..-1]

test 'string slicing', ->
  str = 'abcdefghijklmnopqrstuvwxyz'
  ok str[1...1] is ''
  ok str[1..1] is 'b'
  ok str[1...5] is 'bcde'
  ok str[0..4] is 'abcde'
  ok str[-5..] is 'vwxyz'

test '#1722: operator precedence in unbounded slice compilation', ->
  list = [0..9]
  n = 2 # some truthy number in \`list\`
  arrayEq [0..n], list[..n]
  arrayEq [0..n], list[..(n or 0)]
  arrayEq [0..n], list[..(if n then n else 0)]

test '#2349: inclusive slicing to numeric strings', ->
  arrayEq [0, 1], [0..10][..'1']

test '#4631: slicing with space before and/or after the dots', ->
  a = (s) -> s
  b = [4, 5, 6]
  c = [7, 8, 9]
  arrayEq [2, 3, 4], shared[2...5]
  arrayEq [3, 4, 5], shared[3...6]
  arrayEq [4, 5, 6], shared[4...7]
  arrayEq shared[(a b...)...(a c...)], shared[(a ...b)...(a ...c)]
  arrayEq shared[(a b...)...(a c...)], shared[(a ...b)...(a ...c)]
  arrayEq shared[(a b...)...(a c...)], shared[(a ...b)...(a ...c)]
  arrayEq shared[(a b...)...(a c...)], shared[(a ...b)...(a ...c)]

# Splicing

test 'basic splicing', ->
  ary = [0..9]
  ary[5..9] = [0, 0, 0]
  arrayEq [0, 1, 2, 3, 4, 0, 0, 0], ary

  ary = [0..9]
  ary[2...8] = []
  arrayEq [0, 1, 8, 9], ary

test 'unbounded splicing', ->
  ary = [0..9]
  ary[3..] = [9, 8, 7]
  arrayEq [0, 1, 2, 9, 8, 7].ary

  ary[...3] = [7, 8, 9]
  arrayEq [7, 8, 9, 9, 8, 7], ary

  ary[..] = [1, 2, 3]
  arrayEq [1, 2, 3], ary

test 'splicing with variables as endpoints', ->
  [a, b] = [1, 8]

  ary = [0..9]
  ary[a..b] = [2, 3]
  arrayEq [0, 2, 3, 9], ary

  ary = [0..9]
  ary[a...b] = [5]
  arrayEq [0, 5, 8, 9], ary

test 'splicing with expressions as endpoints', ->
  [a, b] = [1, 3]

  ary = [0..9]
  ary[(a + 1)..(2 * b + 1)] = [4]
  arrayEq [0, 1, 4, 8, 9], ary

  ary = [0..9]
  ary[(a + 1)...(2 * b + 1)] = [4]
  arrayEq [0, 1, 4, 7, 8, 9], ary

test 'splicing to the end, against a one-time function', ->
  ary = null
  fn = ->
    if ary
      throw 'err'
    else
      ary = [1, 2, 3]

  fn()[0..] = 1

  arrayEq ary, [1]

test 'the return value of a splice literal should be the RHS', ->
  ary = [0, 0, 0]
  eq (ary[0..1] = 2), 2

  ary = [0, 0, 0]
  eq (ary[0..] = 3), 3

  arrayEq [(ary[0..0] = 0)], [0]

test '#1723: operator precedence in unbounded splice compilation', ->
  n = 4 # some truthy number in \`list\`

  list = [0..9]
  list[..n] = n
  arrayEq [n..9], list

  list = [0..9]
  list[..(n or 0)] = n
  arrayEq [n..9], list

  list = [0..9]
  list[..(if n then n else 0)] = n
  arrayEq [n..9], list

test '#2953: methods on endpoints in assignment from array splice literal', ->
  list = [0..9]

  Number.prototype.same = -> this
  list[1.same()...9.same()] = 5
  delete Number.prototype.same

  arrayEq [0, 5, 9], list

test '#1726: \`Op\` expression in property access causes unexpected results', ->
  a = [0..2]
  arrayEq a, a[(!1 in a)..]
  arrayEq a, a[(!1 in a)..]
  arrayEq a[(!1 in a)..], a[(!1 in a)..]

`;

exports[`soaks.coffee 1`] = `
# Soaks
# -----

# * Soaked Property Access
# * Soaked Method Invocation
# * Soaked Function Invocation


# Soaked Property Access

test "soaked property access", ->
  nonce = {}
  obj = a: b: nonce
  eq nonce    , obj?.a.b
  eq nonce    , obj?['a'].b
  eq nonce    , obj.a?.b
  eq nonce    , obj?.a?['b']
  eq undefined, obj?.a?.non?.existent?.property

test "soaked property access caches method calls", ->
  nonce ={}
  obj = fn: -> a: nonce
  eq nonce    , obj.fn()?.a
  eq undefined, obj.fn()?.b

test "soaked property access caching", ->
  nonce = {}
  counter = 0
  fn = ->
    counter++
    'self'
  obj =
    self: -> @
    prop: nonce
  eq nonce, obj[fn()]()[fn()]()[fn()]()?.prop
  eq 3, counter

test "method calls on soaked methods", ->
  nonce = {}
  obj = null
  eq undefined, obj?.a().b()
  obj = a: -> b: -> nonce
  eq nonce    , obj?.a().b()

test "postfix existential operator mixes well with soaked property accesses", ->
  eq false, nonexistent?.property?

test "function invocation with soaked property access", ->
  id = (_) -> _
  eq undefined, id nonexistent?.method()

test "if-to-ternary should safely parenthesize soaked property accesses", ->
  ok (if nonexistent?.property then false else true)

test "#726: don't check for a property on a conditionally-referenced nonexistent thing", ->
  eq undefined, nonexistent?[Date()]

test "#756: conditional assignment edge cases", ->
  # TODO: improve this test
  a = null
  ok isNaN      a?.b.c +  1
  eq undefined, a?.b.c += 1
  eq undefined, ++a?.b.c
  eq undefined, delete a?.b.c

test "operations on soaked properties", ->
  # TODO: improve this test
  a = b: {c: 0}
  eq 1,   a?.b.c +  1
  eq 1,   a?.b.c += 1
  eq 2,   ++a?.b.c
  eq yes, delete a?.b.c


# Soaked Method Invocation

test "soaked method invocation", ->
  nonce = {}
  counter = 0
  obj =
    self: -> @
    increment: -> counter++; @
  eq obj      , obj.self?()
  eq undefined, obj.method?()
  eq nonce    , obj.self?().property = nonce
  eq undefined, obj.method?().property = nonce
  eq obj      , obj.increment().increment().self?()
  eq 2        , counter

test "#733: conditional assignments", ->
  a = b: {c: null}
  eq a.b?.c?(), undefined
  a.b?.c or= (it) -> it
  eq a.b?.c?(1), 1
  eq a.b?.c?([2, 3]...), 2


# Soaked Function Invocation

test "soaked function invocation", ->
  nonce = {}
  id = (_) -> _
  eq nonce    , id?(nonce)
  eq nonce    , (id? nonce)
  eq undefined, nonexistent?(nonce)
  eq undefined, (nonexistent? nonce)

test "soaked function invocation with generated functions", ->
  nonce = {}
  id = (_) -> _
  maybe = (fn, arg) -> if typeof fn is 'function' then () -> fn(arg)
  eq maybe(id, nonce)?(), nonce
  eq (maybe id, nonce)?(), nonce
  eq (maybe false, nonce)?(), undefined

test "soaked constructor invocation", ->
  eq 42       , +new Number? 42
  eq undefined,  new Other?  42

test "soaked constructor invocations with caching and property access", ->
  semaphore = 0
  nonce = {}
  class C
    constructor: ->
      ok false if semaphore
      semaphore++
    prop: nonce
  eq nonce, (new C())?.prop
  eq 1, semaphore

test "soaked function invocation safe on non-functions", ->
  eq undefined, (0)?(1)
  eq undefined, (0)? 1, 2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Soaks
# -----

# * Soaked Property Access
# * Soaked Method Invocation
# * Soaked Function Invocation

# Soaked Property Access

test 'soaked property access', ->
  nonce = {}
  obj = a: b: nonce
  eq nonce, obj?.a.b
  eq nonce, obj?['a'].b
  eq nonce, obj.a?.b
  eq nonce, obj?.a?['b']
  eq undefined, obj?.a?.non?.existent?.property

test 'soaked property access caches method calls', ->
  nonce = {}
  obj = fn: -> a: nonce
  eq nonce, obj.fn()?.a
  eq undefined, obj.fn()?.b

test 'soaked property access caching', ->
  nonce = {}
  counter = 0
  fn = ->
    counter++
    'self'
  obj =
    self: -> @
    prop: nonce
  eq nonce, obj[fn()]()[fn()]()[fn()]()?.prop
  eq 3, counter

test 'method calls on soaked methods', ->
  nonce = {}
  obj = null
  eq undefined, obj?.a().b()
  obj = a: -> b: -> nonce
  eq nonce, obj?.a().b()

test 'postfix existential operator mixes well with soaked property accesses', ->
  eq false, nonexistent?.property?

test 'function invocation with soaked property access', ->
  id = (_) -> _
  eq undefined, id nonexistent?.method()

test 'if-to-ternary should safely parenthesize soaked property accesses', ->
  ok if nonexistent?.property then false else true

test "#726: don't check for a property on a conditionally-referenced nonexistent thing", ->
  eq undefined, nonexistent?[Date()]

test '#756: conditional assignment edge cases', ->
  # TODO: improve this test
  a = null
  ok isNaN a?.b.c + 1
  eq undefined, a?.b.c += 1
  eq undefined, ++a?.b.c
  eq undefined, delete a?.b.c

test 'operations on soaked properties', ->
  # TODO: improve this test
  a = b: c: 0
  eq 1, a?.b.c + 1
  eq 1, a?.b.c += 1
  eq 2, ++a?.b.c
  eq yes, delete a?.b.c

# Soaked Method Invocation

test 'soaked method invocation', ->
  nonce = {}
  counter = 0
  obj =
    self: -> @
    increment: ->
      counter++
      @
  eq obj, obj.self?()
  eq undefined, obj.method?()
  eq nonce, (obj.self?().property = nonce)
  eq undefined, (obj.method?().property = nonce)
  eq(
    obj
    obj
      .increment()
      .increment()
      .self?()
  )
  eq 2, counter

test '#733: conditional assignments', ->
  a = b: c: null
  eq a.b?.c?(), undefined
  a.b?.c or= (it) -> it
  eq a.b?.c?(1), 1
  eq a.b?.c?([2, 3]...), 2

# Soaked Function Invocation

test 'soaked function invocation', ->
  nonce = {}
  id = (_) -> _
  eq nonce, id? nonce
  eq nonce, id? nonce
  eq undefined, nonexistent? nonce
  eq undefined, nonexistent? nonce

test 'soaked function invocation with generated functions', ->
  nonce = {}
  id = (_) -> _
  maybe = (fn, arg) -> if typeof fn is 'function' then -> fn arg
  eq maybe(id, nonce)?(), nonce
  eq maybe(id, nonce)?(), nonce
  eq maybe(false, nonce)?(), undefined

test 'soaked constructor invocation', ->
  eq 42, +new Number? 42
  eq undefined, new Other? 42

test 'soaked constructor invocations with caching and property access', ->
  semaphore = 0
  nonce = {}
  class C
    constructor: ->
      ok false if semaphore
      semaphore++
    prop: nonce
  eq nonce, new C()?.prop
  eq 1, semaphore

test 'soaked function invocation safe on non-functions', ->
  eq undefined, (0)? 1
  eq undefined, (0)? 1, 2

`;

exports[`strings.coffee 1`] = `
# String Literals
# ---------------

# TODO: refactor string literal tests
# TODO: add indexing and method invocation tests: "string"["toString"] is String::toString, "string".toString() is "string"

# * Strings
# * Heredocs

test "backslash escapes", ->
  eq "\\\\/\\\\\\\\", /\\/\\\\/.source

eq '(((dollars)))', '\\(\\(\\(dollars\\)\\)\\)'
eq 'one two three', "one
 two
 three"
eq "four five", 'four

 five'

test "#3229, multiline strings", ->
  # Separate lines by default by a single space in literal strings.
  eq 'one
      two', 'one two'
  eq "one
      two", 'one two'
  eq '
        a
        b
    ', 'a b'
  eq "
        a
        b
    ", 'a b'
  eq 'one

        two', 'one two'
  eq "one

        two", 'one two'
  eq '
    indentation
      doesn\\'t
  matter', 'indentation doesn\\'t matter'
  eq 'trailing ws      
    doesn\\'t matter', 'trailing ws doesn\\'t matter'

  # Use backslashes at the end of a line to specify whitespace between lines.
  eq 'a \\
      b\\
      c  \\
      d', 'a bc  d'
  eq "a \\
      b\\
      c  \\
      d", 'a bc  d'
  eq 'ignore  \\  
      trailing whitespace', 'ignore  trailing whitespace'

  # Backslash at the beginning of a literal string.
  eq '\\
      ok', 'ok'
  eq '  \\
      ok', '  ok'

  # #1273, empty strings.
  eq '\\
     ', ''
  eq '
     ', ''
  eq '
          ', ''
  eq '   ', '   '

  # Same behavior in interpolated strings.
  eq "interpolation #{1}
      follows #{2}  \\
      too #{3}\\
      !", 'interpolation 1 follows 2  too 3!'
  eq "a #{
    'string ' + "inside
                 interpolation"
    }", "a string inside interpolation"
  eq "
      #{1}
     ", '1'

  # Handle escaped backslashes correctly.
  eq '\\\\', \`'\\\\'\`
  eq 'escaped backslash at EOL\\\\
      next line', 'escaped backslash at EOL\\\\ next line'
  eq '\\\\
      next line', '\\\\ next line'
  eq '\\\\
     ', '\\\\'
  eq '\\\\\\\\\\\\
     ', '\\\\\\\\\\\\'
  eq "#{1}\\\\
      after interpolation", '1\\\\ after interpolation'
  eq 'escaped backslash before slash\\\\  \\
      next line', 'escaped backslash before slash\\\\  next line'
  eq 'triple backslash\\\\\\
      next line', 'triple backslash\\\\next line'
  eq 'several escaped backslashes\\\\\\\\\\\\
      ok', 'several escaped backslashes\\\\\\\\\\\\ ok'
  eq 'several escaped backslashes slash\\\\\\\\\\\\\\
      ok', 'several escaped backslashes slash\\\\\\\\\\\\ok'
  eq 'several escaped backslashes with trailing ws \\\\\\\\\\\\   
      ok', 'several escaped backslashes with trailing ws \\\\\\\\\\\\ ok'

  # Backslashes at beginning of lines.
  eq 'first line
      \\   backslash at BOL', 'first line \\   backslash at BOL'
  eq 'first line\\
      \\   backslash at BOL', 'first line\\   backslash at BOL'

  # Backslashes at end of strings.
  eq 'first line \\ ', 'first line  '
  eq 'first line
      second line \\
      ', 'first line second line '
  eq 'first line
      second line
      \\
      ', 'first line second line'
  eq 'first line
      second line

        \\

      ', 'first line second line'

  # Edge case.
  eq 'lone

        \\

        backslash', 'lone backslash'

test "#3249, escape newlines in heredocs with backslashes", ->
  # Ignore escaped newlines
  eq '''
    Set whitespace      \\
       <- this is ignored\\  
           none
      normal indentation
    ''', 'Set whitespace      <- this is ignorednone\\n  normal indentation'
  eq """
    Set whitespace      \\
       <- this is ignored\\  
           none
      normal indentation
    """, 'Set whitespace      <- this is ignorednone\\n  normal indentation'

  # Changed from #647, trailing backslash.
  eq '''
  Hello, World\\

  ''', 'Hello, World'
  eq '''
    \\\\
  ''', '\\\\'

  # Backslash at the beginning of a literal string.
  eq '''\\
      ok''', 'ok'
  eq '''  \\
      ok''', '  ok'

  # Same behavior in interpolated strings.
  eq """
    interpolation #{1}
      follows #{2}  \\
        too #{3}\\
    !
  """, 'interpolation 1\\n  follows 2  too 3!'
  eq """

    #{1} #{2}

    """, '\\n1 2\\n'

  # Handle escaped backslashes correctly.
  eq '''
    escaped backslash at EOL\\\\
      next line
  ''', 'escaped backslash at EOL\\\\\\n  next line'
  eq '''\\\\

     ''', '\\\\\\n'

  # Backslashes at beginning of lines.
  eq '''first line
      \\   backslash at BOL''', 'first line\\n\\   backslash at BOL'
  eq """first line\\
      \\   backslash at BOL""", 'first line\\   backslash at BOL'

  # Backslashes at end of strings.
  eq '''first line \\ ''', 'first line  '
  eq '''
    first line
    second line \\
  ''', 'first line\\nsecond line '
  eq '''
    first line
    second line
    \\
  ''', 'first line\\nsecond line'
  eq '''
    first line
    second line

      \\

  ''', 'first line\\nsecond line\\n'

  # Edge cases.
  eq '''lone

          \\



        backslash''', 'lone\\n\\n  backslash'
  eq '''\\
     ''', ''

test '#2388: \`"""\` in heredoc interpolations', ->
  eq """a heredoc #{
      "inside \\
        interpolation"
    }""", "a heredoc inside interpolation"
  eq """a#{"""b"""}c""", 'abc'
  eq """#{""""""}""", ''

test "trailing whitespace", ->
  testTrailing = (str, expected) ->
    eq CoffeeScript.eval(str.replace /\\|$/gm, ''), expected
  testTrailing '''"   |
      |
    a   |
           |
  "''', 'a'
  testTrailing """'''   |
      |
    a   |
           |
  '''""", '  \\na   \\n       '

#647
eq "''Hello, World\\\\''", '''
'\\'Hello, World\\\\\\''
'''
eq '""Hello, World\\\\""', """
"\\"Hello, World\\\\\\""
"""

test "#1273, escaping quotes at the end of heredocs.", ->
  # """\\""" no longer compiles
  eq """\\\\""", '\\\\'
  eq """\\\\\\"""", '\\\\\\"'

a = """
    basic heredoc
    on two lines
    """
ok a is "basic heredoc\\non two lines"

a = '''
    a
      "b
    c
    '''
ok a is "a\\n  \\"b\\nc"

a = """
a
 b
  c
"""
ok a is "a\\n b\\n  c"

a = '''one-liner'''
ok a is 'one-liner'

a = """
      out
      here
"""
ok a is "out\\nhere"

a = '''
       a
     b
   c
    '''
ok a is "    a\\n  b\\nc"

a = '''
a


b c
'''
ok a is "a\\n\\n\\nb c"

a = '''more"than"one"quote'''
ok a is 'more"than"one"quote'

a = '''here's an apostrophe'''
ok a is "here's an apostrophe"

a = """""surrounded by two quotes"\\""""
ok a is '""surrounded by two quotes""'

a = '''''surrounded by two apostrophes'\\''''
ok a is "''surrounded by two apostrophes''"

# The indentation detector ignores blank lines without trailing whitespace
a = """
    one
    two

    """
ok a is "one\\ntwo\\n"

eq ''' line 0
  should not be relevant
    to the indent level
''', ' line 0\\nshould not be relevant\\n  to the indent level'

eq """
  interpolation #{
 "contents"
 }
  should not be relevant
    to the indent level
""", 'interpolation contents\\nshould not be relevant\\n  to the indent level'

eq ''' '\\\\\\' ''', " '\\\\' "
eq """ "\\\\\\" """, ' "\\\\" '

eq '''  <- keep these spaces ->  ''', '  <- keep these spaces ->  '

eq '''undefined''', 'undefined'
eq """undefined""", 'undefined'


test "#1046, empty string interpolations", ->
  eq "#{ }", ''

test "strings are not callable", ->
  throws -> CoffeeScript.compile '"a"()'
  throws -> CoffeeScript.compile '"a#{b}"()'
  throws -> CoffeeScript.compile '"a" 1'
  throws -> CoffeeScript.compile '"a#{b}" 1'
  throws -> CoffeeScript.compile '''
    "a"
       k: v
  '''
  throws -> CoffeeScript.compile '''
    "a#{b}"
       k: v
  '''

test "#3795: Escape otherwise invalid characters", ->
  eq ' ', '\\u2028'
  eq ' ', '\\u2029'
  eq '\\0\\
      1', '\\x001'
  eq " ", '\\u2028'
  eq " ", '\\u2029'
  eq "\\0\\
      1", '\\x001'
  eq ''' ''', '\\u2028'
  eq ''' ''', '\\u2029'
  eq '''\\0\\
      1''', '\\x001'
  eq """ """, '\\u2028'
  eq """ """, '\\u2029'
  eq """\\0\\
      1""", '\\x001'

  a = 'a'
  eq "#{a} ", 'a\\u2028'
  eq "#{a} ", 'a\\u2029'
  eq "#{a}\\0\\
      1", 'a\\0' + '1'
  eq """#{a} """, 'a\\u2028'
  eq """#{a} """, 'a\\u2029'
  eq """#{a}\\0\\
      1""", 'a\\0' + '1'

test "#4314: Whitespace less than or equal to stripped indentation", ->
  # The odd indentation is intentional here, to test 1-space indentation.
  eq ' ', """
 #{} #{}
"""

  eq '1 2  3   4    5     end\\na 0     b', """
    #{1} #{2}  #{3}   #{4}    #{5}     end
    a #{0}     b"""

test "#4248: Unicode code point escapes", ->
  eq '\\u01ab\\u00cd', '\\u{1ab}\\u{cd}'
  eq '\\u01ab', '\\u{000001ab}'
  eq 'a\\u01ab', "#{ 'a' }\\u{1ab}"
  eq '\\u01abc', '''\\u{01ab}c'''
  eq '\\u01abc', """\\u{1ab}#{ 'c' }"""
  eq '\\udab3\\uddef', '\\u{bcdef}'
  eq '\\udab3\\uddef', '\\u{0000bcdef}'
  eq 'a\\udab3\\uddef', "#{ 'a' }\\u{bcdef}"
  eq '\\udab3\\uddefc', '''\\u{0bcdef}c'''
  eq '\\udab3\\uddefc', """\\u{bcdef}#{ 'c' }"""
  eq '\\\\u{123456}', "#{'\\\\'}#{'u{123456}'}"

  # don't rewrite code point escapes
  eqJS """
    '\\\\u{bcdef}\\\\u{abc}'
  """,
  """
    '\\\\u{bcdef}\\\\u{abc}';
  """

  eqJS """
    "#{ 'a' }\\\\u{bcdef}"
  """,
  """
    "a\\\\u{bcdef}";
  """
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# String Literals
# ---------------

# TODO: refactor string literal tests
# TODO: add indexing and method invocation tests: "string"["toString"] is String::toString, "string".toString() is "string"

# * Strings
# * Heredocs

test 'backslash escapes', ->
  eq '\\\\/\\\\\\\\', /\\/\\\\/.source

eq '(((dollars)))', '\\(\\(\\(dollars\\)\\)\\)'
eq 'one two three', 'one
 two
 three'
eq 'four five', 'four

 five'

test '#3229, multiline strings', ->
  # Separate lines by default by a single space in literal strings.
  eq 'one
      two', 'one two'
  eq 'one
      two', 'one two'
  eq '
        a
        b
    ', 'a b'
  eq '
        a
        b
    ', 'a b'
  eq 'one

        two', 'one two'
  eq 'one

        two', 'one two'
  eq "
    indentation
      doesn't
  matter", "indentation doesn't matter"
  eq "trailing ws      
    doesn't matter", "trailing ws doesn't matter"

  # Use backslashes at the end of a line to specify whitespace between lines.
  eq 'a \\
      b\\
      c  \\
      d', 'a bc  d'
  eq 'a \\
      b\\
      c  \\
      d', 'a bc  d'
  eq 'ignore  \\  
      trailing whitespace', 'ignore  trailing whitespace'

  # Backslash at the beginning of a literal string.
  eq '\\
      ok', 'ok'
  eq '  \\
      ok', '  ok'

  # #1273, empty strings.
  eq '\\
     ', ''
  eq '
     ', ''
  eq '
          ', ''
  eq '   ', '   '

  # Same behavior in interpolated strings.
  eq(
    "interpolation #{1}
      follows #{2}  \\
      too #{3}\\
      !"
    'interpolation 1 follows 2  too 3!'
  )
  eq(
    "a #{'string ' + 'inside
                 interpolation'}"
    'a string inside interpolation'
  )
  eq(
    "
      #{1}
     "
    '1'
  )

  # Handle escaped backslashes correctly.
  eq '\\\\', \`'\\\\'\`
  eq(
    'escaped backslash at EOL\\\\
      next line'
    'escaped backslash at EOL\\\\ next line'
  )
  eq '\\\\
      next line', '\\\\ next line'
  eq '\\\\
     ', '\\\\'
  eq '\\\\\\\\\\\\
     ', '\\\\\\\\\\\\'
  eq(
    "#{1}\\\\
      after interpolation"
    '1\\\\ after interpolation'
  )
  eq(
    'escaped backslash before slash\\\\  \\
      next line'
    'escaped backslash before slash\\\\  next line'
  )
  eq 'triple backslash\\\\\\
      next line', 'triple backslash\\\\next line'
  eq(
    'several escaped backslashes\\\\\\\\\\\\
      ok'
    'several escaped backslashes\\\\\\\\\\\\ ok'
  )
  eq(
    'several escaped backslashes slash\\\\\\\\\\\\\\
      ok'
    'several escaped backslashes slash\\\\\\\\\\\\ok'
  )
  eq(
    'several escaped backslashes with trailing ws \\\\\\\\\\\\   
      ok'
    'several escaped backslashes with trailing ws \\\\\\\\\\\\ ok'
  )

  # Backslashes at beginning of lines.
  eq 'first line
      \\   backslash at BOL', 'first line \\   backslash at BOL'
  eq 'first line\\
      \\   backslash at BOL', 'first line\\   backslash at BOL'

  # Backslashes at end of strings.
  eq 'first line \\ ', 'first line  '
  eq 'first line
      second line \\
      ', 'first line second line '
  eq 'first line
      second line
      \\
      ', 'first line second line'
  eq 'first line
      second line

        \\

      ', 'first line second line'

  # Edge case.
  eq 'lone

        \\

        backslash', 'lone backslash'

test '#3249, escape newlines in heredocs with backslashes', ->
  # Ignore escaped newlines
  eq(
    '''
    Set whitespace      \\
       <- this is ignored\\  
           none
      normal indentation
    '''
    'Set whitespace      <- this is ignorednone\\n  normal indentation'
  )
  eq(
    '''
    Set whitespace      \\
       <- this is ignored\\  
           none
      normal indentation
    '''
    'Set whitespace      <- this is ignorednone\\n  normal indentation'
  )

  # Changed from #647, trailing backslash.
  eq(
    '''
  Hello, World\\

  '''
    'Hello, World'
  )
  eq(
    '''
    \\\\
  '''
    '\\\\'
  )

  # Backslash at the beginning of a literal string.
  eq(
    '''\\
      ok'''
    'ok'
  )
  eq(
    '''  \\
      ok'''
    '  ok'
  )

  # Same behavior in interpolated strings.
  eq(
    """
    interpolation #{1}
      follows #{2}  \\
        too #{3}\\
    !
  """
    'interpolation 1\\n  follows 2  too 3!'
  )
  eq(
    """

    #{1} #{2}

    """
    '\\n1 2\\n'
  )

  # Handle escaped backslashes correctly.
  eq(
    '''
    escaped backslash at EOL\\\\
      next line
  '''
    'escaped backslash at EOL\\\\\\n  next line'
  )
  eq(
    '''\\\\

     '''
    '\\\\\\n'
  )

  # Backslashes at beginning of lines.
  eq(
    '''first line
      \\   backslash at BOL'''
    'first line\\n\\   backslash at BOL'
  )
  eq(
    '''first line\\
      \\   backslash at BOL'''
    'first line\\   backslash at BOL'
  )

  # Backslashes at end of strings.
  eq '''first line \\ ''', 'first line  '
  eq(
    '''
    first line
    second line \\
  '''
    'first line\\nsecond line '
  )
  eq(
    '''
    first line
    second line
    \\
  '''
    'first line\\nsecond line'
  )
  eq(
    '''
    first line
    second line

      \\

  '''
    'first line\\nsecond line\\n'
  )

  # Edge cases.
  eq(
    '''lone

          \\



        backslash'''
    'lone\\n\\n  backslash'
  )
  eq(
    '''\\
     '''
    ''
  )

test '#2388: \`"""\` in heredoc interpolations', ->
  eq(
    """a heredoc #{'inside \\
        interpolation'}"""
    'a heredoc inside interpolation'
  )
  eq """a#{'''b'''}c""", 'abc'
  eq """#{''''''}""", ''

test 'trailing whitespace', ->
  testTrailing = (str, expected) ->
    eq CoffeeScript.eval(str.replace /\\|$/gm, ''), expected
  testTrailing(
    '''"   |
      |
    a   |
           |
  "'''
    'a'
  )
  testTrailing(
    """'''   |
      |
    a   |
           |
  '''"""
    '  \\na   \\n       '
  )

#647
eq "''Hello, World\\\\''", '''
'\\'Hello, World\\\\\\''
'''
eq '""Hello, World\\\\""', '''
"\\"Hello, World\\\\\\""
'''

test '#1273, escaping quotes at the end of heredocs.', ->
  # """\\""" no longer compiles
  eq '''\\\\''', '\\\\'
  eq '''\\\\\\"''', '\\\\"'

a = '''
    basic heredoc
    on two lines
    '''
ok a is 'basic heredoc\\non two lines'

a = '''
    a
      "b
    c
    '''
ok a is 'a\\n  "b\\nc'

a = '''
a
 b
  c
'''
ok a is 'a\\n b\\n  c'

a = '''one-liner'''
ok a is 'one-liner'

a = '''
      out
      here
'''
ok a is 'out\\nhere'

a = '''
       a
     b
   c
    '''
ok a is '    a\\n  b\\nc'

a = '''
a


b c
'''
ok a is 'a\\n\\n\\nb c'

a = '''more"than"one"quote'''
ok a is 'more"than"one"quote'

a = '''here's an apostrophe'''
ok a is "here's an apostrophe"

a = '''""surrounded by two quotes"\\"'''
ok a is '""surrounded by two quotes""'

a = '''''surrounded by two apostrophes'\\''''
ok a is "''surrounded by two apostrophes''"

# The indentation detector ignores blank lines without trailing whitespace
a = '''
    one
    two

    '''
ok a is 'one\\ntwo\\n'

eq(
  ''' line 0
  should not be relevant
    to the indent level
'''
  ' line 0\\nshould not be relevant\\n  to the indent level'
)

eq(
  """
  interpolation #{'contents'}
  should not be relevant
    to the indent level
"""
  'interpolation contents\\nshould not be relevant\\n  to the indent level'
)

eq ''' '\\\\\\' ''', " '\\\\' "
eq ''' "\\\\\\" ''', ' "\\\\" '

eq '''  <- keep these spaces ->  ''', '  <- keep these spaces ->  '

eq '''undefined''', 'undefined'
eq '''undefined''', 'undefined'

test '#1046, empty string interpolations', ->
  eq "#{}", ''

test 'strings are not callable', ->
  throws -> CoffeeScript.compile '"a"()'
  throws -> CoffeeScript.compile '"a#{b}"()'
  throws -> CoffeeScript.compile '"a" 1'
  throws -> CoffeeScript.compile '"a#{b}" 1'
  throws ->
    CoffeeScript.compile '''
    "a"
       k: v
  '''
  throws ->
    CoffeeScript.compile '''
    "a#{b}"
       k: v
  '''

test '#3795: Escape otherwise invalid characters', ->
  eq ' ', '\\u2028'
  eq ' ', '\\u2029'
  eq '\\0\\
      1', '\\x001'
  eq ' ', '\\u2028'
  eq ' ', '\\u2029'
  eq '\\0\\
      1', '\\x001'
  eq ''' ''', '\\u2028'
  eq ''' ''', '\\u2029'
  eq(
    '''\\0\\
      1'''
    '\\x001'
  )
  eq ''' ''', '\\u2028'
  eq ''' ''', '\\u2029'
  eq(
    '''\\0\\
      1'''
    '\\x001'
  )

  a = 'a'
  eq "#{a} ", 'a\\u2028'
  eq "#{a} ", 'a\\u2029'
  eq(
    "#{a}\\0\\
      1"
    'a\\0' + '1'
  )
  eq """#{a} """, 'a\\u2028'
  eq """#{a} """, 'a\\u2029'
  eq(
    """#{a}\\0\\
      1"""
    'a\\0' + '1'
  )

test '#4314: Whitespace less than or equal to stripped indentation', ->
  # The odd indentation is intentional here, to test 1-space indentation.
  eq ' ', """
 #{} #{}
"""

  eq '1 2  3   4    5     end\\na 0     b', """
    #{1} #{2}  #{3}   #{4}    #{5}     end
    a #{0}     b"""

test '#4248: Unicode code point escapes', ->
  eq '\\u01ab\\u00cd', '\\u{1ab}\\u{cd}'
  eq '\\u01ab', '\\u{000001ab}'
  eq 'a\\u01ab', "#{'a'}\\u{1ab}"
  eq '\\u01abc', '''\\u{01ab}c'''
  eq '\\u01abc', """\\u{1ab}#{'c'}"""
  eq '\\udab3\\uddef', '\\u{bcdef}'
  eq '\\udab3\\uddef', '\\u{0000bcdef}'
  eq 'a\\udab3\\uddef', "#{'a'}\\u{bcdef}"
  eq '\\udab3\\uddefc', '''\\u{0bcdef}c'''
  eq '\\udab3\\uddefc', """\\u{bcdef}#{'c'}"""
  eq '\\\\u{123456}', "#{'\\\\'}#{'u{123456}'}"

  # don't rewrite code point escapes
  eqJS(
    '''
    '\\\\u{bcdef}\\\\u{abc}'
  '''
    '''
    '\\\\u{bcdef}\\\\u{abc}';
  '''
  )

  eqJS(
    """
    "#{'a'}\\\\u{bcdef}"
  """
    '''
    "a\\\\u{bcdef}";
  '''
  )

`;

exports[`tagged_template_literals.coffee 1`] = `
# Tagged template literals
# ------------------------

# NOTES:
# A tagged template literal is a string that is passed to a prefixing function for
# post-processing. There's a bunch of different angles that need testing:
# - Prefixing function, which can be any form of function call:
#   - function: func'Hello'
#   - object property with dot notation: outerobj.obj.func'Hello'
#   - object property with bracket notation: outerobj['obj']['func']'Hello'
# - String form: single quotes, double quotes and block strings
# - String is single-line or multi-line
# - String is interpolated or not

func = (text, expressions...) ->
  "text: [#{text.join '|'}] expressions: [#{expressions.join '|'}]"

outerobj =
  obj:
    func: func
    f: -> func

# Example use
test "tagged template literal for html templating", ->
  html = (htmlFragments, expressions...) ->
    htmlFragments.reduce (fullHtml, htmlFragment, i) ->
      fullHtml + "#{expressions[i - 1]}#{htmlFragment}"

  state =
    name: 'Greg'
    adjective: 'awesome'

  eq """
      <p>
        Hi Greg. You're looking awesome!
      </p>
    """,
    html"""
      <p>
        Hi #{state.name}. You're looking #{state.adjective}!
      </p>
    """

# Simple, non-interpolated strings
test "tagged template literal with a single-line single-quote string", ->
  eq 'text: [single-line single quotes] expressions: []',
  func'single-line single quotes'

test "tagged template literal with a single-line double-quote string", ->
  eq 'text: [single-line double quotes] expressions: []',
  func"single-line double quotes"

test "tagged template literal with a single-line single-quote block string", ->
  eq 'text: [single-line block string] expressions: []',
  func'''single-line block string'''

test "tagged template literal with a single-line double-quote block string", ->
  eq 'text: [single-line block string] expressions: []',
  func"""single-line block string"""

test "tagged template literal with a multi-line single-quote string", ->
  eq 'text: [multi-line single quotes] expressions: []',
  func'multi-line
                                                              single quotes'

test "tagged template literal with a multi-line double-quote string", ->
  eq 'text: [multi-line double quotes] expressions: []',
  func"multi-line
       double quotes"

test "tagged template literal with a multi-line single-quote block string", ->
  eq 'text: [multi-line\\nblock string] expressions: []',
  func'''
      multi-line
      block string
      '''

test "tagged template literal with a multi-line double-quote block string", ->
  eq 'text: [multi-line\\nblock string] expressions: []',
  func"""
      multi-line
      block string
      """

# Interpolated strings with expressions
test "tagged template literal with a single-line double-quote interpolated string", ->
  eq 'text: [single-line | double quotes | interpolation] expressions: [36|42]',
  func"single-line #{6 * 6} double quotes #{6 * 7} interpolation"

test "tagged template literal with a single-line double-quote block interpolated string", ->
  eq 'text: [single-line | block string | interpolation] expressions: [incredible|48]',
  func"""single-line #{'incredible'} block string #{6 * 8} interpolation"""

test "tagged template literal with a multi-line double-quote interpolated string", ->
  eq 'text: [multi-line | double quotes | interpolation] expressions: [2|awesome]',
  func"multi-line #{4/2}
       double quotes #{'awesome'} interpolation"

test "tagged template literal with a multi-line double-quote block interpolated string", ->
  eq 'text: [multi-line |\\nblock string |] expressions: [/abc/|32]',
  func"""
      multi-line #{/abc/}
      block string #{2 * 16}
      """


# Tagged template literal must use a callable function
test "tagged template literal dot notation recognized as a callable function", ->
  eq 'text: [dot notation] expressions: []',
  outerobj.obj.func'dot notation'

test "tagged template literal bracket notation recognized as a callable function", ->
  eq 'text: [bracket notation] expressions: []',
  outerobj['obj']['func']'bracket notation'

test "tagged template literal mixed dot and bracket notation recognized as a callable function", ->
  eq 'text: [mixed notation] expressions: []',
  outerobj['obj'].func'mixed notation'


# Edge cases
test "tagged template literal with an empty string", ->
  eq 'text: [] expressions: []',
  func''

test "tagged template literal with an empty interpolated string", ->
  eq 'text: [] expressions: []',
  func"#{}"

test "tagged template literal as single interpolated expression", ->
  eq 'text: [|] expressions: [3]',
  func"#{3}"

test "tagged template literal with an interpolated string that itself contains an interpolated string", ->
  eq 'text: [inner | string] expressions: [interpolated]',
  func"inner #{"#{'inter'}polated"} string"

test "tagged template literal with an interpolated string that contains a tagged template literal", ->
  eq 'text: [inner tagged | literal] expressions: [text: [|] expressions: [template]]',
  func"inner tagged #{func"#{'template'}"} literal"

test "tagged template literal with backticks", ->
  eq 'text: [ES template literals look like this: \`foo bar\`] expressions: []',
  func"ES template literals look like this: \`foo bar\`"

test "tagged template literal with escaped backticks", ->
  eq 'text: [ES template literals look like this: \\\\\`foo bar\\\\\`] expressions: []',
  func"ES template literals look like this: \\\\\`foo bar\\\\\`"

test "tagged template literal with unnecessarily escaped backticks", ->
  eq 'text: [ES template literals look like this: \`foo bar\`] expressions: []',
  func"ES template literals look like this: \\\`foo bar\\\`"

test "tagged template literal with ES interpolation", ->
  eq 'text: [ES template literals also look like this: \`3 + 5 = \${3+5}\`] expressions: []',
  func"ES template literals also look like this: \`3 + 5 = \${3+5}\`"

test "tagged template literal with both ES and CoffeeScript interpolation", ->
  eq "text: [ES template literals also look like this: \`3 + 5 = \${3+5}\` which equals |] expressions: [8]",
  func"ES template literals also look like this: \`3 + 5 = \${3+5}\` which equals #{3+5}"

test "tagged template literal with escaped ES interpolation", ->
  eq 'text: [ES template literals also look like this: \`3 + 5 = \\\\\${3+5}\`] expressions: []',
  func"ES template literals also look like this: \`3 + 5 = \\\\\${3+5}\`"

test "tagged template literal with unnecessarily escaped ES interpolation", ->
  eq 'text: [ES template literals also look like this: \`3 + 5 = \${3+5}\`] expressions: []',
  func"ES template literals also look like this: \`3 + 5 = \\\${3+5}\`"

test "tagged template literal special escaping", ->
  eq 'text: [\` \` \\\\\` \\\\\` \\\\\\\\\` $ { \${ \${ \\\\\${ \\\\\${ \\\\\\\\\${ | \` \${] expressions: [1]',
  func"\` \\\` \\\\\` \\\\\\\` \\\\\\\\\` $ { \${ \\\${ \\\\\${ \\\\\\\${ \\\\\\\\\${ #{1} \` \${"

test '#4467: tagged template literal call recognized as a callable function', ->
  eq 'text: [dot notation] expressions: []',
  outerobj.obj.f()'dot notation'

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Tagged template literals
# ------------------------

# NOTES:
# A tagged template literal is a string that is passed to a prefixing function for
# post-processing. There's a bunch of different angles that need testing:
# - Prefixing function, which can be any form of function call:
#   - function: func'Hello'
#   - object property with dot notation: outerobj.obj.func'Hello'
#   - object property with bracket notation: outerobj['obj']['func']'Hello'
# - String form: single quotes, double quotes and block strings
# - String is single-line or multi-line
# - String is interpolated or not

func = (text, expressions...) ->
  "text: [#{text.join '|'}] expressions: [#{expressions.join '|'}]"

outerobj =
  obj:
    func: func
    f: -> func

# Example use
test 'tagged template literal for html templating', ->
  html = (htmlFragments, expressions...) ->
    htmlFragments.reduce (fullHtml, htmlFragment, i) ->
      fullHtml + "#{expressions[i - 1]}#{htmlFragment}"

  state =
    name: 'Greg'
    adjective: 'awesome'

  eq(
    '''
      <p>
        Hi Greg. You're looking awesome!
      </p>
    '''
    html"""
      <p>
        Hi #{state.name}. You're looking #{state.adjective}!
      </p>
    """
  )

# Simple, non-interpolated strings
test 'tagged template literal with a single-line single-quote string', ->
  eq(
    'text: [single-line single quotes] expressions: []'
    func'single-line single quotes'
  )

test 'tagged template literal with a single-line double-quote string', ->
  eq(
    'text: [single-line double quotes] expressions: []'
    func"single-line double quotes"
  )

test 'tagged template literal with a single-line single-quote block string', ->
  eq(
    'text: [single-line block string] expressions: []'
    func'''single-line block string'''
  )

test 'tagged template literal with a single-line double-quote block string', ->
  eq(
    'text: [single-line block string] expressions: []'
    func'''single-line block string'''
  )

test 'tagged template literal with a multi-line single-quote string', ->
  eq(
    'text: [multi-line single quotes] expressions: []'
    func'multi-line
                                                              single quotes'
  )

test 'tagged template literal with a multi-line double-quote string', ->
  eq(
    'text: [multi-line double quotes] expressions: []'
    func"multi-line
       double quotes"
  )

test 'tagged template literal with a multi-line single-quote block string', ->
  eq(
    'text: [multi-line\\nblock string] expressions: []'
    func'''
      multi-line
      block string
      '''
  )

test 'tagged template literal with a multi-line double-quote block string', ->
  eq(
    'text: [multi-line\\nblock string] expressions: []'
    func'''
      multi-line
      block string
      '''
  )

# Interpolated strings with expressions
test 'tagged template literal with a single-line double-quote interpolated string', ->
  eq(
    'text: [single-line | double quotes | interpolation] expressions: [36|42]'
    func"single-line #{6 * 6} double quotes #{6 * 7} interpolation"
  )

test 'tagged template literal with a single-line double-quote block interpolated string', ->
  eq(
    'text: [single-line | block string | interpolation] expressions: [incredible|48]'
    func"""single-line #{'incredible'} block string #{6 * 8} interpolation"""
  )

test 'tagged template literal with a multi-line double-quote interpolated string', ->
  eq(
    'text: [multi-line | double quotes | interpolation] expressions: [2|awesome]'
    func"multi-line #{4 / 2}
       double quotes #{'awesome'} interpolation"
  )

test 'tagged template literal with a multi-line double-quote block interpolated string', ->
  eq(
    'text: [multi-line |\\nblock string |] expressions: [/abc/|32]'
    func"""
      multi-line #{/abc/}
      block string #{2 * 16}
      """
  )

# Tagged template literal must use a callable function
test 'tagged template literal dot notation recognized as a callable function', ->
  eq 'text: [dot notation] expressions: []', outerobj.obj.func'dot notation'

test 'tagged template literal bracket notation recognized as a callable function', ->
  eq(
    'text: [bracket notation] expressions: []'
    outerobj['obj']['func']'bracket notation'
  )

test 'tagged template literal mixed dot and bracket notation recognized as a callable function', ->
  eq(
    'text: [mixed notation] expressions: []'
    outerobj['obj'].func'mixed notation'
  )

# Edge cases
test 'tagged template literal with an empty string', ->
  eq 'text: [] expressions: []', func''

test 'tagged template literal with an empty interpolated string', ->
  eq 'text: [] expressions: []', func"#{}"

test 'tagged template literal as single interpolated expression', ->
  eq 'text: [|] expressions: [3]', func"#{3}"

test 'tagged template literal with an interpolated string that itself contains an interpolated string', ->
  eq(
    'text: [inner | string] expressions: [interpolated]'
    func"inner #{"#{'inter'}polated"} string"
  )

test 'tagged template literal with an interpolated string that contains a tagged template literal', ->
  eq(
    'text: [inner tagged | literal] expressions: [text: [|] expressions: [template]]'
    func"inner tagged #{func"#{'template'}"} literal"
  )

test 'tagged template literal with backticks', ->
  eq(
    'text: [ES template literals look like this: \`foo bar\`] expressions: []'
    func"ES template literals look like this: \`foo bar\`"
  )

test 'tagged template literal with escaped backticks', ->
  eq(
    'text: [ES template literals look like this: \\\\\`foo bar\\\\\`] expressions: []'
    func"ES template literals look like this: \\\\\`foo bar\\\\\`"
  )

test 'tagged template literal with unnecessarily escaped backticks', ->
  eq(
    'text: [ES template literals look like this: \`foo bar\`] expressions: []'
    func"ES template literals look like this: \\\`foo bar\\\`"
  )

test 'tagged template literal with ES interpolation', ->
  eq(
    'text: [ES template literals also look like this: \`3 + 5 = \${3+5}\`] expressions: []'
    func"ES template literals also look like this: \`3 + 5 = \${3+5}\`"
  )

test 'tagged template literal with both ES and CoffeeScript interpolation', ->
  eq(
    'text: [ES template literals also look like this: \`3 + 5 = \${3+5}\` which equals |] expressions: [8]'
    func"ES template literals also look like this: \`3 + 5 = \${3+5}\` which equals #{3 +
      5}"
  )

test 'tagged template literal with escaped ES interpolation', ->
  eq(
    'text: [ES template literals also look like this: \`3 + 5 = \\\\\${3+5}\`] expressions: []'
    func"ES template literals also look like this: \`3 + 5 = \\\\\${3+5}\`"
  )

test 'tagged template literal with unnecessarily escaped ES interpolation', ->
  eq(
    'text: [ES template literals also look like this: \`3 + 5 = \${3+5}\`] expressions: []'
    func"ES template literals also look like this: \`3 + 5 = \\\${3+5}\`"
  )

test 'tagged template literal special escaping', ->
  eq(
    'text: [\` \` \\\\\` \\\\\` \\\\\\\\\` $ { \${ \${ \\\\\${ \\\\\${ \\\\\\\\\${ | \` \${] expressions: [1]'
    func"\` \\\` \\\\\` \\\\\\\` \\\\\\\\\` $ { \${ \\\${ \\\\\${ \\\\\\\${ \\\\\\\\\${ #{1} \` \${"
  )

test '#4467: tagged template literal call recognized as a callable function', ->
  eq 'text: [dot notation] expressions: []', outerobj.obj.f()'dot notation'

`;
